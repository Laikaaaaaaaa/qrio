<!doctype html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Qrio - Trình chỉnh sửa mã QR miễn phí</title>
  <meta name="description" content="Thiết kế mã QR chuyên nghiệp với trình chỉnh sửa mạnh mẽ. Tùy chỉnh màu sắc, kiểu dáng, thêm logo và xuất ảnh HD." />
  <meta name="robots" content="index, follow" />
  <link rel="canonical" href="https://qrio.vn/edit" />
  
  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://qrio.vn/edit" />
  <meta property="og:title" content="Qrio - Trình chỉnh sửa mã QR" />
  <meta property="og:description" content="Thiết kế mã QR chuyên nghiệp với trình chỉnh sửa mạnh mẽ." />
  <meta property="og:image" content="https://qrio.vn/static/logo/logo.png" />
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Qrio Editor" />
  <meta name="twitter:description" content="Thiết kế mã QR chuyên nghiệp." />
  
  <!-- Theme color -->
  <meta name="theme-color" content="#7c3aed" />
  
  <link rel="icon" type="image/x-icon" href="/static/logo/favicon_io%20(3)/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/static/logo/favicon_io%20(3)/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/static/logo/favicon_io%20(3)/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/static/logo/favicon_io%20(3)/apple-touch-icon.png">
  <link rel="manifest" href="/static/logo/favicon_io%20(3)/site.webmanifest">
  <link rel="icon" type="image/png" sizes="48x48" href="/static/logo/logo.png">
  <link rel="shortcut icon" href="/static/logo/logo.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700;800&family=Roboto:wght@400;700&family=Open+Sans:wght@400;700&family=Montserrat:wght@400;700&family=Playfair+Display:wght@400;700&family=Dancing+Script:wght@400;700&family=Pacifico&family=Lobster&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: 'Be Vietnam Pro', system-ui, sans-serif;
      background: #1e1e2e;
      color: #fff;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    /* Leaflet marker icon (inline SVG) */
    .qrio-leaflet-marker {
      background: transparent;
      border: none;
    }

    .qrio-leaflet-marker svg {
      display: block;
      filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.35));
    }

    .sovereignty-label {
      background: rgba(30, 30, 46, 0.85);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 12px;
      font-weight: 700;
      white-space: nowrap;
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.35);
      pointer-events: none;
    }

    :root {
      --sidebar-width: 320px;
      --mobile-header-height: 44px;
      --floating-toolbar-height: 52px;
      --floating-toolbar-gap: 12px;
      --desktop-floating-top: 76px;
      --mobile-main-top: calc(var(--mobile-header-height) + var(--floating-toolbar-height) + var(--floating-toolbar-gap));
    }

    /* LAYOUT */
    .app-layout {
      display: flex;
      height: 100vh;
    }

    /* SIDEBAR */
    .sidebar {
      width: var(--sidebar-width);
      background: #2a2a3e;
      display: flex;
      flex-direction: column;
      border-right: 1px solid #3a3a50;
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 14px 18px;
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-box {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background: transparent;
    }

    .logo-box img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .sidebar-header h1 {
      font-size: 16px;
      font-weight: 700;
    }

    .sidebar-home-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 8px 14px;
      background: rgba(255,255,255,0.15);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      transition: background 0.15s;
    }

    .sidebar-home-btn:hover {
      background: rgba(255,255,255,0.25);
    }

    /* TABS */
    .sidebar-tabs {
      display: flex;
      border-bottom: 1px solid #3a3a50;
    }

    .sidebar-tabs.hidden {
      display: none;
    }

    .sidebar-tab {
      flex: 1;
      padding: 12px;
      text-align: center;
      font-size: 11px;
      font-weight: 600;
      color: #888;
      cursor: pointer;
      border: none;
      background: transparent;
      transition: 0.2s;
    }

    .sidebar-tab:hover {
      color: #fff;
    }

    .sidebar-tab.active {
      color: #7c3aed;
      border-bottom: 2px solid #7c3aed;
      margin-bottom: -1px;
    }

    /* SIDEBAR CONTENT */
    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .sidebar-panel {
      display: none;
    }

    .sidebar-panel.active {
      display: block;
    }

    .section {
      margin-bottom: 16px;
      background: #232336;
      border-radius: 8px;
      padding: 12px;
    }
    
    .mobile-bottom-controls {
      display: none;
      align-items: center;
      gap: 10px;
      flex: 1;
      min-width: 0;
    }
    
    .mobile-bottom-controls input[type="text"] {
      flex: 1;
      min-width: 0;
      max-width: 45vw;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.20);
      color: #fff;
      font-size: 12px;
      outline: none;
    }
    
    .mobile-zoom-slider {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.20);
      flex: 1;
      min-width: 0;
      max-width: 45vw;
    }
    
    .mobile-zoom-slider input[type="range"] {
      flex: 1;
      min-width: 0;
    }
    
    .mobile-zoom-slider span {
      font-size: 11px;
      color: rgba(255,255,255,0.85);
      min-width: 44px;
      text-align: right;
      flex-shrink: 0;
    }

    .section-title {
      font-size: 11px;
      font-weight: 700;
      color: #7c3aed;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid #3a3a50;
    }

    /* QR TYPES */
    .types-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .type-btn {
      padding: 10px 6px;
      border-radius: 6px;
      background: #3a3a50;
      border: 2px solid transparent;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: 0.2s;
      color: #aaa;
    }

    .type-btn:hover {
      background: #4a4a60;
      color: #fff;
    }

    .type-btn.active {
      background: #4f46e5;
      border-color: #7c3aed;
      color: #fff;
    }

    .type-btn .icon {
      font-size: 16px;
    }

    .type-btn .label {
      font-size: 9px;
      font-weight: 600;
    }

    /* QR image */
    .qr-content img.qr-base {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* FORMS */
    .form-group {
      margin-bottom: 10px;
    }

    .form-group:last-child {
      margin-bottom: 0;
    }

    .form-group label {
      display: block;
      font-size: 10px;
      font-weight: 600;
      color: #aaa;
      margin-bottom: 4px;
    }

    .form-group input[type="text"],
    .form-group input[type="url"],
    .form-group input[type="email"],
    .form-group input[type="tel"],
    .form-group input[type="number"],
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 8px 10px;
      border: 2px solid #3a3a50;
      border-radius: 6px;
      font-size: 11px;
      font-family: inherit;
      background: #1e1e2e;
      color: #fff;
      transition: 0.2s;
    }

    .form-group input:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline: none;
      border-color: #7c3aed;
    }

    /* Custom Font Picker */
    .font-picker-wrapper {
      position: relative;
    }
    .font-picker-input {
      cursor: pointer;
    }
    .font-picker-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 250px;
      overflow-y: auto;
      background: #1e1e2e;
      border: 2px solid #7c3aed;
      border-radius: 6px;
      z-index: 1000;
      display: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }
    .font-picker-dropdown.show {
      display: block;
      animation: fadeInSlide 0.2s ease;
    }
    @keyframes fadeInSlide {
      from { opacity: 0; transform: translateY(-8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .font-picker-item {
      padding: 10px 12px;
      cursor: pointer;
      font-size: 14px;
      color: #e2e8f0;
      border-bottom: 1px solid #2a2a3a;
      transition: background 0.15s;
    }
    .font-picker-item:last-child {
      border-bottom: none;
    }
    .font-picker-item:hover {
      background: #2d2d40;
    }
    .font-picker-item.selected {
      background: #4f46e5;
      color: #fff;
    }
    .font-picker-search {
      position: sticky;
      top: 0;
      background: #1e1e2e;
      padding: 8px;
      border-bottom: 1px solid #3a3a50;
    }
    .font-picker-search input {
      width: 100%;
      padding: 8px 10px;
      border: 2px solid #3a3a50;
      border-radius: 6px;
      background: #2a2a3a;
      color: #fff;
      font-size: 12px;
    }
    .font-picker-search input:focus {
      outline: none;
      border-color: #7c3aed;
    }

    .style-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }

    .style-btn,
    .finder-btn {
      border: 1px solid #3a3a50;
      background: #1f1f2f;
      color: #fff;
      border-radius: 8px;
      padding: 10px;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      transition: 0.2s;
    }

    .style-btn.active,
    .finder-btn.active {
      border-color: #7c3aed;
      background: #332c5c;
      color: #e5dbff;
    }

    .style-btn i,
    .finder-btn i {
      font-size: 20px;
    }

    .finder-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 6px;
      margin-top: 8px;
    }

    .finder-group {
      margin-bottom: 12px;
    }

    .custom-shape {
      font-size: 11px;
      color: #aaa;
      margin-top: 6px;
    }

    .form-group input[type="range"] {
      width: 100%;
      cursor: pointer;
    }

    .version-hint {
      font-size: 11px;
      color: #aaa;
      margin-top: 4px;
    }

    .form-group textarea {
      min-height: 50px;
      resize: vertical;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .special-form {
      display: none;
    }

    .special-form.active {
      display: block;
    }

    /* COLOR PICKER */
    .color-picker-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .color-input-wrap {
      position: relative;
      width: 36px;
      height: 36px;
      flex-shrink: 0;
      border-radius: 6px;
      overflow: hidden;
      border: 2px solid #3a3a50;
    }

    .color-input-wrap input[type="color"] {
      width: 50px;
      height: 50px;
      border: none;
      cursor: pointer;
      padding: 0;
      margin: -7px;
    }

    .color-presets {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .color-dot {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: 0.15s;
    }

    .color-dot:hover {
      transform: scale(1.1);
    }

    .color-dot.active {
      border-color: #fff;
      box-shadow: 0 0 0 2px #7c3aed;
    }

    /* PILLS */
    .pill-row {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .pill {
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      background: #3a3a50;
      color: #aaa;
      border: none;
      transition: 0.15s;
    }

    .pill:hover {
      background: #4a4a60;
      color: #fff;
    }

    .pill.active {
      background: #4f46e5;
      color: #fff;
    }

    /* SHAPES GRID */
    .shapes-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .shape-preview {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 10px 6px;
      background: #3a3a50;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
      border: 2px solid transparent;
    }

    .shape-preview:hover {
      background: #4a4a60;
      border-color: #6366f1;
      transform: translateY(-2px);
    }

    .shape-thumb {
      width: 36px;
      height: 36px;
      flex-shrink: 0;
    }

    .shape-thumb.svg-thumb {
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      color: #fff;
    }

    .shape-thumb svg,
    .shape-thumb i {
      width: 100%;
      height: 100%;
      display: block;
    }

    .shape-preview span {
      font-size: 10px;
      color: #aaa;
      text-align: center;
      line-height: 1.2;
    }

    .shape-preview:hover span {
      color: #fff;
    }

    /* MAIN AREA */
    .main-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #1e1e2e;
      min-width: 0;
    }

    /* TOOLBAR */
    .toolbar {
      padding: 8px 16px;
      background: #2a2a3e;
      border-bottom: 1px solid #3a3a50;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .toolbar-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .selection-hint {
      font-size: 10px;
      color: #aaa;
      margin-left: 10px;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 10px;
      border-right: 1px solid #3a3a50;
    }

    .toolbar-group:last-child {
      border-right: none;
    }

    .toolbar-label {
      font-size: 10px;
      color: #888;
    }

    .toolbar-input {
      padding: 5px 8px;
      border: 1px solid #3a3a50;
      border-radius: 4px;
      background: #1e1e2e;
      color: #fff;
      font-size: 11px;
      width: 100px;
    }

    .toolbar-input:focus {
      outline: none;
      border-color: #7c3aed;
    }

    .toolbar-btn {
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      background: #3a3a50;
      color: #fff;
      transition: 0.15s;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .toolbar-btn:hover {
      background: #4a4a60;
    }

    .toolbar-btn.primary {
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
    }

    .toolbar-btn.primary:hover {
      opacity: 0.9;
    }

    /* ZOOM CONTROLS */
    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .zoom-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: none;
      background: #3a3a50;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .zoom-btn:hover {
      background: #4a4a60;
    }

    .zoom-value {
      font-size: 11px;
      color: #aaa;
      min-width: 45px;
      text-align: center;
    }

    /* CANVAS AREA */
    /* Canvas uses top-left origin so elements don't shift when resizing */
    .canvas-wrapper {
      flex: 1;
      overflow: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      position: relative;
      background:
        linear-gradient(45deg, #252535 25%, transparent 25%),
        linear-gradient(-45deg, #252535 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #252535 75%),
        linear-gradient(-45deg, transparent 75%, #252535 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      background-color: #1e1e2e;
    }

    .canvas-stage {
      position: relative;
      flex-shrink: 0;
      margin: 0 auto;
    }

    /* CANVAS */
    .canvas {
      position: absolute;
      left: 0;
      top: 0;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      transform-origin: top left; /* top-left origin keeps elements stable when resizing */
      overflow: hidden;
      transition: outline 0.15s ease;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      flex-shrink: 0;
      margin: 0;
    }

    /* SHAPES */
    .shape-base { width: 100%; height: 100%; }
    .shape-base.shape-svg {
      display: flex;
      align-items: center;
      justify-content: center;
      color: inherit;
    }

    .shape-base.shape-svg svg,
    .shape-base.shape-svg i {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .canvas * {
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    .canvas-empty-state {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 30;
    }

    .canvas-empty-card {
      pointer-events: auto;
      background: rgba(17, 24, 39, 0.8);
      border: 1px dashed #3a3a50;
      border-radius: 14px;
      padding: 18px 20px;
      min-width: 220px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      animation: fadeInEmpty 0.25s ease;
    }

    .canvas-empty-card i {
      display: inline-flex;
      width: 46px;
      height: 46px;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      color: #fff;
      margin-bottom: 10px;
    }

    .canvas-empty-card .title {
      font-weight: 700;
      font-size: 16px;
      color: #e2e8f0;
      margin-bottom: 4px;
    }

    .canvas-empty-card .subtitle {
      font-size: 12px;
      color: #94a3b8;
      margin-bottom: 12px;
    }

    .canvas-empty-card .cta-btn {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      background: linear-gradient(135deg, #10b981, #22c55e);
      color: #0b3b33;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .canvas-empty-card .cta-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(16, 185, 129, 0.35);
    }

    @keyframes fadeInEmpty {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .canvas.selected {
      outline: 2px solid #10b981;
      outline-offset: 4px;
    }

    /* WRAPPER SELECTION BOX */
    .wrapper-selection-box {
      position: absolute;
      border: 1px dashed rgba(99, 102, 241, 0.8);
      background: rgba(99, 102, 241, 0.1);
      pointer-events: none;
      z-index: 25;
    }

    /* GUIDES */
    .guides-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
      display: block;
    }

    .guide {
      position: absolute;
      background: transparent;
      border-top: 1px dashed #f43f5e;
      z-index: 51;
      pointer-events: none;
      opacity: 0.8;
    }

    .guide.horizontal {
      height: 0;
      left: 0;
      right: 0;
      width: 100%;
    }

    .guide.vertical {
      width: 0;
      border-left: 1px dashed #f43f5e;
      border-top: none;
      top: 0;
      bottom: 0;
      height: 100%;
    }

    .selection-box {
      position: absolute;
      border: 1px dashed rgba(99, 102, 241, 0.8);
      background: rgba(99, 102, 241, 0.15);
      pointer-events: none;
      z-index: 45;
    }

    /* CANVAS ELEMENT */
    .canvas-element {
      position: absolute;
      cursor: move;
      display: flex;
      align-items: center;
      justify-content: center;
      transform-origin: center center;
    }

    .canvas-element.selected {
      outline: 2px solid #4f46e5;
      outline-offset: 2px;
    }

    .canvas-element.selected::after {
      content: '';
      position: absolute;
      inset: -4px;
      border: 1px dashed #7c3aed;
      pointer-events: none;
    }

    /* When multi-selected, hide individual handles - only show border */
    .canvas-element.selected.multi-selected .resize-handle,
    .canvas-element.selected.multi-selected .rotation-handle,
    .canvas-element.selected.multi-selected .rotation-line {
      display: none !important;
    }

    .canvas-element.selected.multi-selected::after {
      border: none;
    }

    /* RESIZE HANDLES - use inverse scale to maintain consistent size at any zoom */
    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #fff;
      border: 2px solid #4f46e5;
      border-radius: 2px;
      z-index: 10;
      transform-origin: center center;
    }

    .resize-handle.nw {
      top: -5px;
      left: -5px;
      cursor: nw-resize;
    }

    .resize-handle.ne {
      top: -5px;
      right: -5px;
      cursor: ne-resize;
    }

    .resize-handle.sw {
      bottom: -5px;
      left: -5px;
      cursor: sw-resize;
    }

    .resize-handle.se {
      bottom: -5px;
      right: -5px;
      cursor: se-resize;
    }

    .resize-handle.n {
      top: -5px;
      left: 50%;
      cursor: n-resize;
    }

    .resize-handle.s {
      bottom: -5px;
      left: 50%;
      cursor: s-resize;
    }

    .resize-handle.w {
      left: -5px;
      top: 50%;
      cursor: w-resize;
    }

    .resize-handle.e {
      right: -5px;
      top: 50%;
      cursor: e-resize;
    }

    /* ROTATION HANDLE */
    /* ROTATION HANDLE - use inverse scale to maintain consistent size */
    .rotation-handle {
      position: absolute;
      top: -35px;
      left: 50%;
      width: 20px;
      height: 20px;
      background: #fff;
      border: 2px solid #4f46e5;
      border-radius: 50%;
      cursor: grab;
      z-index: 15;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #4f46e5;
      transform-origin: center center;
    }
    
    .rotation-handle:hover {
      background: #4f46e5;
      color: #fff;
    }
    
    .rotation-handle:active {
      cursor: grabbing;
    }
    
    .rotation-line {
      position: absolute;
      top: -15px;
      left: 50%;
      width: 1px;
      height: 15px;
      background: #4f46e5;
      z-index: 14;
      transform-origin: center top;
    }

    /* MULTI-SELECT BOUNDING BOX */
    .multi-select-box {
      position: absolute;
      border: 2px solid #10b981;
      background: rgba(16, 185, 129, 0.05);
      pointer-events: auto;
      z-index: 100;
    }
    
    .multi-select-box .ms-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #fff;
      border: 2px solid #10b981;
      border-radius: 2px;
      z-index: 101;
      transform-origin: center center;
    }
    
    .multi-select-box .ms-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
    .multi-select-box .ms-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
    .multi-select-box .ms-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
    .multi-select-box .ms-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
    .multi-select-box .ms-handle.n { top: -5px; left: 50%; cursor: n-resize; }
    .multi-select-box .ms-handle.s { bottom: -5px; left: 50%; cursor: s-resize; }
    .multi-select-box .ms-handle.w { left: -5px; top: 50%; cursor: w-resize; }
    .multi-select-box .ms-handle.e { right: -5px; top: 50%; cursor: e-resize; }

    /* CONTEXT MENU */
    .context-menu {
      position: fixed;
      background: #2a2a3e;
      border: 1px solid #3a3a50;
      border-radius: 8px;
      padding: 6px 0;
      min-width: 180px;
      z-index: 9999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }
    
    .context-menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 14px;
      cursor: pointer;
      font-size: 12px;
      color: #e2e8f0;
      transition: background 0.15s;
    }
    
    .context-menu-item:hover {
      background: #3a3a50;
    }
    
    .context-menu-item i {
      width: 16px;
      text-align: center;
      color: #94a3b8;
    }
    
    .context-menu-item .shortcut {
      margin-left: auto;
      font-size: 10px;
      color: #64748b;
    }
    
    .context-menu-divider {
      height: 1px;
      background: #3a3a50;
      margin: 4px 0;
    }
    
    .context-menu-submenu {
      position: relative;
    }
    
    .context-menu-submenu::after {
      content: '▸';
      position: absolute;
      right: 10px;
      color: #64748b;
    }

    /* MOBILE TOP TOOLBAR */
    .mobile-toolbar {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 44px;
      background: #1e1e2e;
      border-bottom: 1px solid #3a3a50;
      z-index: 100;
      padding: 0 8px;
      align-items: center;
      gap: 2px;
      overflow-x: auto;
    }
    
    .mobile-toolbar::-webkit-scrollbar {
      display: none;
    }
    
    .mobile-toolbar-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      background: transparent;
      border: none;
      color: #94a3b8;
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      min-width: 40px;
      white-space: nowrap;
    }
    
    .mobile-toolbar-btn:hover,
    .mobile-toolbar-btn:active {
      background: #3a3a50;
      color: #fff;
    }
    
    .mobile-toolbar-btn span {
      font-size: 9px;
      margin-top: 2px;
    }
    
    .mobile-toolbar-divider {
      width: 1px;
      height: 24px;
      background: #3a3a50;
      margin: 0 4px;
    }

    /* FLOATING TOOLBAR (like Canva) - appears when elements selected */
    .floating-toolbar {
      position: fixed;
      top: var(--desktop-floating-top);
      left: 0;
      transform: none;
      display: none;
      align-items: center;
      gap: 4px;
      background: #1e1e2e;
      border: 1px solid #3a3a50;
      border-radius: 12px;
      padding: 8px 12px;
      z-index: 500;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    
    .floating-toolbar.visible {
      display: flex;
    }
    
    .floating-toolbar-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      background: transparent;
      border: none;
      color: #94a3b8;
      font-size: 16px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.15s;
    }
    
    .floating-toolbar-btn:hover {
      background: #3a3a50;
      color: #fff;
    }
    
    .floating-toolbar-btn.active {
      background: #4f46e5;
      color: #fff;
    }
    
    .floating-toolbar-divider {
      width: 1px;
      height: 24px;
      background: #3a3a50;
      margin: 0 4px;
    }
    
    .floating-toolbar-dropdown {
      position: relative;
    }
    
    .floating-toolbar-menu {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #2a2a3e;
      border: 1px solid #3a3a50;
      border-radius: 8px;
      padding: 6px 0;
      min-width: 140px;
      margin-top: 8px;
      display: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      max-height: 70vh;
      overflow-y: auto;
      z-index: 1000;
    }
    
    /* Position the more-menu on the right side */
    #more-menu {
      left: auto;
      right: 0;
      transform: none;
    }

    /* When showing the 3-dots menu inside the mobile bottom panel */
    #panel-more #more-menu {
      position: static;
      left: auto;
      right: auto;
      top: auto;
      transform: none;
      margin-top: 0;
      display: block;
      max-height: none;
      box-shadow: none;
      border: 1px solid #3a3a50;
    }
    
    .floating-toolbar-menu.show {
      display: block;
      animation: fadeInMenu 0.15s ease;
    }
    
    @keyframes fadeInMenu {
      from { opacity: 0; transform: translateY(-4px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .floating-toolbar-menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 9px 14px;
      font-size: 12px;
      color: #e2e8f0;
      cursor: pointer;
      transition: background 0.1s;
    }
    
    .floating-toolbar-menu-item:hover {
      background: #3a3a50;
    }
    
    .floating-toolbar-menu-item i {
      width: 16px;
      text-align: center;
      color: #94a3b8;
      font-size: 12px;
    }
    
    .floating-toolbar-menu-item:hover i {
      color: #e2e8f0;
    }

    /* MOBILE HEADER */
    .mobile-header {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 44px;
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      z-index: 200;
      padding: 0 12px;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .mobile-header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .mobile-header .home-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(255,255,255,0.15);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      transition: background 0.15s;
    }

    .mobile-header .home-btn:hover {
      background: rgba(255,255,255,0.25);
    }

    .mobile-header .download-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: #10b981;
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
    }

    .mobile-header .download-btn:hover {
      background: #059669;
    }

    .mobile-header-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      min-width: 0;
      justify-content: center;
    }

    .mobile-file-pill {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.18);
      min-width: 0;
      max-width: 48vw;
    }

    .mobile-file-pill .mobile-file-label {
      font-size: 10px;
      color: rgba(255,255,255,0.75);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .mobile-file-pill input {
      border: none;
      outline: none;
      background: transparent;
      color: #fff;
      font-size: 12px;
      min-width: 0;
      width: 100%;
    }

    .mobile-zoom-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px;
      border-radius: 10px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.18);
      flex-shrink: 0;
    }

    .mobile-zoom-controls .zoom-btn {
      width: 30px;
      height: 30px;
      border-radius: 8px;
      background: rgba(255,255,255,0.12);
    }

    .mobile-zoom-controls .zoom-btn:hover {
      background: rgba(255,255,255,0.18);
    }

    .mobile-zoom-controls .zoom-value {
      color: rgba(255,255,255,0.85);
      min-width: 44px;
      font-size: 11px;
    }

    /* TOAST NOTIFICATION */
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
      15% { opacity: 1; transform: translateX(-50%) translateY(0); }
      85% { opacity: 1; transform: translateX(-50%) translateY(0); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
    }

    /* OPACITY SLIDER */
    .opacity-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .opacity-row input[type="range"] {
      flex: 1;
    }
    
    .opacity-row span {
      font-size: 10px;
      color: #aaa;
      min-width: 35px;
      text-align: right;
    }

    /* GRADIENT PICKER */
    .gradient-toggle {
      padding: 4px 8px;
      font-size: 10px;
      background: #3a3a50;
      border: none;
      border-radius: 4px;
      color: #aaa;
      cursor: pointer;
    }
    
    .gradient-toggle.active {
      background: #4f46e5;
      color: #fff;
    }

    /* EXPORT MODAL */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(4px);
    }
    
    .modal {
      background: #2a2a3e;
      border-radius: 12px;
      width: 500px;
      max-width: 90vw;
      max-height: 85vh;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
    }

    /* Location picker modal */
    #location-map {
      width: 100%;
      height: min(55vh, 520px);
      min-height: 320px;
      background: #1e1e2e;
    }

    /* Make map sizing robust even if modal animates */
    #location-picker-modal .modal-body {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #location-picker-modal #location-map {
      flex: 1 1 auto;
      min-height: 320px;
    }
    
    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid #3a3a50;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    
    .modal-header h3 {
      font-size: 16px;
      font-weight: 600;
      margin: 0;
    }
    
    .modal-close {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      border: none;
      background: #3a3a50;
      color: #fff;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .modal-close:hover {
      background: #dc2626;
    }
    
    .modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    
    .export-preview {
      background: 
        linear-gradient(45deg, #1a1a2a 25%, transparent 25%),
        linear-gradient(-45deg, #1a1a2a 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #1a1a2a 75%),
        linear-gradient(-45deg, transparent 75%, #1a1a2a 75%);
      background-size: 16px 16px;
      background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
      background-color: #232336;
      border-radius: 8px;
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
      min-height: 150px;
      max-height: 200px;
    }
    
    .export-preview canvas {
      max-width: 100%;
      max-height: 160px;
      border-radius: 8px;
    }
    
    .export-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .export-size-mode {
      background: #1e1e2e;
      padding: 12px;
      border-radius: 8px;
    }
    
    .export-info {
      text-align: center;
      padding: 12px;
      background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
      border-radius: 8px;
      font-size: 13px;
      color: #a8a8b8;
      border: 1px solid #3a3a50;
    }
    
    #quality-group {
      transition: all 0.2s;
    }
    
    #lock-ratio-btn.active {
      background: #7c3aed;
      color: white;
    }
    
    .modal-footer {
      padding: 16px 20px;
      border-top: 1px solid #3a3a50;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-shrink: 0;
    }

    /* TEXT ELEMENT */
    .gradient-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
    }
    
    .gradient-toggle {
      padding: 4px 8px;
      font-size: 10px;
      background: #3a3a50;
      border: none;
      border-radius: 4px;
      color: #aaa;
      cursor: pointer;
    }
    
    .gradient-toggle.active {
      background: #4f46e5;
      color: #fff;
    }

    /* TEXT ELEMENT */
    .text-content {
      text-align: center;
      white-space: normal;
      overflow: hidden;
      padding: 4px 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      word-break: break-word;
      line-height: 1.2;
      border-radius: 4px;
    }

    /* Inline text editing */
    .text-content.editing {
      cursor: text;
      outline: 2px solid #7c3aed;
      background: rgba(255,255,255,0.95);
    }

    .text-content[contenteditable="true"] {
      user-select: text;
    }

    .canvas-element.editing {
      cursor: text;
    }

    /* QR ELEMENT */
    .qr-content img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .qr-loading {
      color: #888;
      font-size: 12px;
    }

    /* ELEMENT TOOLBAR */
    .element-toolbar {
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      background: #2a2a3e;
      border-radius: 6px;
      padding: 4px;
      display: flex;
      gap: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      white-space: nowrap;
    }

    .element-toolbar button {
      padding: 4px 8px;
      border: none;
      background: transparent;
      color: #fff;
      font-size: 11px;
      cursor: pointer;
      border-radius: 4px;
    }

    .element-toolbar button:hover {
      background: #3a3a50;
    }

    /* RIGHT PANEL */
    .right-panel {
      width: 240px;
      background: #2a2a3e;
      border-left: 1px solid #3a3a50;
      padding: 12px;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .right-panel .section-title {
      font-size: 10px;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #4a4a60;
      border-radius: 3px;
    }


    /* CANVAS HANDLES */
    .canvas-selection-overlay {
      position: absolute;
      pointer-events: none;
      z-index: 30;
      border: 2px solid #10b981;
      border-radius: 10px;
      box-sizing: border-box;
    }

    .canvas-selection-overlay .canvas-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #10b981;
      border: 2px solid #0f766e;
      border-radius: 4px;
      pointer-events: auto;
    }

    .canvas-selection-overlay .canvas-handle.nw { top: -8px; left: -8px; cursor: nw-resize; }
    .canvas-selection-overlay .canvas-handle.ne { top: -8px; right: -8px; cursor: ne-resize; }
    .canvas-selection-overlay .canvas-handle.sw { bottom: -8px; left: -8px; cursor: sw-resize; }
    .canvas-selection-overlay .canvas-handle.se { bottom: -8px; right: -8px; cursor: se-resize; }

    .canvas-selection-overlay .canvas-rotation-line {
      position: absolute;
      top: -32px;
      left: 50%;
      transform: translateX(-50%);
      width: 2px;
      height: 24px;
      background: #10b981;
      pointer-events: none;
    }

    .canvas-selection-overlay .canvas-rotation-handle {
      position: absolute;
      top: -50px;
      left: 50%;
      transform: translateX(-50%);
      width: 20px;
      height: 20px;
      background: #10b981;
      border: 2px solid #0f766e;
      border-radius: 50%;
      cursor: grab;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0b3b33;
      font-size: 10px;
    }

    .canvas-selection-overlay .canvas-rotation-handle:active { cursor: grabbing; }
    /* MOBILE TOGGLE */
    .mobile-toggle {
      display: none;
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
    }

    .mobile-toggle:hover {
      transform: scale(1.05);
    }

    /* RESPONSIVE */
    
    /* 750–1300px: tablet/small-desktop layout (right panel moves below canvas) */
    @media (max-width: 1300px) {
      .app-layout {
        flex-wrap: wrap;
      }
      
      .sidebar {
        width: 280px;
        flex-shrink: 0;
        height: 100vh;
        max-height: 100vh;
        overflow: hidden;
        min-height: 0;
      }

      .sidebar-content {
        min-height: 0;
      }
      
      .main-area {
        flex: 1;
        min-width: 300px;
      }
      
      .right-panel {
        position: fixed;
        bottom: 0;
        left: 280px;
        right: 0;
        top: auto;
        width: auto;
        height: auto;
        max-height: 35vh;
        border-left: none;
        border-top: 1px solid #3a3a50;
        z-index: 60;
        overflow-y: auto;
      }

      /* Panel is fixed at bottom; give wrapper extra scroll room and avoid vertical auto-centering */
      .canvas-wrapper {
        align-items: center;
        padding-bottom: calc(24px + 35vh);
      }
      
    }
    
    @media (max-width: 1024px) {
      .right-panel {
        left: 260px;
      }
      
      .sidebar {
        width: 260px;
      }
      
      .toolbar {
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px 12px;
      }
      
      .toolbar-group {
        padding: 0 6px;
      }
    }
    
    /* 600–1200px now uses the <=1200px layout (no special 600–900 layout) */

    /* Mobile (<=750px) */
    @media (max-width: 750px) {
      .app-layout {
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }
      
      /* Hide toggle button on mobile */
      .mobile-toggle {
        display: none !important;
      }
      
      /* Hide mobile top toolbar - use floating toolbar instead */
      .mobile-toolbar {
        display: none !important;
      }
      
      /* Left sidebar moves to bottom */
      .sidebar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        top: auto;
        width: 100%;
        height: 45vh;
        z-index: 70;
        transform: translateY(calc(100% - 60px));
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s ease;
        border-right: none;
        border-top: 1px solid #3a3a50;
        border-radius: 16px 16px 0 0;
      }
      
      .sidebar.open {
        transform: translateY(0);
        box-shadow: 0 -12px 40px rgba(0, 0, 0, 0.5);
      }
      
      .sidebar-header {
        padding: 12px 16px;
      }
      
      .sidebar-header h1 {
        font-size: 14px;
      }
      
      .sidebar-content {
        max-height: calc(45vh - 100px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 24px;
      }
      
      .main-area {
        position: fixed;
        top: var(--mobile-main-top);
        left: 0;
        right: 0;
        bottom: 60px;
        height: auto;
        z-index: 10;
        transition: bottom 0.3s ease;
      }
      
      .main-area.sidebar-open {
        bottom: 45vh;
      }

      .main-area.sidebar-collapsed {
        bottom: 60px;
      }
      
      .toolbar {
        display: none;
      }
      
      .canvas-wrapper {
        padding: 16px;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: auto;
      }
      
      .canvas {
        max-width: none;
        max-height: none;
        flex-shrink: 0;
      }
      
      /* Hide right panel completely on mobile */
      .right-panel {
        display: none !important;
      }
      
      /* Floating toolbar on mobile - position below mobile header, center full screen */
      .floating-toolbar {
        top: calc(var(--mobile-header-height) + var(--floating-toolbar-gap));
        left: 50%;
        transform: translateX(-50%);
        padding: 6px 10px;
        gap: 2px;
        max-width: calc(100vw - 20px);
        overflow-x: auto;
      }
      
      .floating-toolbar-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
        flex-shrink: 0;
      }
      
      /* Mobile header */
      .mobile-header {
        display: flex !important;
      }

      .mobile-bottom-controls {
        display: flex;
      }
      
      .types-grid {
        grid-template-columns: repeat(4, 1fr);
      }
      
      .type-btn {
        padding: 8px 4px;
      }
      
      .type-btn .label {
        display: none;
      }
      
      .modal {
        max-height: 80vh;
        width: 95vw;
      }
      
      .export-preview {
        min-height: 100px;
        max-height: 120px;
        padding: 10px;
      }
      
      .export-preview canvas {
        max-height: 100px;
      }
      
      .modal-body {
        padding: 12px;
      }
      
      .modal-footer {
        padding: 12px;
        flex-wrap: wrap;
        gap: 8px;
      }
      
      .modal-footer button {
        flex: 1;
        min-width: 120px;
      }

      .sidebar-header .mobile-close i {
        transition: transform 0.25s ease;
      }

      .sidebar:not(.open) .mobile-close i {
        transform: rotate(180deg);
      }
      
      .section {
        padding: 10px;
        margin-bottom: 12px;
      }
      
      .form-row {
        grid-template-columns: 1fr;
        gap: 10px;
      }
      
      .pill-row {
        gap: 6px;
      }
      
      .pill {
        padding: 6px 10px;
        font-size: 11px;
      }
    }

    @media (max-width: 480px) {
      :root {
        --mobile-header-height: 48px;
      }
      
      .mobile-header {
        height: 48px;
        padding: 0 10px;
      }
      
      .mobile-header .home-btn {
        padding: 6px 10px;
        font-size: 12px;
      }
      
      .mobile-header .download-btn {
        padding: 6px 12px;
        font-size: 11px;
      }
      
      .sidebar {
        height: 50vh;
        transform: translateY(calc(100% - 54px));
      }
      
      .sidebar.open {
        transform: translateY(0);
      }
      
      .sidebar-content {
        max-height: calc(50vh - 90px);
      }
      
      .main-area {
        bottom: 54px;
      }
      
      .main-area.sidebar-open {
        bottom: 50vh;
      }
      
      .sidebar-tabs {
        font-size: 10px;
      }
      
      .sidebar-tab {
        padding: 8px 4px;
        font-size: 10px;
      }
      
      .sidebar-tab i {
        display: block;
        margin-bottom: 2px;
      }
      
      .types-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      
      .type-btn {
        padding: 6px 4px;
      }
      
      .type-btn .icon {
        font-size: 14px;
      }
      
      .type-btn .label {
        display: block;
        font-size: 7px;
      }
      
      .section {
        padding: 8px;
        margin-bottom: 10px;
      }
      
      .section-title {
        font-size: 10px;
        margin-bottom: 8px;
      }
      
      .form-group label {
        font-size: 9px;
      }
      
      .form-group input,
      .form-group select,
      .form-group textarea {
        font-size: 12px;
        padding: 8px;
      }
      
      .pill {
        padding: 5px 8px;
        font-size: 9px;
      }
      
      .zoom-controls {
        display: none;
      }
      
      .canvas-wrapper {
        padding: 12px;
      }
      
      .floating-toolbar {
        padding: 4px 8px;
        border-radius: 10px;
      }
      
      .floating-toolbar-btn {
        width: 28px;
        height: 28px;
        font-size: 12px;
      }
      
      .floating-toolbar-divider {
        height: 20px;
        margin: 0 2px;
      }
      
      /* Hide some toolbar buttons on very small screens */
      .floating-toolbar .more-btn {
        display: flex;
      }
    }
    
    /* Landscape phone */
    @media (max-height: 500px) and (orientation: landscape) {
      .sidebar {
        height: 60vh;
        transform: translateY(calc(100% - 44px));
      }
      
      .sidebar.open {
        transform: translateY(0);
      }
      
      .sidebar-content {
        max-height: calc(60vh - 80px);
      }
      
      .main-area {
        bottom: 44px;
      }
      
      .main-area.sidebar-open {
        bottom: 60vh;
      }
      
      .canvas-wrapper {
        padding: 10px;
      }
      
      .modal {
        max-height: 95vh;
      }
    }
    
    /* Ensure nothing is cut off */
    @media (max-width: 768px) {
      .shapes-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .style-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .color-presets {
        flex-wrap: wrap;
      }
      
      .finder-row {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>

<body>

  <!-- MOBILE HEADER -->
  <header class="mobile-header" id="mobile-header">
    <div class="mobile-header-left">
      <a href="home.html" class="home-btn" title="Home">
        <i class="fa-solid fa-house"></i>
      </a>
    </div>

    <button class="download-btn" onclick="openExportModal()" title="Tải xuống">
      <i class="fa-solid fa-download"></i>
    </button>
  </header>

  <div class="app-layout">
    <!-- MOBILE TOP TOOLBAR (like Canva) -->
    <div class="mobile-toolbar" id="mobile-toolbar">
      <button class="mobile-toolbar-btn" onclick="copySelected()">
        <i class="fa-solid fa-copy"></i>
        <span>Copy</span>
      </button>
      <button class="mobile-toolbar-btn" onclick="pasteClipboard()">
        <i class="fa-solid fa-paste"></i>
        <span>Dán</span>
      </button>
      <button class="mobile-toolbar-btn" onclick="duplicateSelected()">
        <i class="fa-solid fa-clone"></i>
        <span>Nhân đôi</span>
      </button>
      <div class="mobile-toolbar-divider"></div>
      <button class="mobile-toolbar-btn" onclick="deleteSelected()">
        <i class="fa-solid fa-trash"></i>
        <span>Xóa</span>
      </button>
      <div class="mobile-toolbar-divider"></div>
      <button class="mobile-toolbar-btn" onclick="moveLayerUp()">
        <i class="fa-solid fa-layer-group"></i>
        <span>Lên trên</span>
      </button>
      <button class="mobile-toolbar-btn" onclick="moveLayerDown()">
        <i class="fa-solid fa-layer-group fa-flip-vertical"></i>
        <span>Xuống dưới</span>
      </button>
      <div class="mobile-toolbar-divider"></div>
      <button class="mobile-toolbar-btn" onclick="undo()">
        <i class="fa-solid fa-rotate-left"></i>
        <span>Hoàn tác</span>
      </button>
      <button class="mobile-toolbar-btn" onclick="redo()">
        <i class="fa-solid fa-rotate-right"></i>
        <span>Làm lại</span>
      </button>
      <div class="mobile-toolbar-divider"></div>
      <button class="mobile-toolbar-btn" onclick="openExportModal()">
        <i class="fa-solid fa-download"></i>
        <span>Tải xuống</span>
      </button>
    </div>

    <!-- MOBILE TOGGLE -->
    <button class="mobile-toggle" id="mobile-menu-toggle">
      <i class="fa-solid fa-bars"></i>
    </button>
    
    <!-- SIDEBAR -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <a href="home.html" class="sidebar-home-btn" title="Về trang chủ">
          <i class="fa-solid fa-house"></i>
        </a>

        <!-- Mobile-only: project name + zoom slider (placed on bottom panel header) -->
        <div class="mobile-bottom-controls" aria-label="Mobile viewport zoom">
          <input type="text" id="project-name-mobile" value="qr_design" placeholder="Tên file" />
          <div class="mobile-zoom-slider">
            <input type="range" id="zoom-slider-mobile" min="10" max="400" step="1" value="100" />
            <span id="zoom-slider-value-mobile">100%</span>
          </div>
        </div>

        <button class="mobile-close" id="mobile-close" style="display:none;margin-left:auto;background:transparent;border:none;color:#fff;font-size:18px;cursor:pointer;">
          <i class="fa-solid fa-chevron-down"></i>
        </button>
      </div>

      <div class="sidebar-tabs">
        <button class="sidebar-tab active" data-panel="qr"><i class="fa-solid fa-qrcode"></i> QR Code</button>
        <button class="sidebar-tab" data-panel="text"><i class="fa-solid fa-pencil"></i> Text</button>
        <button class="sidebar-tab" data-panel="elements"><i class="fa-solid fa-shapes"></i> Thêm</button>
      </div>

      <div class="sidebar-content">
        <!-- QR Panel -->
        <div class="sidebar-panel active" id="panel-qr">
          <!-- Create QR Section (shown when no QR exists) -->
          <div id="qr-create-section" class="section" style="text-align:center;">
            <div style="padding:40px 20px;">
              <i class="fa-solid fa-qrcode" style="font-size:48px;color:#4f46e5;margin-bottom:16px;"></i>
              <h3 style="margin:0 0 8px;color:#e2e8f0;">Chưa có mã QR</h3>
              <p style="margin:0 0 16px;color:#94a3b8;font-size:13px;">Tạo mã QR để bắt đầu thiết kế</p>
              <button class="toolbar-btn" style="width:100%;justify-content:center;background:linear-gradient(135deg,#4f46e5,#7c3aed);color:#fff;padding:12px 20px;" onclick="addQRElement()">
                <i class="fa-solid fa-plus"></i> Tạo mã QR
              </button>
            </div>
          </div>
          
          <!-- QR Customization Section (shown when QR exists) -->
          <div id="qr-customize-section">
          <div class="section">
            <div class="section-title">Loại QR</div>
            <div class="types-grid" style="grid-template-columns: repeat(4, 1fr);">
              <button class="type-btn active" data-type="url"><i class="fa-solid fa-link icon"></i><span
                  class="label">URL</span></button>
              <button class="type-btn" data-type="text"><i class="fa-solid fa-font icon"></i><span
                  class="label">Text</span></button>
              <button class="type-btn" data-type="wifi"><i class="fa-solid fa-wifi icon"></i><span
                  class="label">WiFi</span></button>
              <button class="type-btn" data-type="email"><i class="fa-solid fa-envelope icon"></i><span
                  class="label">Email</span></button>
              <button class="type-btn" data-type="phone"><i class="fa-solid fa-phone icon"></i><span
                  class="label">Phone</span></button>
              <button class="type-btn" data-type="sms"><i class="fa-solid fa-message icon"></i><span
                  class="label">SMS</span></button>
              <button class="type-btn" data-type="location"><i class="fa-solid fa-location-dot icon"></i><span
                  class="label">Vị trí</span></button>
              <button class="type-btn" data-type="vcard"><i class="fa-solid fa-address-card icon"></i><span
                  class="label">vCard</span></button>
              <button class="type-btn" data-type="event"><i class="fa-solid fa-calendar-days icon"></i><span
                  class="label">Sự kiện</span></button>
              <button class="type-btn" data-type="vietqr"><i class="fa-solid fa-building-columns icon"></i><span
                  class="label">VietQR</span></button>
              <button class="type-btn" data-type="crypto"><i class="fa-brands fa-bitcoin icon"></i><span
                  class="label">Crypto</span></button>
              <button class="type-btn" data-type="file"><i class="fa-solid fa-file-arrow-up icon"></i><span
                  class="label">File</span></button>
            </div>
          </div>

          <div class="section">
            <div class="section-title">Độ phức tạp</div>
            <div class="form-group">
              <label>Phiên bản <span id="version-label">1</span></label>
              <input type="range" id="qr-version" min="1" max="12" value="1" />
            </div>
            <p id="version-hint" class="version-hint">21 × 21 ô vuông</p>
          </div>

          <div class="section">
            <div class="section-title">Nội dung</div>

            <div class="special-form active" id="form-url">
              <div class="form-group">
                <label>URL</label>
                <input type="url" id="input-url" placeholder="https://www.agrichat.site/" />
              </div>
            </div>

            <div class="special-form" id="form-text">
              <div class="form-group">
                <label>Văn bản</label>
                <textarea id="input-text" placeholder="Nhập văn bản..."></textarea>
              </div>
            </div>

            <div class="special-form" id="form-phone">
              <div class="form-group">
                <label>Số điện thoại</label>
                <input type="tel" id="input-phone" placeholder="+84..." />
              </div>
            </div>

            <div class="special-form" id="form-wifi">
              <div class="form-group"><label>SSID</label><input type="text" id="wifi-ssid" placeholder="Tên WiFi" />
              </div>
              <div class="form-group"><label>Mật khẩu</label><input type="text" id="wifi-password"
                  placeholder="Password" /></div>
              <div class="form-group">
                <label>Bảo mật</label>
                <select id="wifi-security">
                  <option value="WPA">WPA/WPA2</option>
                  <option value="WEP">WEP</option>
                  <option value="nopass">Không</option>
                </select>
              </div>
            </div>

            <div class="special-form" id="form-email">
              <div class="form-group"><label>Email</label><input type="email" id="email-address"
                  placeholder="email@..." /></div>
              <div class="form-group"><label>Tiêu đề</label><input type="text" id="email-subject"
                  placeholder="Subject" /></div>
              <div class="form-group"><label>Nội dung</label><textarea id="email-body" placeholder="Body..."></textarea>
              </div>
            </div>

            <div class="special-form" id="form-sms">
              <div class="form-group"><label>SĐT</label><input type="tel" id="sms-phone" placeholder="+84..." /></div>
              <div class="form-group"><label>Tin nhắn</label><textarea id="sms-message"
                  placeholder="Message..."></textarea></div>
            </div>
            
            <!-- Location QR -->
            <div class="special-form" id="form-location">
              <div class="form-group"><label>Vĩ độ (Latitude)</label><input type="number" step="any" id="loc-lat" placeholder="21.0285" /></div>
              <div class="form-group"><label>Kinh độ (Longitude)</label><input type="number" step="any" id="loc-lng" placeholder="105.8542" /></div>
              <div class="form-group"><label>Tên địa điểm (tùy chọn)</label><input type="text" id="loc-name" placeholder="Hà Nội, Việt Nam" /></div>
              <div style="display:flex;gap:8px;margin-top:8px;">
                <button class="toolbar-btn" style="flex:1;justify-content:center;" onclick="getCurrentLocation()">
                  <i class="fa-solid fa-crosshairs"></i> Vị trí hiện tại
                </button>
                <button class="toolbar-btn" style="flex:1;justify-content:center;" onclick="openLocationPickerModal()">
                  <i class="fa-solid fa-map-location-dot"></i> Chọn trên bản đồ
                </button>
              </div>
            </div>
            
            <!-- vCard QR -->
            <div class="special-form" id="form-vcard">
              <div class="form-row">
                <div class="form-group"><label>Họ</label><input type="text" id="vcard-lastname" placeholder="Nguyễn" /></div>
                <div class="form-group"><label>Tên</label><input type="text" id="vcard-firstname" placeholder="Văn A" /></div>
              </div>
              <div class="form-group"><label>Công ty</label><input type="text" id="vcard-org" placeholder="Công ty ABC" /></div>
              <div class="form-group"><label>Chức vụ</label><input type="text" id="vcard-title" placeholder="Giám đốc" /></div>
              <div class="form-group"><label>Điện thoại</label><input type="tel" id="vcard-phone" placeholder="+84..." /></div>
              <div class="form-group"><label>Email</label><input type="email" id="vcard-email" placeholder="email@company.com" /></div>
              <div class="form-group"><label>Website</label><input type="url" id="vcard-url" placeholder="https://..." /></div>
              <div class="form-group"><label>Địa chỉ</label><textarea id="vcard-address" placeholder="123 Đường ABC, Quận 1, TP.HCM"></textarea></div>
            </div>
            
            <!-- Event/Calendar QR -->
            <div class="special-form" id="form-event">
              <div class="form-group"><label>Tên sự kiện</label><input type="text" id="event-title" placeholder="Họp team" /></div>
              <div class="form-group"><label>Địa điểm</label><input type="text" id="event-location" placeholder="Phòng họp A" /></div>
              <div class="form-row">
                <div class="form-group"><label>Bắt đầu</label><input type="datetime-local" id="event-start" /></div>
                <div class="form-group"><label>Kết thúc</label><input type="datetime-local" id="event-end" /></div>
              </div>
              <div class="form-group"><label>Mô tả</label><textarea id="event-desc" placeholder="Chi tiết sự kiện..."></textarea></div>
            </div>
            
            <!-- VietQR (Banking) -->
            <div class="special-form" id="form-vietqr">
              <div class="form-group">
                <label>Ngân hàng</label>
                <select id="vietqr-bank">
                  <option value="970436">Vietcombank (VCB)</option>
                  <option value="970418">BIDV</option>
                  <option value="970415">Vietinbank</option>
                  <option value="970405">Agribank</option>
                  <option value="970422">MB Bank</option>
                  <option value="970407">Techcombank</option>
                  <option value="970416">ACB</option>
                  <option value="970432">VPBank</option>
                  <option value="970423">TPBank</option>
                  <option value="970437">HDBank</option>
                  <option value="970448">OCB</option>
                  <option value="970403">Sacombank</option>
                  <option value="970426">MSB</option>
                  <option value="970441">VIB</option>
                  <option value="970443">SHB</option>
                  <option value="970454">Cake</option>
                  <option value="970429">SCB</option>
                  <option value="970431">Eximbank</option>
                  <option value="970400">Saigonbank</option>
                  <option value="970452">KienLongBank</option>
                  <option value="970433">VietABank</option>
                  <option value="970446">COOP Bank</option>
                  <option value="970449">LPBank</option>
                  <option value="970457">Ubank</option>
                  <option value="970406">DongA Bank</option>
                  <option value="970434">IVB</option>
                  <option value="970424">Shinhan Vietnam</option>
                  <option value="970427">VRB</option>
                  <option value="970425">AnBinhBank</option>
                  <option value="970438">BacABank</option>
                  <option value="970421">VietBank</option>
                  <option value="970428">NamABank</option>
                  <option value="970419">NCB</option>
                  <option value="970439">PVcomBank</option>
                  <option value="970412">PGBank</option>
                  <option value="970440">SeABank</option>
                  <option value="970458">TNEX</option>
                  <option value="970462">VBSP</option>
                  <option value="422589">CIMB</option>
                  <option value="801011">Nonghyup</option>
                  <option value="970414">OCBC</option>
                  <option value="970463">Viettel Money</option>
                  <option value="970456">VNPT Money</option>
                </select>
              </div>
              <div class="form-group"><label>Số tài khoản</label><input type="text" id="vietqr-account" placeholder="0123456789" /></div>
              <div class="form-group"><label>Tên chủ TK (tùy chọn)</label><input type="text" id="vietqr-name" placeholder="NGUYEN VAN A" /></div>
              <div class="form-group"><label>Số tiền (VND, tùy chọn)</label><input type="number" id="vietqr-amount" placeholder="100000" /></div>
              <div class="form-group"><label>Nội dung CK (tùy chọn)</label><input type="text" id="vietqr-memo" placeholder="Chuyen khoan" /></div>
            </div>
            
            <!-- Crypto QR -->
            <div class="special-form" id="form-crypto">
              <div class="form-group">
                <label>Loại tiền</label>
                <select id="crypto-type">
                  <option value="bitcoin">Bitcoin (BTC)</option>
                  <option value="ethereum">Ethereum (ETH)</option>
                  <option value="litecoin">Litecoin (LTC)</option>
                  <option value="bitcoincash">Bitcoin Cash (BCH)</option>
                  <option value="dogecoin">Dogecoin (DOGE)</option>
                  <option value="monero">Monero (XMR)</option>
                  <option value="solana">Solana (SOL)</option>
                  <option value="tron">TRON (TRX)</option>
                </select>
              </div>
              <div class="form-group"><label>Địa chỉ ví</label><input type="text" id="crypto-address" placeholder="bc1q..." /></div>
              <div class="form-group"><label>Số lượng (tùy chọn)</label><input type="number" step="any" id="crypto-amount" placeholder="0.001" /></div>
              <div class="form-group"><label>Ghi chú (tùy chọn)</label><input type="text" id="crypto-label" placeholder="Donation" /></div>
            </div>
            
            <!-- File Upload QR (generates URL to file) -->
            <div class="special-form" id="form-file">
              <div class="form-group">
                <label>Tải file lên (sẽ tạo link download)</label>
                <input type="file" id="file-upload-input" style="display:none" onchange="handleFileUpload(event)" />
                <button class="toolbar-btn" style="width:100%;justify-content:center" onclick="document.getElementById('file-upload-input').click()">
                  <i class="fa-solid fa-cloud-arrow-up"></i> Chọn file
                </button>
                <p style="font-size:10px;color:#888;margin-top:6px;">Hỗ trợ: PDF, DOC, XLS, ZIP, hình ảnh... (tối đa 5MB)</p>
              </div>
              <div id="file-upload-preview" style="display:none;margin-top:10px;padding:10px;background:#1e1e2e;border-radius:6px;">
                <div style="display:flex;align-items:center;gap:10px;">
                  <i class="fa-solid fa-file" style="font-size:24px;color:#7c3aed;"></i>
                  <div style="flex:1;overflow:hidden;">
                    <div id="uploaded-file-name" style="font-size:12px;color:#e2e8f0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"></div>
                    <div id="file-size" style="font-size:10px;color:#888;"></div>
                  </div>
                  <button class="pill" onclick="removeUploadedFile()"><i class="fa-solid fa-times"></i></button>
                </div>
              </div>
              <div class="form-group" style="margin-top:10px;">
                <label>Hoặc nhập URL file trực tiếp</label>
                <input type="url" id="file-direct-url" placeholder="https://example.com/file.pdf" />
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-title">Màu QR</div>
            <div class="form-group">
              <label>Màu code</label>
              <div class="color-picker-row">
                <div class="color-input-wrap">
                  <input type="color" id="qr-color" value="#1e293b" />
                </div>
                <div class="color-presets" id="qr-color-presets">
                  <div class="color-dot active" style="background:#1e293b" data-color="#1e293b"></div>
                  <div class="color-dot" style="background:#2563eb" data-color="#2563eb"></div>
                  <div class="color-dot" style="background:#059669" data-color="#059669"></div>
                  <div class="color-dot" style="background:#dc2626" data-color="#dc2626"></div>
                  <div class="color-dot" style="background:#7c3aed" data-color="#7c3aed"></div>
                </div>
              </div>
            </div>
            <div class="form-group">
              <label>Màu nền QR</label>
              <div class="color-picker-row">
                <div class="color-input-wrap">
                  <input type="color" id="qr-bg-color" value="#ffffff" />
                </div>
                <div class="color-presets" id="qr-bg-presets">
                  <div class="color-dot active" style="background:#ffffff;border:1px solid #555" data-color="#ffffff">
                  </div>
                  <div class="color-dot" style="background:#f1f5f9" data-color="#f1f5f9"></div>
                  <div class="color-dot" style="background:#fef3c7" data-color="#fef3c7"></div>
                  <div class="color-dot" style="background:#dbeafe" data-color="#dbeafe"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-title">Logo QR</div>
            <div class="form-group">
              <label>Tải logo lên (sẽ hiển thị ở giữa QR)</label>
              <input type="file" id="qr-logo-upload" accept="image/*" style="display:none" />
              <button class="toolbar-btn" style="width:100%;justify-content:center" onclick="document.getElementById('qr-logo-upload').click()">
                <i class="fa-solid fa-upload"></i> Tải logo lên
              </button>
              <div id="logo-preview" style="margin-top:8px;display:none;">
                <div style="display:flex;align-items:center;gap:8px;">
                  <img id="logo-preview-img" style="width:40px;height:40px;object-fit:contain;border-radius:4px;border:1px solid #3a3a50;" />
                  <button class="pill" onclick="removeLogo()"><i class="fa-solid fa-times"></i> Xóa</button>
                </div>
              </div>
            </div>
            <div class="form-group">
              <label>Kích thước logo (%)</label>
              <div class="opacity-row">
                <input type="range" id="logo-size" min="10" max="25" value="25" />
                <span id="logo-size-label">25%</span>
              </div>
            </div>
            <div class="form-group">
              <label>Bo tròn logo (%)</label>
              <div class="opacity-row">
                <input type="range" id="logo-radius" min="0" max="50" value="25" />
                <span id="logo-radius-label">25%</span>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-title">Dot & ECC</div>
            <div class="form-group">
              <label>Kiểu chấm</label>
              <div class="pill-row" id="dot-pills">
                <button class="pill active" data-module="rounded-square">Vuông bo</button>
                <button class="pill" data-module="square">Vuông truyền thống</button>
                <button class="pill" data-module="circle">Chấm tròn</button>
                <button class="pill" data-module="rounded-bar">Gạch bo góc</button>
                <button class="pill" data-module="horizontal-bar">Gạch ngang</button>
                <button class="pill" data-module="vertical-bar">Gạch dọc</button>
                <button class="pill" data-module="capsule">Viên thuốc</button>
              </div>
            </div>
            <div class="form-group">
              <label>Kiểu mắt</label>
              <div class="pill-row" id="eye-pills">
                <button class="pill active" data-eye="square">Vuông classic</button>
                <button class="pill" data-eye="rounded">Bo tròn</button>
                <button class="pill" data-eye="circle">Bubble / Dot</button>
                <button class="pill" data-eye="rounded-bar">Gạch bo tròn</button>
                <button class="pill" data-eye="diamond">Kim cương</button>
              </div>
            </div>
            <div class="form-group">
              <label>Sửa lỗi</label>
              <div class="pill-row" id="ecc-pills">
                <button class="pill" data-ecc="L">Thấp</button>
                <button class="pill" data-ecc="M">Vừa</button>
                <button class="pill active" data-ecc="H">Cao</button>
              </div>
            </div>
          </div>
          
          <div class="section">
            <div class="section-title">Tinh chỉnh QR</div>
            <div class="form-group">
              <label>Khoảng cách chấm</label>
              <div class="opacity-row">
                <input type="range" id="qr-dot-gap" min="0" max="30" value="0" />
                <span id="dot-gap-label">0%</span>
              </div>
            </div>
            <div class="form-group">
              <label>Độ dày viền mắt QR</label>
              <div class="opacity-row">
                <input type="range" id="qr-eye-thickness" min="70" max="175" value="100" />
                <span id="eye-thickness-label">100%</span>
              </div>
            </div>
          </div>
          </div><!-- End qr-customize-section -->
        </div>

        <!-- Text Panel -->
        <div class="sidebar-panel" id="panel-text">
          <div class="section">
            <div class="section-title">Thêm văn bản</div>
            <button class="toolbar-btn" style="width:100%;justify-content:center;margin-bottom:8px"
              onclick="addTextElement('Tiêu đề', 24, true)"><i class="fa-solid fa-plus"></i> Thêm Tiêu đề</button>
            <button class="toolbar-btn" style="width:100%;justify-content:center;margin-bottom:8px"
              onclick="addTextElement('Phụ đề', 16, false)"><i class="fa-solid fa-plus"></i> Thêm Phụ đề</button>
            <button class="toolbar-btn" style="width:100%;justify-content:center"
              onclick="addTextElement('Văn bản', 14, false)"><i class="fa-solid fa-plus"></i> Thêm Text</button>
          </div>
        </div>

        <!-- Elements Panel -->
        <div class="sidebar-panel" id="panel-elements">
          <div class="section">
            <div class="section-title">Màu nền Canvas</div>
            <div class="form-group">
              <div class="color-picker-row">
                <div class="color-input-wrap">
                  <input type="color" id="canvas-bg" value="#ffffff" />
                </div>
                <div class="color-presets" id="canvas-bg-presets">
                  <div class="color-dot active" style="background:#ffffff;border:1px solid #555" data-color="#ffffff">
                  </div>
                  <div class="color-dot" style="background:#f8fafc" data-color="#f8fafc"></div>
                  <div class="color-dot" style="background:#fef3c7" data-color="#fef3c7"></div>
                  <div class="color-dot" style="background:#dbeafe" data-color="#dbeafe"></div>
                  <div class="color-dot" style="background:#1e293b" data-color="#1e293b"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-title">Kích thước Canvas</div>
            <div class="form-row">
              <div class="form-group">
                <label>Rộng</label>
                <input type="number" id="canvas-width" value="400" min="200" max="650" />
              </div>
              <div class="form-group">
                <label>Cao</label>
                <input type="number" id="canvas-height" value="400" min="200" max="650" />
              </div>
            </div>
            <button class="toolbar-btn" style="width:100%;justify-content:center;margin-top:8px"
              onclick="updateCanvasSize()">Áp dụng</button>
          </div>

          <div class="section">
            <div class="section-title">Hình dạng</div>
            <div class="shapes-grid" id="shapes-grid-main">
              <!-- Hiển thị 9 hình đầu tiên -->
            </div>
            <div class="shapes-grid shapes-grid-hidden" id="shapes-grid-extra" style="display:none;margin-top:8px;">
              <!-- Các hình còn lại -->
            </div>
            <button class="toolbar-btn" id="toggle-shapes-btn" style="width:100%;justify-content:center;margin-top:10px;" onclick="toggleMoreShapes()">
              <i class="fa-solid fa-chevron-down"></i> Xem thêm hình dạng
            </button>
          </div>
        </div>

        <!-- Properties Panel (mobile auto-switch when selecting) -->
        <div class="sidebar-panel" id="panel-props">
          <div class="section">
            <div class="section-title">Thuộc tính</div>
            <div id="element-props-host-mobile"></div>
          </div>
        </div>

        <!-- More actions (mobile only: opened via 3-dots button in toolbar) -->
        <div class="sidebar-panel" id="panel-more">
          <div class="section">
            <div class="section-title">Thao tác</div>
            <div id="more-menu-host-mobile"></div>
          </div>
        </div>
      </div>
    </aside>

    <!-- MAIN AREA -->
    <main class="main-area">
      <div class="toolbar">
        <div class="toolbar-left">
          <div class="toolbar-group">
            <span class="toolbar-label">Tên File:</span>
            <input type="text" id="project-name-desktop" class="toolbar-input" value="qr_design" placeholder="Tên file" />
          </div>
          <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomCanvas(-10)">−</button>
            <span class="zoom-value" id="zoom-value">100%</span>
            <button class="zoom-btn" onclick="zoomCanvas(10)">+</button>
            <button class="zoom-btn" onclick="zoomCanvas(0)" title="Reset 100%">↺</button>
            <button class="zoom-btn" onclick="fitViewport()" title="Fit to view"><i class="fa-solid fa-expand"></i></button>
          </div>
        </div>
        <div class="toolbar-left">
          <button class="toolbar-btn" onclick="alignSelected('left')" title="Căn trái"><i
              class="fa-solid fa-align-left"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('center-h')" title="Căn giữa ngang"><i
              class="fa-solid fa-align-center"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('right')" title="Căn phải"><i
              class="fa-solid fa-align-right"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('top')" title="Căn trên"><i
              class="fa-solid fa-arrow-up"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('center-v')" title="Căn giữa dọc"><i
              class="fa-solid fa-arrows-up-down"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('bottom')" title="Căn dưới"><i
              class="fa-solid fa-arrow-down"></i></button>
        </div>
        <div class="toolbar-left">
          <button class="toolbar-btn" onclick="copyToClipboard()"><i class="fa-regular fa-copy"></i> Copy</button>
          <button class="toolbar-btn primary" onclick="downloadImage()"><i class="fa-solid fa-download"></i> Tải xuống</button>
        </div>
      </div>

      <div class="canvas-wrapper" id="canvas-wrapper">
        <div class="canvas-stage" id="canvas-stage" style="width:400px;height:400px;">
          <div class="canvas" id="canvas" style="width:400px;height:400px;">
            <!-- Elements will be added here -->
          </div>
        </div>
      </div>
    </main>

    <!-- RIGHT PANEL - Element Properties -->
    <aside class="right-panel" id="right-panel">
      <div class="section">
        <div class="section-title">Thuộc tính</div>
        <div id="element-props-host-desktop">
          <div id="element-props"></div>
        </div>
      </div>
    </aside>
  </div>

  <!-- FLOATING TOOLBAR (like Canva) -->
  <div class="floating-toolbar" id="floating-toolbar">
    <button class="floating-toolbar-btn" onclick="undo()" title="Hoàn tác (Ctrl+Z)">
      <i class="fa-solid fa-rotate-left"></i>
    </button>
    <button class="floating-toolbar-btn" onclick="redo()" title="Làm lại (Ctrl+Shift+Z)">
      <i class="fa-solid fa-rotate-right"></i>
    </button>
    <div class="floating-toolbar-divider"></div>
    <button class="floating-toolbar-btn" onclick="copySelected()" title="Copy (Ctrl+C)">
      <i class="fa-solid fa-copy"></i>
    </button>
    <button class="floating-toolbar-btn" onclick="duplicateSelected()" title="Nhân đôi (Ctrl+D)">
      <i class="fa-solid fa-clone"></i>
    </button>
    <button class="floating-toolbar-btn" onclick="deleteSelected()" title="Xóa (Delete)">
      <i class="fa-solid fa-trash"></i>
    </button>
    <div class="floating-toolbar-divider"></div>
    <div class="floating-toolbar-dropdown">
      <button class="floating-toolbar-btn" onclick="toggleLayerMenu()" title="Vị trí">
        <i class="fa-solid fa-layer-group"></i>
      </button>
      <div class="floating-toolbar-menu" id="layer-menu">
        <div class="floating-toolbar-menu-item" onclick="moveLayerUp(); hideLayerMenu();">
          <i class="fa-solid fa-arrow-up"></i> Lên trên
        </div>
        <div class="floating-toolbar-menu-item" onclick="moveLayerDown(); hideLayerMenu();">
          <i class="fa-solid fa-arrow-down"></i> Xuống dưới
        </div>
        <div class="floating-toolbar-menu-item" onclick="moveLayerToTop(); hideLayerMenu();">
          <i class="fa-solid fa-angles-up"></i> Lên trên cùng
        </div>
        <div class="floating-toolbar-menu-item" onclick="moveLayerToBottom(); hideLayerMenu();">
          <i class="fa-solid fa-angles-down"></i> Xuống dưới cùng
        </div>
      </div>
    </div>
    <div class="floating-toolbar-divider"></div>
    <button class="floating-toolbar-btn" onclick="pasteClipboard()" title="Dán (Ctrl+V)">
      <i class="fa-solid fa-paste"></i>
    </button>
    <div class="floating-toolbar-dropdown">
      <button class="floating-toolbar-btn more-btn" onclick="toggleMoreMenu()" title="Thêm">
        <i class="fa-solid fa-ellipsis"></i>
      </button>
      <div id="more-menu-host-desktop">
        <div class="floating-toolbar-menu" id="more-menu" style="min-width:200px;right:0;left:auto;transform:none;">
          <div class="floating-toolbar-menu-item" onclick="selectAllElements(); hideMoreMenu();">
            <i class="fa-solid fa-check-double"></i> Chọn tất cả
            <span style="margin-left:auto;font-size:10px;color:#666;">Ctrl+A</span>
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('left'); hideMoreMenu();">
            <i class="fa-solid fa-align-left"></i> Canh trái
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('center-h'); hideMoreMenu();">
            <i class="fa-solid fa-align-center"></i> Canh giữa ngang
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('right'); hideMoreMenu();">
            <i class="fa-solid fa-align-right"></i> Canh phải
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('top'); hideMoreMenu();">
            <i class="fa-solid fa-arrow-up"></i> Canh trên
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('center-v'); hideMoreMenu();">
            <i class="fa-solid fa-arrows-up-down"></i> Canh giữa dọc
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('bottom'); hideMoreMenu();">
            <i class="fa-solid fa-arrow-down"></i> Canh dưới
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="distributeSelected('horizontal'); hideMoreMenu();">
            <i class="fa-solid fa-grip-lines-vertical"></i> Phân bố ngang
          </div>
          <div class="floating-toolbar-menu-item" onclick="distributeSelected('vertical'); hideMoreMenu();">
            <i class="fa-solid fa-grip-lines"></i> Phân bố dọc
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="flipSelected('horizontal'); hideMoreMenu();">
            <i class="fa-solid fa-arrows-left-right"></i> Lật ngang
          </div>
          <div class="floating-toolbar-menu-item" onclick="flipSelected('vertical'); hideMoreMenu();">
            <i class="fa-solid fa-arrows-up-down-left-right"></i> Lật dọc
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="resetRotation(); hideMoreMenu();">
            <i class="fa-solid fa-rotate"></i> Reset xoay (0°)
          </div>
          <div class="floating-toolbar-menu-item" onclick="rotateSelected(90); hideMoreMenu();">
            <i class="fa-solid fa-rotate-right"></i> Xoay 90°
          </div>
          <div class="floating-toolbar-menu-item" onclick="rotateSelected(-90); hideMoreMenu();">
            <i class="fa-solid fa-rotate-left"></i> Xoay -90°
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="toggleLockSelected(); hideMoreMenu();">
            <i class="fa-solid fa-lock"></i> Khóa / Mở khóa
          </div>
          <div class="floating-toolbar-menu-item" onclick="fitToCanvas(); hideMoreMenu();">
            <i class="fa-solid fa-expand"></i> Vừa canvas
          </div>
          <div class="floating-toolbar-menu-item" onclick="centerInCanvas(); hideMoreMenu();">
            <i class="fa-solid fa-crosshairs"></i> Đặt vào giữa
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="openExportModal(); hideMoreMenu();">
            <i class="fa-solid fa-download"></i> Tải xuống
            <span style="margin-left:auto;font-size:10px;color:#666;">Ctrl+S</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- EXPORT MODAL -->
  <div class="modal-overlay" id="export-modal" style="display:none;">
    <div class="modal" style="max-width:520px;">
      <div class="modal-header">
        <h3>Tải xuống thiết kế</h3>
        <button class="modal-close" onclick="closeExportModal()">×</button>
      </div>
      <div class="modal-body">
        <div class="export-preview">
          <canvas id="export-preview-canvas"></canvas>
        </div>
        <div class="export-options">
          <div class="form-group">
            <label>Định dạng</label>
            <div class="pill-row" id="format-pills">
              <button class="pill active" data-format="png">PNG</button>
              <button class="pill" data-format="jpg">JPG</button>
              <button class="pill" data-format="svg">SVG</button>
              <button class="pill" data-format="pdf">PDF</button>
            </div>
          </div>
          <div class="form-group">
            <label>Kích thước xuất</label>
            <div class="export-size-mode">
              <div class="pill-row" style="margin-bottom:12px;">
                <button class="pill active" id="size-mode-scale" onclick="setSizeMode('scale')">Tỷ lệ</button>
                <button class="pill" id="size-mode-custom" onclick="setSizeMode('custom')">Tùy chỉnh</button>
              </div>
              <div id="scale-options">
                <div class="pill-row" id="size-pills">
                  <button class="pill" data-scale="1">1x</button>
                  <button class="pill active" data-scale="2">2x</button>
                  <button class="pill" data-scale="3">3x</button>
                  <button class="pill" data-scale="4">4x</button>
                </div>
              </div>
              <div id="custom-size-options" style="display:none;">
                <div class="form-row">
                  <div class="form-group">
                    <label style="font-size:11px;color:#888;">Rộng (px)</label>
                    <input type="number" id="export-width" value="800" min="100" max="4096" onchange="updateExportSize()" />
                  </div>
                  <div class="form-group">
                    <label style="font-size:11px;color:#888;">Cao (px)</label>
                    <input type="number" id="export-height" value="800" min="100" max="4096" onchange="updateExportSize()" />
                  </div>
                  <div class="form-group" style="align-items:center;padding-top:20px;">
                    <button class="pill" id="lock-ratio-btn" onclick="toggleLockRatio()" title="Giữ tỷ lệ" style="padding:8px 10px;">
                      <i class="fa-solid fa-lock"></i>
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="form-group" id="quality-group">
            <label>Chất lượng</label>
            <div class="opacity-row">
              <input type="range" id="export-quality" min="50" max="100" value="92" />
              <span id="quality-label">92%</span>
            </div>
          </div>
          <div class="form-group">
            <label>Bo góc canvas</label>
            <div class="opacity-row">
              <input type="range" id="export-radius" min="0" max="100" value="8" />
              <span id="radius-label">8px</span>
            </div>
          </div>
          <div class="export-info">
            <i class="fa-solid fa-image" style="margin-right:6px;color:#7c3aed;"></i>
            <span id="export-size-info">800 × 800 px</span>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="toolbar-btn" onclick="closeExportModal()">Hủy</button>
        <button class="toolbar-btn primary" onclick="doExport()"><i class="fa-solid fa-download"></i> Tải xuống</button>
      </div>
    </div>
  </div>

  <!-- LOCATION PICKER MODAL (Leaflet) -->
  <div class="modal-overlay" id="location-picker-modal" style="display:none;">
    <div class="modal" style="max-width:760px;width:760px;">
      <div class="modal-header">
        <h3>Chọn vị trí trên bản đồ</h3>
        <button class="modal-close" onclick="closeLocationPickerModal()">×</button>
      </div>
      <div class="modal-body" style="padding:0;">
        <div id="location-map"></div>
        <div style="padding:12px 16px;border-top:1px solid #3a3a50;display:flex;justify-content:space-between;gap:10px;align-items:center;">
          <div style="font-size:12px;color:#94a3b8;min-width:0;" id="location-picker-coords">Chạm vào bản đồ để chọn</div>
          <div style="display:flex;gap:8px;flex-shrink:0;">
            <button class="toolbar-btn" onclick="closeLocationPickerModal()">Hủy</button>
            <button class="toolbar-btn primary" onclick="confirmLocationFromMap()">Chọn vị trí</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // State
    let elements = [];
    let selectedIds = new Set();
    let dragging = null;
    let resizing = null;
    let rotating = null; // For rotation handle
    let canvasZoom = 100;
    let currentQRType = 'url';
    let currentQRVersion = 1;
    let currentModuleStyle = 'rounded-square';
    let currentEyeStyle = 'square';
    let activeGuides = [];
    let selectionBox = null;
    let selectionStart = null;
    let isSelecting = false;
    let qrImageCache = null; // Cache QR image to avoid re-fetching
    let qrLogoData = null; // Logo for QR center
    let qrLogoSize = 25; // Logo size percentage
    let qrLogoRadius = 25; // Logo corner rounding percentage
    let qrDotGap = 0; // Gap between dots
    let qrEyeThickness = 100; // Eye thickness
    let canvasSelected = false; // Track if canvas itself is selected
    let wrapperSelectionBox = null; // Selection box for wrapper area
    let canvasRotation = 0; // Rotation of canvas in degrees
    let canvasOverlay = null; // Overlay with handles for canvas
    let canvasResizing = null; // State for canvas resize drag
    let canvasRotating = null; // State for canvas rotate drag
    let selectionStartedOnWrapper = false;
    let selectionStartedOnCanvas = false;
    let lastSelectionPoint = null;
    let clipboard = []; // Clipboard for copy/paste
    let history = []; // Undo history
    let historyIndex = -1; // Current position in history
    let multiSelectBox = null; // Bounding box for multi-selection
    let multiSelectDragging = null; // Multi-select drag state
    let multiSelectResizing = null; // Multi-select resize state
    let emptyQRNotice = null; // CTA when QR is missing
    // Rich font catalog (lazy-loaded via Google Fonts when selected)
    // Vietnamese-optimized fonts are marked - prioritizing fonts with full Vietnamese diacritics support
    const fontCatalog = [
      // ===== TOP VIETNAMESE FONTS (Best diacritics support) =====
      'Be Vietnam Pro','Quicksand','Nunito','Open Sans','Roboto','Montserrat','Poppins','Inter','Mulish','Raleway',
      'Josefin Sans','Rubik','Work Sans','Lato','Mukta','Source Sans Pro','Barlow','DM Sans','Public Sans','Jost',
      'Lexend','Manrope','IBM Plex Sans','Cabin','Heebo','Assistant','Hind','Outfit','Figtree','Albert Sans',
      
      // ===== DISPLAY & DECORATIVE FONTS (Vietnamese support) =====
      'Playfair Display','Dancing Script','Pacifico','Lobster','Caveat','Satisfy','Great Vibes','Courgette',
      'Parisienne','Amatic SC','Shadows Into Light','Handlee','Architects Daughter','Indie Flower','Kalam',
      'Patrick Hand','Permanent Marker','Rock Salt','Yellowtail','Allura','Alex Brush','Tangerine','Sacramento',
      
      // ===== SERIF FONTS (Vietnamese support) =====
      'Noto Serif','Merriweather','PT Serif','Libre Baskerville','Crimson Pro','Cormorant Garamond','Spectral',
      'Vollkorn','Bitter','Lora','EB Garamond','Arvo','Source Serif Pro','Alegreya','Cardo','Literata',
      'Bree Serif','Rokkitt','Noticia Text','Domine','Crete Round','Young Serif','Fraunces','Newsreader',
      
      // ===== SANS-SERIF MODERN =====
      'Catamaran','Fira Sans','Space Grotesk','Karla','Exo 2','Titillium Web','Teko','Archivo','Urbanist',
      'Sora','Syne','Maven Pro','Chivo','Overpass','Oxygen','Comfortaa','Josefin Slab','Lexend Deca',
      'Atkinson Hyperlegible','Geologica','Onest','Bricolage Grotesque','Instrument Sans','Epilogue','Gabarito',
      
      // ===== CONDENSED & DISPLAY =====
      'Barlow Condensed','Barlow Semi Condensed','Archivo Narrow','Bebas Neue','Oswald','Anton','Archivo Black',
      'Alfa Slab One','Abril Fatface','Righteous','Bungee','Fredoka','Grandstander','Rowdies','Unbounded',
      
      // ===== MONOSPACE (Coding fonts) =====
      'Space Mono','Inconsolata','JetBrains Mono','Fira Code','Source Code Pro','Ubuntu Mono','Roboto Mono',
      'IBM Plex Mono','DM Mono','Overpass Mono','Azeret Mono','Anonymous Pro','Cousine','Cutive Mono',
      
      // ===== ASIAN LANGUAGE SUPPORT =====
      'Noto Sans','Noto Sans Display','Noto Sans Mono','Noto Sans JP','Noto Serif JP',
      'M PLUS 1p','M PLUS Rounded 1c','Sawarabi Gothic','Nanum Gothic','Nanum Myeongjo',
      
      // ===== ELEGANT & PREMIUM =====
      'Cormorant','Bodoni Moda','Piazzolla','Brygada 1918','Alegreya Sans','Petrona','Signika',
      'Baloo 2','Kanit','Sarabun','Prompt','Plus Jakarta Sans','Red Hat Display','Red Hat Text','Zilla Slab',
      
      // ===== VIETNAMESE SPECIALTY =====
      'Tinos','Arimo','Libre Franklin','Asap','Signika Negative','Martel','Karma',
      'Hind Siliguri','Hind Madurai','Hind Vadodara','Schibsted Grotesk','Ubuntu',
      'Slabo 27px','Sanchez','Antic Slab','Exo','Tourney'
    ];

    function loadGoogleFont(font) {
      if (!font) return;
      const id = `font-${font.replace(/\s+/g, '-')}`;
      if (document.getElementById(id)) return;
      const link = document.createElement('link');
      link.id = id;
      link.rel = 'stylesheet';
      const family = font.replace(/\s+/g, '+');
      link.href = `https://fonts.googleapis.com/css2?family=${family}:wght@400;600;700&display=swap`;
      document.head.appendChild(link);
    }

    // Convert RGB/RGBA to hex
    function rgbToHex(color) {
      if (!color) return '#ffffff';
      if (color.startsWith('#')) return color;
      const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!match) return '#ffffff';
      const r = parseInt(match[1]).toString(16).padStart(2, '0');
      const g = parseInt(match[2]).toString(16).padStart(2, '0');
      const b = parseInt(match[3]).toString(16).padStart(2, '0');
      return `#${r}${g}${b}`;
    }

    const canvas = document.getElementById('canvas');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    const canvasStage = document.getElementById('canvas-stage');
    const MIN_CANVAS_SIZE = 200;
    const MAX_CANVAS_SIZE = 650;

    function clampCanvasDimension(value) {
      const parsed = parseInt(value, 10);
      if (Number.isNaN(parsed)) return MIN_CANVAS_SIZE;
      return Math.min(MAX_CANVAS_SIZE, Math.max(MIN_CANVAS_SIZE, parsed));
    }

    function syncCanvasSizeInputs(width, height) {
      const widthInput = document.getElementById('canvas-width');
      const heightInput = document.getElementById('canvas-height');
      if (widthInput) widthInput.value = width;
      if (heightInput) heightInput.value = height;
    }
    
    function normalizeRotation(value) {
      const num = Number(value);
      return Number.isFinite(num) ? num : 0;
    }

    // Update floating toolbar position to align with canvas center
    function updateToolbarPosition() {
      const toolbar = document.getElementById('floating-toolbar');
      if (!toolbar) return;

      const targetRect = (canvasStage || canvas).getBoundingClientRect();
      const canvasCenter = targetRect.left + targetRect.width / 2;
      const toolbarWidth = toolbar.offsetWidth || 0;
      const half = toolbarWidth / 2;
      const vw = document.documentElement.clientWidth;
      const minX = 12 + half;
      const maxX = vw - 12 - half;
      const clampedCenter = Math.max(minX, Math.min(maxX, canvasCenter));

      if (window.innerWidth <= 768) {
        toolbar.style.left = clampedCenter + 'px';
        toolbar.style.transform = 'translateX(-50%)';
      } else {
        toolbar.style.transform = 'none';
        toolbar.style.left = (clampedCenter - half) + 'px';
      }
    }

    // Keep the canvas visually stable in the viewport when its size changes
    function keepCanvasViewStable(oldRect, newRect) {
      const dx = (newRect.width - oldRect.width) / 2;
      const dy = (newRect.height - oldRect.height) / 2;
      if (dx === 0 && dy === 0) return;
      canvasWrapper.scrollLeft += dx;
      canvasWrapper.scrollTop += dy;
    }

    function updateCanvasStageSize() {
      const stage = canvasStage;
      if (!stage) return;
      const baseW = parseInt(canvas.style.width) || 400;
      const baseH = parseInt(canvas.style.height) || 400;
      const scale = canvasZoom / 100;
      stage.style.width = (baseW * scale) + 'px';
      stage.style.height = (baseH * scale) + 'px';
    }

    // Center stage in view using scroll (works with transform-zoom + real scaled bounds)
    function getBottomOverlayInset() {
      const panel = document.getElementById('right-panel');
      if (!panel) return 0;
      const cs = window.getComputedStyle(panel);
      if (cs.display === 'none' || cs.visibility === 'hidden' || cs.position !== 'fixed') return 0;
      const wrapperRect = canvasWrapper.getBoundingClientRect();
      const panelRect = panel.getBoundingClientRect();
      // Amount of wrapper's bottom area covered by the fixed panel
      return Math.max(0, wrapperRect.bottom - panelRect.top);
    }

    function centerCanvasInView() {
      const wrapperRect = canvasWrapper.getBoundingClientRect();
      const stage = canvasStage || canvas;
      const stageRect = stage.getBoundingClientRect();
      const bottomInset = getBottomOverlayInset();
      const visibleH = Math.max(0, canvasWrapper.clientHeight - bottomInset);

      const targetLeft = (stageRect.left - wrapperRect.left) + canvasWrapper.scrollLeft - (canvasWrapper.clientWidth - stageRect.width) / 2;
      const targetTop = (stageRect.top - wrapperRect.top) + canvasWrapper.scrollTop - (visibleH - stageRect.height) / 2;

      canvasWrapper.scrollLeft = Math.max(0, targetLeft);
      canvasWrapper.scrollTop = Math.max(0, targetTop);
    }

    // Create guides container
    let guidesContainer = null;

    function initGuidesContainer() {
      if (!guidesContainer) {
        guidesContainer = document.createElement('div');
        guidesContainer.className = 'guides-container';
        canvas.appendChild(guidesContainer);
      }
    }

    function updateCanvasTransform() {
      canvas.style.transform = `scale(${canvasZoom / 100})`;
      updateCanvasStageSize();
      renderCanvasSelectionOverlay();
      updateHandleScales(); // Update handle sizes to compensate for zoom
    }
    
    // Update handles to maintain consistent visual size regardless of zoom
    function updateHandleScales() {
      const inverseScale = 100 / canvasZoom;
      
      // Update resize handles
      document.querySelectorAll('.resize-handle').forEach(handle => {
        const pos = handle.dataset.handle;
        let transform = `scale(${inverseScale})`;
        // Add translateX/Y for edge handles
        if (pos === 'n' || pos === 's') {
          transform += ' translateX(-50%)';
        } else if (pos === 'w' || pos === 'e') {
          transform += ' translateY(-50%)';
        }
        handle.style.transform = transform;
      });
      
      // Update rotation handles
      document.querySelectorAll('.rotation-handle').forEach(handle => {
        handle.style.transform = `translateX(-50%) scale(${inverseScale})`;
      });
      
      document.querySelectorAll('.rotation-line').forEach(line => {
        line.style.transform = `translateX(-50%) scaleY(${inverseScale})`;
      });
      
      // Update multi-select box handles
      document.querySelectorAll('.multi-select-box .ms-handle').forEach(handle => {
        const classList = handle.classList;
        let transform = `scale(${inverseScale})`;
        if (classList.contains('n') || classList.contains('s')) {
          transform += ' translateX(-50%)';
        } else if (classList.contains('w') || classList.contains('e')) {
          transform += ' translateY(-50%)';
        }
        handle.style.transform = transform;
      });
      
      // Update multi-select box border width
      if (multiSelectBox) {
        multiSelectBox.style.borderWidth = `${Math.max(1, 2 / (canvasZoom / 100))}px`;
      }
      
      // Update element selection outline to maintain consistent width
      document.querySelectorAll('.canvas-element.selected').forEach(el => {
        const outlineWidth = Math.max(1, 2 / (canvasZoom / 100));
        el.style.outlineWidth = `${outlineWidth}px`;
      });
    }

    function initSelectionBox() {
      if (!selectionBox) {
        selectionBox = document.createElement('div');
        selectionBox.className = 'selection-box';
        selectionBox.style.display = 'none';
        canvas.appendChild(selectionBox);
      }
      if (!wrapperSelectionBox) {
        wrapperSelectionBox = document.createElement('div');
        wrapperSelectionBox.className = 'wrapper-selection-box';
        wrapperSelectionBox.style.display = 'none';
        canvasWrapper.appendChild(wrapperSelectionBox);
      }
    }

    function removeCanvasSelectionOverlay() {
      if (canvasOverlay && canvasOverlay.parentElement) {
        canvasOverlay.remove();
      }
      canvasOverlay = null;
    }

    function renderCanvasSelectionOverlay() {
      removeCanvasSelectionOverlay();
      if (!canvasSelected) return;
      const wrapperRect = canvasWrapper.getBoundingClientRect();
      const stage = canvasStage || canvas;
      const rect = stage.getBoundingClientRect();
      const overlay = document.createElement('div');
      overlay.className = 'canvas-selection-overlay';
      overlay.style.left = (rect.left - wrapperRect.left + canvasWrapper.scrollLeft) + 'px';
      overlay.style.top = (rect.top - wrapperRect.top + canvasWrapper.scrollTop) + 'px';
      overlay.style.width = rect.width + 'px';
      overlay.style.height = rect.height + 'px';

      const handles = ['nw', 'ne', 'sw', 'se'];
      handles.forEach(pos => {
        const h = document.createElement('div');
        h.className = `canvas-handle ${pos}`;
        h.dataset.canvasHandle = pos;
        overlay.appendChild(h);
      });

      // Rotation handle removed - canvas rotation is disabled

      canvasWrapper.appendChild(overlay);
      canvasOverlay = overlay;
    }

    function highlightCanvasSelection() {
      canvasSelected = true;
      canvas.style.outline = '2px solid #10b981';
      canvas.style.outlineOffset = '4px';
      renderCanvasSelectionOverlay();
      updateFloatingToolbar();
    }

    // Show snap guides
    function showGuide(type, position) {
      if (!guidesContainer) {
        console.warn('Guides container not initialized');
        return;
      }

      const guide = document.createElement('div');
      guide.className = `guide ${type}`;
      guide.style.pointerEvents = 'none';

      if (type === 'horizontal') {
        guide.style.top = position + 'px';
        guide.style.height = '2px';
        guide.style.left = '0';
        guide.style.right = '0';
        guide.style.width = '100%';
      } else {
        guide.style.left = position + 'px';
        guide.style.width = '2px';
        guide.style.top = '0';
        guide.style.bottom = '0';
        guide.style.height = '100%';
      }

      guidesContainer.appendChild(guide);
      activeGuides.push(guide);
    }

    // Clear guides
    function clearGuides() {
      if (activeGuides.length === 0) return;

      activeGuides.forEach(g => {
        if (g && g.parentElement) {
          g.remove();
        }
      });
      activeGuides = [];
    }

    // Project management
    const PROJECTS_KEY = 'qr_studio_projects';
    let currentProjectId = null;
    let autoSaveInterval = null;
    
    function getProjectIdFromURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('project');
    }
    
    function loadProjectsFromStorage() {
      try {
        return JSON.parse(localStorage.getItem(PROJECTS_KEY) || '[]');
      } catch {
        return [];
      }
    }
    
    function saveProjectsToStorage(projects) {
      localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
    }
    
    function loadProject(projectId) {
      const projects = loadProjectsFromStorage();
      const project = projects.find(p => p.id === projectId);
      if (!project) return false;
      
      console.log('Loading project:', project.name);
      
      // Restore canvas settings
      if (project.canvasWidth && project.canvasHeight) {
        const canvas = document.getElementById('canvas');
        const clampedWidth = clampCanvasDimension(project.canvasWidth);
        const clampedHeight = clampCanvasDimension(project.canvasHeight);
        canvas.style.width = clampedWidth + 'px';
        canvas.style.height = clampedHeight + 'px';
        syncCanvasSizeInputs(clampedWidth, clampedHeight);
      }
      
      if (project.canvasBgColor) {
        const canvas = document.getElementById('canvas');
        canvas.style.backgroundColor = project.canvasBgColor;
      }
      
      // Restore file name
      if (project.name) {
        setProjectNameValue(project.name);
      }
      
      // Clear existing elements
      elements.length = 0;
      const canvas = document.getElementById('canvas');
      canvas.querySelectorAll('.element').forEach(el => el.remove());
      
      // Restore elements
      if (project.elements && project.elements.length > 0) {
        project.elements.forEach(elData => {
          if (elData.type === 'qr') {
            // Restore QR element
            qrText = elData.qrText || 'https://example.com';
            addQRElement();
            const el = elements[elements.length - 1];
            Object.assign(el, elData);
            generateQR();
          } else if (elData.type === 'text') {
            addTextElement(elData.text || 'Text');
            const el = elements[elements.length - 1];
            Object.assign(el, elData);
          } else if (elData.type === 'shape') {
            addShapeElement(elData.shapeType || 'rect');
            const el = elements[elements.length - 1];
            Object.assign(el, elData);
          }
        });
        renderElements();
      }
      
      // Update QR panel visibility based on whether QR exists
      updateQRPanelVisibility();
      
      currentProjectId = projectId;
      
      // Clear and reinitialize history
      history = [snapshotState()];
      historyIndex = 0;
      
      return true;
    }

    function getProjectNameValue() {
      const desktop = document.getElementById('project-name-desktop');
      const mobile = document.getElementById('project-name-mobile');
      return (desktop?.value || mobile?.value || 'Thiết kế mới').trim() || 'Thiết kế mới';
    }

    function setProjectNameValue(name) {
      const val = (name || '').toString();
      const desktop = document.getElementById('project-name-desktop');
      const mobile = document.getElementById('project-name-mobile');
      if (desktop) desktop.value = val;
      if (mobile) mobile.value = val;
    }

    function syncProjectNameInputs() {
      const desktop = document.getElementById('project-name-desktop');
      const mobile = document.getElementById('project-name-mobile');
      if (!desktop || !mobile) return;
      const syncToOther = (src, dst) => {
        dst.value = src.value;
      };
      desktop.addEventListener('input', () => syncToOther(desktop, mobile));
      mobile.addEventListener('input', () => syncToOther(mobile, desktop));
    }
    
    function saveCurrentProject() {
      if (!currentProjectId) {
        // Create new project if none exists
        currentProjectId = 'project-' + Date.now();
      }
      
      const canvas = document.getElementById('canvas');
      const clampedWidth = clampCanvasDimension(canvas.style.width);
      const clampedHeight = clampCanvasDimension(canvas.style.height);
      canvas.style.width = clampedWidth + 'px';
      canvas.style.height = clampedHeight + 'px';
      syncCanvasSizeInputs(clampedWidth, clampedHeight);
      
      // Generate thumbnail from QR image cache
      let thumbnail = null;
      if (qrImageCache) {
        thumbnail = qrImageCache; // Use the QR image as thumbnail
      }
      
      const projectData = {
        id: currentProjectId,
        name: getProjectNameValue(),
        canvasWidth: clampedWidth,
        canvasHeight: clampedHeight,
        canvasBgColor: canvas.style.backgroundColor,
        elements: elements.map(el => ({...el})),
        thumbnail: thumbnail,
        updatedAt: new Date().toISOString()
      };
      
      const projects = loadProjectsFromStorage();
      const existingIndex = projects.findIndex(p => p.id === currentProjectId);
      
      if (existingIndex >= 0) {
        projectData.createdAt = projects[existingIndex].createdAt;
        projects[existingIndex] = projectData;
      } else {
        projectData.createdAt = new Date().toISOString();
        projects.unshift(projectData);
      }
      
      saveProjectsToStorage(projects);
      showAutoSaveIndicator();
      console.log('Project saved:', projectData.name);
    }
    
    function showAutoSaveIndicator() {
      // Create or update auto-save indicator - subtle text only
      let indicator = document.getElementById('autosave-indicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'autosave-indicator';
        indicator.style.cssText = `
          position: fixed;
          bottom: 16px;
          right: 16px;
          color: #666;
          font-size: 11px;
          z-index: 10000;
          opacity: 0;
          transition: opacity 0.3s;
        `;
        document.body.appendChild(indicator);
      }
      
      indicator.textContent = 'Đã lưu';
      indicator.style.opacity = '1';
      
      setTimeout(() => {
        indicator.style.opacity = '0';
      }, 1500);
    }
    
    function startAutoSave() {
      // Stop any existing interval
      if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
      }
      
      // Auto-save every 10 seconds
      autoSaveInterval = setInterval(() => {
        saveCurrentProject();
      }, 10000);
      
      console.log('Auto-save started (every 10 seconds)');
    }
    
    function stopAutoSave() {
      if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
      }
    }
    
    // Save before leaving
    window.addEventListener('beforeunload', () => {
      saveCurrentProject();
    });

    // Initialize
    function init() {
      console.log('===== INIT STARTED =====');
      initGuidesContainer();
      initSelectionBox();
      
      // Check for project in URL
      const projectIdFromURL = getProjectIdFromURL();
      if (projectIdFromURL) {
        currentProjectId = projectIdFromURL;
        if (!loadProject(projectIdFromURL)) {
          // Project not found, add default QR
          addQRElement();
        }
      } else {
        // New project - add default QR element
        addQRElement();
      }
      
      // Initialize history with current state
      history = [snapshotState()];
      historyIndex = 0;

      // Setup event listeners
      console.log('Setting up sidebar tabs...');
      setupSidebarTabs();
      console.log('Setting up QR type tabs...');
      setupQRTypeTabs();
      console.log('Setting up color pickers...');
      setupColorPickers();
      console.log('Setting up pills...');
      setupPills();
      console.log('Setting up input listeners...');
      setupInputListeners();
      console.log('Setting up version control...');
      setupVersionControl();
      console.log('Setting up canvas events...');
      setupCanvasEvents();
      console.log('Setting up scroll zoom...');
      setupScrollZoom();
      console.log('Setting up logo upload...');
      setupLogoUpload();
      console.log('Setting up mobile menu...');
      setupMobileMenu();

      // Keep desktop/mobile project name inputs in sync
      syncProjectNameInputs();

      // Mobile-only zoom slider (in bottom panel header)
      setupMobileZoomSlider();

      // Generate initial QR
      console.log('Generating initial QR...');
      generateQR();
      showElementProps();
      updateCanvasTransform();
      updateZoomLabels();
      
      // Initialize shapes grid
      initShapesGrid();
      
      // Initialize floating toolbar
      updateFloatingToolbar();
      updateToolbarPosition();
      
      // Keep canvas centered and toolbar aligned on resize
      const handleViewportResize = () => {
        updateMobilePropsMode();
        if (typeof syncMoreMenuHost === 'function') syncMoreMenuHost();
        scheduleViewportUpdate(false);
      };
      window.addEventListener('resize', handleViewportResize);
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', handleViewportResize);
      }
      canvasWrapper.addEventListener('scroll', () => {
        if (canvasSelected) renderCanvasSelectionOverlay();
        if (wrapperSelectionBox && wrapperSelectionBox.style.display === 'block') {
          wrapperSelectionBox.style.display = 'none';
        }
      }, { passive: true });
      new ResizeObserver(handleViewportResize).observe(canvas);
      new ResizeObserver(handleViewportResize).observe(canvasWrapper);
      handleViewportResize();
      
      // Auto-fit canvas to viewport on initial load
      setTimeout(() => {
        scheduleViewportUpdate(window.innerWidth <= 750);
      }, 100);
      
      // Start auto-save
      startAutoSave();
      
      console.log('===== INIT COMPLETED =====');
    }
    
    // Mobile menu toggle
    function setupMobileMenu() {
      const toggle = document.getElementById('mobile-menu-toggle');
      const sidebar = document.getElementById('sidebar');
      const closeBtn = document.getElementById('mobile-close');
      const mainArea = document.querySelector('.main-area');
      const sidebarHeader = document.querySelector('.sidebar-header');

      const isMobileOrTablet = () => window.innerWidth <= 750;
      const isMobile = () => window.innerWidth <= 750;

      const applyState = (open) => {
        if (!sidebar) return;
        const shouldOpen = open || !isMobileOrTablet();
        sidebar.classList.toggle('open', shouldOpen);
        if (mainArea) {
          mainArea.classList.toggle('sidebar-collapsed', isMobileOrTablet() && !shouldOpen);
          mainArea.classList.toggle('sidebar-open', isMobileOrTablet() && shouldOpen);
        }
      };

      const handleToggle = () => {
        if (!sidebar) return;
        const nextOpen = !sidebar.classList.contains('open');
        applyState(nextOpen);
      };
      
      if (toggle && sidebar) {
        toggle.onclick = handleToggle;
      }
      
      if (closeBtn && sidebar) {
        closeBtn.onclick = (e) => {
          e.preventDefault();
          if (!isMobileOrTablet()) return;
          handleToggle();
        };
      }
      
      // Allow tapping on sidebar header to toggle on mobile/tablet
      if (sidebarHeader && sidebar) {
        sidebarHeader.onclick = (e) => {
          // Don't toggle if clicking on buttons inside header
          if (e.target.closest('a, button')) return;
          if (!isMobileOrTablet()) return;
          handleToggle();
        };
      }
      
      const handleResize = () => {
        if (!sidebar) return;
        if (isMobileOrTablet()) {
          if (closeBtn) closeBtn.style.display = 'block';
          // Start collapsed on mobile/tablet
          if (!sidebar.classList.contains('open')) {
            applyState(false);
          }
        } else {
          if (closeBtn) closeBtn.style.display = 'none';
          sidebar.classList.add('open');
          sidebar.classList.remove('collapsed');
          if (mainArea) {
            mainArea.classList.remove('sidebar-collapsed');
            mainArea.classList.remove('sidebar-open');
          }
        }
      };

      window.addEventListener('resize', handleResize);
      handleResize();
    }
    
    // Logo upload setup
    function setupLogoUpload() {
      const logoUpload = document.getElementById('qr-logo-upload');
      const logoSizeSlider = document.getElementById('logo-size');
      const logoSizeLabel = document.getElementById('logo-size-label');
      const logoRadiusSlider = document.getElementById('logo-radius');
      const logoRadiusLabel = document.getElementById('logo-radius-label');

      // Initialize limits based on current ECC
      syncLogoSizeConstraints(false);
      
      if (logoUpload) {
        logoUpload.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            // Show loading state
            document.getElementById('logo-preview').style.display = 'block';
            document.getElementById('logo-preview-img').src = '';
            document.getElementById('logo-preview-img').alt = 'Đang tải...';
            
            try {
              // Process image - resize if too large but maintain quality
              const processedData = await processLogoImage(file);
              qrLogoData = processedData;
              document.getElementById('logo-preview-img').src = qrLogoData;
              document.getElementById('logo-preview-img').alt = 'Logo';
              // Regenerate QR so backend can carve a quiet area beneath the logo
              generateQR();
            } catch (err) {
              console.error('Logo processing error:', err);
              alert('Không thể xử lý ảnh. Vui lòng thử ảnh khác.');
              document.getElementById('logo-preview').style.display = 'none';
            }
          }
        };
      }
      
      if (logoSizeSlider) {
        // Debounce the slider to prevent lag
        let logoTimeout = null;
        logoSizeSlider.oninput = () => {
          const didClamp = syncLogoSizeConstraints(true);
          if (!didClamp) {
            qrLogoSize = parseInt(logoSizeSlider.value);
            if (logoSizeLabel) logoSizeLabel.textContent = qrLogoSize + '%';
          }
          
          // Debounce QR regeneration (quiet area depends on logo size)
          if (logoTimeout) clearTimeout(logoTimeout);
          logoTimeout = setTimeout(() => {
            if (qrLogoData) generateQR();
          }, 150);
        };
      }

      if (logoRadiusSlider) {
        // Debounce regeneration as rounding affects hole + logo mask
        let radiusTimeout = null;
        logoRadiusSlider.oninput = () => {
          qrLogoRadius = Math.max(0, Math.min(50, parseInt(logoRadiusSlider.value) || 0));
          if (logoRadiusLabel) logoRadiusLabel.textContent = qrLogoRadius + '%';
          if (radiusTimeout) clearTimeout(radiusTimeout);
          radiusTimeout = setTimeout(() => {
            if (qrLogoData) generateQR();
          }, 150);
        };
      }
    }
    
    // Process logo image - resize if too large
    async function processLogoImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (evt) => {
          const img = new Image();
          img.onload = () => {
            // Max size for logo processing
            const maxSize = 500;
            let width = img.width;
            let height = img.height;
            
            // Only resize if image is larger than maxSize
            if (width > maxSize || height > maxSize) {
              if (width > height) {
                height = Math.round(height * maxSize / width);
                width = maxSize;
              } else {
                width = Math.round(width * maxSize / height);
                height = maxSize;
              }
            }
            
            // Create canvas with high quality
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // Use high quality image smoothing
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, width, height);
            
            // Export as PNG to preserve transparency
            resolve(canvas.toDataURL('image/png', 1.0));
          };
          img.onerror = () => reject(new Error('Failed to load image'));
          img.src = evt.target.result;
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
      });
    }
    
    // Remove logo
    function removeLogo() {
      qrLogoData = null;
      document.getElementById('logo-preview').style.display = 'none';
      document.getElementById('qr-logo-upload').value = '';
      generateQR();
    }

    // Sidebar tabs
    function setupSidebarTabs() {
      document.querySelectorAll('.sidebar-tab').forEach(tab => {
        tab.onclick = () => {
          document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.sidebar-panel').forEach(p => p.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById('panel-' + tab.dataset.panel).classList.add('active');

          // Remember last non-props panel for mobile so we can return after auto-opening Properties.
          lastSidebarPanelId = 'panel-' + tab.dataset.panel;
          if (typeof isMobileViewport === 'function' && isMobileViewport()) {
            const tabs = document.querySelector('.sidebar-tabs');
            if (tabs) tabs.classList.remove('hidden');
          }
        };
      });
    }

    // QR type tabs
    function setupQRTypeTabs() {
      document.querySelectorAll('.type-btn').forEach(btn => {
        btn.onclick = () => {
          document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentQRType = btn.dataset.type;

          document.querySelectorAll('.special-form').forEach(f => f.classList.remove('active'));
          document.getElementById('form-' + currentQRType)?.classList.add('active');

          generateQR();
        };
      });
    }

    // Color pickers
    function setupColorPickers() {
      // QR color picker
      const qrColorInput = document.getElementById('qr-color');
      const qrColorPresets = document.getElementById('qr-color-presets');
      const qrBgColorInput = document.getElementById('qr-bg-color');
      const qrBgColorPresets = document.getElementById('qr-bg-presets');
      const canvasBgInput = document.getElementById('canvas-bg');
      const canvasBgPresets = document.getElementById('canvas-bg-presets');

      console.log('Color pickers found:', {
        qrColorInput: !!qrColorInput,
        qrColorPresets: !!qrColorPresets,
        qrBgColorInput: !!qrBgColorInput,
        qrBgColorPresets: !!qrBgColorPresets
      });

      // QR Color change
      if (qrColorInput) {
        qrColorInput.addEventListener('change', () => {
          console.log('QR color changed to:', qrColorInput.value);
          generateQR();
        });
        qrColorInput.addEventListener('input', () => {
          console.log('QR color input to:', qrColorInput.value);
          generateQR();
        });
      }

      // QR BG Color change
      if (qrBgColorInput) {
        qrBgColorInput.addEventListener('change', () => {
          console.log('QR BG color changed to:', qrBgColorInput.value);
          generateQR();
        });
        qrBgColorInput.addEventListener('input', () => {
          console.log('QR BG color input to:', qrBgColorInput.value);
          generateQR();
        });
      }

      // Canvas BG Color change
      if (canvasBgInput) {
        canvasBgInput.addEventListener('change', () => {
          console.log('Canvas BG color changed to:', canvasBgInput.value);
          updateCanvasBg(canvasBgInput.value, true);
        });
        canvasBgInput.addEventListener('input', () => {
          console.log('Canvas BG color input to:', canvasBgInput.value);
          updateCanvasBg(canvasBgInput.value, false);
        });
      }

      // QR Color Presets
      if (qrColorPresets) {
        qrColorPresets.querySelectorAll('.color-dot').forEach(dot => {
          dot.onclick = (e) => {
            e.preventDefault();
            const color = dot.dataset.color;
            console.log('QR preset clicked:', color);
            qrColorInput.value = color;
            qrColorPresets.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
            dot.classList.add('active');
            generateQR();
          };
        });
      }

      // QR BG Color Presets
      if (qrBgColorPresets) {
        qrBgColorPresets.querySelectorAll('.color-dot').forEach(dot => {
          dot.onclick = (e) => {
            e.preventDefault();
            const color = dot.dataset.color;
            console.log('QR BG preset clicked:', color);
            qrBgColorInput.value = color;
            qrBgColorPresets.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
            dot.classList.add('active');
            generateQR();
          };
        });
      }

      // Canvas BG Color Presets
      if (canvasBgPresets) {
        canvasBgPresets.querySelectorAll('.color-dot').forEach(dot => {
          dot.onclick = (e) => {
            e.preventDefault();
            const color = dot.dataset.color;
            console.log('Canvas BG preset clicked:', color);
            if (canvasBgInput) canvasBgInput.value = color;
            canvasBgPresets.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
            dot.classList.add('active');
            updateCanvasBg(color, true);
          };
        });
      }
    }

    // Pills
    function setupPills() {
      ['dot-pills', 'ecc-pills', 'eye-pills'].forEach(id => {
        const row = document.getElementById(id);
        if (!row) return;
        row.addEventListener('click', (e) => {
          const pill = e.target.closest('.pill');
          if (!pill) return;
          row.querySelectorAll('.pill').forEach(p => p.classList.remove('active'));
          pill.classList.add('active');
          if (id === 'dot-pills') {
            currentModuleStyle = pill.dataset.module || currentModuleStyle;
          }
          if (id === 'eye-pills') {
            currentEyeStyle = pill.dataset.eye || currentEyeStyle;
          }
          if (id === 'ecc-pills') {
            // ECC affects how large a logo (and the carved hole) can be while still scanning.
            const didClamp = syncLogoSizeConstraints(true);
            if (qrLogoData && didClamp) {
              generateQR();
              return;
            }
          }
          generateQR();
        });
      });
    }

    function getCurrentECC() {
      return document.querySelector('#ecc-pills .pill.active')?.dataset.ecc || 'H';
    }

    function getMaxLogoPercentByECC(ecc) {
      switch ((ecc || 'H').toUpperCase()) {
        case 'L': return 14;
        case 'M': return 18;
        case 'Q': return 22;
        case 'H':
        default: return 25;
      }
    }

    let lastLogoClampToastAt = 0;
    function syncLogoSizeConstraints(showToastOnClamp = false) {
      const slider = document.getElementById('logo-size');
      const label = document.getElementById('logo-size-label');
      if (!slider) return false;

      const maxAllowed = getMaxLogoPercentByECC(getCurrentECC());
      slider.max = String(maxAllowed);

      const current = parseInt(slider.value) || qrLogoSize || 25;
      if (current <= maxAllowed) {
        qrLogoSize = current;
        if (label) label.textContent = qrLogoSize + '%';
        return false;
      }

      qrLogoSize = maxAllowed;
      slider.value = String(maxAllowed);
      if (label) label.textContent = qrLogoSize + '%';

      if (showToastOnClamp) {
        const now = Date.now();
        if (now - lastLogoClampToastAt > 1800) {
          lastLogoClampToastAt = now;
          showToast(`Logo tối đa ${maxAllowed}% với ECC ${getCurrentECC()}`);
        }
      }
      return true;
    }

    // Debounce utility to reduce rapid calls
    function debounce(fn, delay = 400) {
      let timer;
      return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }
    const debouncedGenerateQR = debounce(generateQR, 400);

    // Input listeners
    function setupInputListeners() {
      const inputs = [
        'input-url', 'input-text', 'input-phone',
        'wifi-ssid', 'wifi-password', 'wifi-security',
        'email-address', 'email-subject', 'email-body',
        'sms-phone', 'sms-message'
      ];

      inputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.oninput = () => debouncedGenerateQR();
          el.onchange = () => generateQR();
        }
      });
      
      // QR customization sliders
      setupQRCustomizationSliders();
    }
    
    function setupQRCustomizationSliders() {
      // Dot gap slider
      const dotGapSlider = document.getElementById('qr-dot-gap');
      const dotGapLabel = document.getElementById('dot-gap-label');
      if (dotGapSlider) {
        dotGapSlider.oninput = () => {
          qrDotGap = parseInt(dotGapSlider.value);
          if (dotGapLabel) dotGapLabel.textContent = qrDotGap + '%';
        };
        dotGapSlider.onchange = () => generateQR();
      }
      
      // Eye thickness slider
      const eyeThicknessSlider = document.getElementById('qr-eye-thickness');
      const eyeThicknessLabel = document.getElementById('eye-thickness-label');
      if (eyeThicknessSlider) {
        eyeThicknessSlider.oninput = () => {
          qrEyeThickness = parseInt(eyeThicknessSlider.value);
          if (eyeThicknessLabel) eyeThicknessLabel.textContent = qrEyeThickness + '%';
        };
        eyeThicknessSlider.onchange = () => generateQR();
      }
    }

    function getModuleCountForVersion(version) {
      return 17 + 4 * version;
    }

    function updateVersionDisplay() {
      const label = document.getElementById('version-label');
      const hint = document.getElementById('version-hint');
      const moduleCount = getModuleCountForVersion(currentQRVersion);
      if (label) label.textContent = ` ${currentQRVersion}`;
      if (hint) hint.textContent = `${moduleCount} × ${moduleCount} ô vuông`;
    }

    function setupVersionControl() {
      const slider = document.getElementById('qr-version');
      if (!slider) return;
      slider.value = currentQRVersion;

      const applyVersionValue = () => {
        currentQRVersion = Math.max(1, Math.min(12, parseInt(slider.value) || 1));
        updateVersionDisplay();
      };

      slider.addEventListener('input', () => {
        applyVersionValue();
      });

      slider.addEventListener('change', () => {
        applyVersionValue();
        generateQR();
      });
      updateVersionDisplay();
    }

    // Get QR data
    function getQRData() {
      switch (currentQRType) {
        case 'url': return document.getElementById('input-url').value || 'https://qrio.vn';
        case 'text': return document.getElementById('input-text').value || 'Hello';
        case 'phone':
          const p = document.getElementById('input-phone').value;
          return p ? 'tel:' + p : 'tel:+84123456789';
        case 'wifi':
          const ssid = document.getElementById('wifi-ssid').value || 'WiFi';
          const pass = document.getElementById('wifi-password').value || '';
          const sec = document.getElementById('wifi-security').value;
          return `WIFI:T:${sec};S:${ssid};P:${pass};;`;
        case 'email':
          const email = document.getElementById('email-address').value || 'test@test.com';
          const subj = encodeURIComponent(document.getElementById('email-subject').value || '');
          const body = encodeURIComponent(document.getElementById('email-body').value || '');
          return `mailto:${email}?subject=${subj}&body=${body}`;
        case 'sms':
          const smsP = document.getElementById('sms-phone').value || '';
          const msg = encodeURIComponent(document.getElementById('sms-message').value || '');
          return `sms:${smsP}?body=${msg}`;
        case 'location':
          const lat = document.getElementById('loc-lat').value || '21.0285';
          const lng = document.getElementById('loc-lng').value || '105.8542';
          const latNum = Number.parseFloat(lat);
          const lngNum = Number.parseFloat(lng);
          const safeLat = Number.isFinite(latNum) ? latNum : 21.0285;
          const safeLng = Number.isFinite(lngNum) ? lngNum : 105.8542;
          // Use our built-in viewer page so scanning always shows a marker + Vietnamese labels.
          return `${window.location.origin}/location?lat=${safeLat.toFixed(6)}&lng=${safeLng.toFixed(6)}&z=18`;
        case 'vcard':
          return generateVCard();
        case 'event':
          return generateVEvent();
        case 'vietqr':
          return generateVietQR();
        case 'crypto':
          return generateCryptoURI();
        case 'file':
          const directUrl = document.getElementById('file-direct-url').value;
          if (directUrl) return directUrl;
          if (uploadedFileUrl) return uploadedFileUrl;
          return 'https://qrio.vn';
        default: return 'https://qrio.vn';
      }
    }
    
    // Helper function for vCard
    function generateVCard() {
      const fn = document.getElementById('vcard-firstname').value || '';
      const ln = document.getElementById('vcard-lastname').value || '';
      const org = document.getElementById('vcard-org').value || '';
      const title = document.getElementById('vcard-title').value || '';
      const phone = document.getElementById('vcard-phone').value || '';
      const email = document.getElementById('vcard-email').value || '';
      const url = document.getElementById('vcard-url').value || '';
      const addr = document.getElementById('vcard-address').value || '';
      
      let vcard = 'BEGIN:VCARD\nVERSION:3.0\n';
      if (fn || ln) vcard += `N:${ln};${fn};;;\n`;
      if (fn || ln) vcard += `FN:${fn} ${ln}\n`;
      if (org) vcard += `ORG:${org}\n`;
      if (title) vcard += `TITLE:${title}\n`;
      if (phone) vcard += `TEL;TYPE=WORK,VOICE:${phone}\n`;
      if (email) vcard += `EMAIL;TYPE=PREF,INTERNET:${email}\n`;
      if (url) vcard += `URL:${url}\n`;
      if (addr) vcard += `ADR;TYPE=WORK:;;${addr.replace(/\n/g, ', ')};;;;\n`;
      vcard += 'END:VCARD';
      return vcard;
    }
    
    // Helper function for Calendar Event
    function generateVEvent() {
      const title = document.getElementById('event-title').value || 'Event';
      const location = document.getElementById('event-location').value || '';
      const startInput = document.getElementById('event-start').value;
      const endInput = document.getElementById('event-end').value;
      const desc = document.getElementById('event-desc').value || '';
      
      const formatDate = (dateStr) => {
        if (!dateStr) return '';
        const d = new Date(dateStr);
        return d.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
      };
      
      const start = formatDate(startInput) || formatDate(new Date().toISOString());
      const end = formatDate(endInput) || formatDate(new Date(Date.now() + 3600000).toISOString());
      
      let vevent = 'BEGIN:VCALENDAR\nVERSION:2.0\nBEGIN:VEVENT\n';
      vevent += `SUMMARY:${title}\n`;
      vevent += `DTSTART:${start}\n`;
      vevent += `DTEND:${end}\n`;
      if (location) vevent += `LOCATION:${location}\n`;
      if (desc) vevent += `DESCRIPTION:${desc.replace(/\n/g, '\\n')}\n`;
      vevent += 'END:VEVENT\nEND:VCALENDAR';
      return vevent;
    }
    
    // Helper function for VietQR
    function generateVietQR() {
      const bankBin = document.getElementById('vietqr-bank').value || '970436';
      const account = document.getElementById('vietqr-account').value || '';
      const name = document.getElementById('vietqr-name').value || '';
      const amount = document.getElementById('vietqr-amount').value || '';
      const memo = document.getElementById('vietqr-memo').value || '';
      
      if (!account) return 'https://qrio.vn';
      
      // VietQR format: EMVCo compatible
      // Simplified version - for full compliance, use VietQR API
      let qrContent = '';
      qrContent += '000201'; // Payload Format Indicator
      qrContent += '010212'; // Point of Initiation Method (dynamic)
      
      // Merchant Account Information (ID 38 for VietQR)
      let mai = '0010A000000727'; // GUID
      mai += `01${String(bankBin.length).padStart(2, '0')}${bankBin}`; // Bank BIN
      mai += `02${String(account.length).padStart(2, '0')}${account}`; // Account
      qrContent += `38${String(mai.length).padStart(2, '0')}${mai}`;
      
      qrContent += '5303704'; // Currency (VND)
      
      if (amount) {
        const amtStr = String(parseInt(amount));
        qrContent += `54${String(amtStr.length).padStart(2, '0')}${amtStr}`;
      }
      
      qrContent += '5802VN'; // Country
      
      if (name) {
        const nameClean = name.substring(0, 25).toUpperCase();
        qrContent += `59${String(nameClean.length).padStart(2, '0')}${nameClean}`;
      }
      
      qrContent += '6006HANOI'; // City (default)
      
      if (memo) {
        const memoClean = memo.substring(0, 25);
        const addData = `08${String(memoClean.length).padStart(2, '0')}${memoClean}`;
        qrContent += `62${String(addData.length).padStart(2, '0')}${addData}`;
      }
      
      // CRC placeholder (calculated by VietQR standard - simplified)
      qrContent += '6304';
      const crc = calculateCRC16(qrContent);
      qrContent = qrContent.slice(0, -4) + '6304' + crc;
      
      return qrContent;
    }
    
    // CRC-16 CCITT calculation for VietQR
    function calculateCRC16(str) {
      let crc = 0xFFFF;
      for (let i = 0; i < str.length; i++) {
        crc ^= str.charCodeAt(i) << 8;
        for (let j = 0; j < 8; j++) {
          if (crc & 0x8000) {
            crc = (crc << 1) ^ 0x1021;
          } else {
            crc <<= 1;
          }
          crc &= 0xFFFF;
        }
      }
      return crc.toString(16).toUpperCase().padStart(4, '0');
    }
    
    // Helper function for Crypto URI
    function generateCryptoURI() {
      const type = document.getElementById('crypto-type').value || 'bitcoin';
      const address = document.getElementById('crypto-address').value || '';
      const amount = document.getElementById('crypto-amount').value || '';
      const label = document.getElementById('crypto-label').value || '';
      
      if (!address) return 'https://qrio.vn';
      
      let uri = `${type}:${address}`;
      const params = [];
      if (amount) params.push(`amount=${amount}`);
      if (label) params.push(`label=${encodeURIComponent(label)}`);
      if (params.length > 0) uri += '?' + params.join('&');
      
      return uri;
    }
    
    // Get current location for Location QR
    function getCurrentLocation() {
      if (!navigator.geolocation) {
        showToast('Trình duyệt không hỗ trợ định vị');
        return;
      }
      
      showToast('Đang lấy vị trí...');
      navigator.geolocation.getCurrentPosition(
        (position) => {
          document.getElementById('loc-lat').value = position.coords.latitude.toFixed(6);
          document.getElementById('loc-lng').value = position.coords.longitude.toFixed(6);
          showToast('Đã lấy vị trí thành công!');
          generateQR();
        },
        (error) => {
          showToast('Không thể lấy vị trí: ' + error.message);
        },
        { enableHighAccuracy: true }
      );
    }
    
    // File upload handling
    let uploadedFileUrl = '';
    let uploadedFileData = null;
    
    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Check file size (5MB limit)
      if (file.size > 5 * 1024 * 1024) {
        showToast('File quá lớn! Tối đa 5MB');
        return;
      }
      
      // Show preview
      document.getElementById('file-upload-preview').style.display = 'block';
      document.getElementById('uploaded-file-name').textContent = file.name;
      document.getElementById('file-size').textContent = formatFileSize(file.size);
      
      // Convert to base64 data URL (for demo - in production, upload to server)
      const reader = new FileReader();
      reader.onload = function(e) {
        uploadedFileData = e.target.result;
        // For demo purposes, we'll encode the file as a data URL
        // In production, you'd upload to a server and get a real URL
        uploadedFileUrl = `https://qrio.vn/download?file=${encodeURIComponent(file.name)}`;
        showToast('File đã sẵn sàng!');
        generateQR();
      };
      reader.readAsDataURL(file);
    }
    
    function removeUploadedFile() {
      uploadedFileUrl = '';
      uploadedFileData = null;
      document.getElementById('file-upload-input').value = '';
      document.getElementById('file-upload-preview').style.display = 'none';
      generateQR();
    }
    
    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Generate QR
    async function generateQR() {
      const qrEl = elements.find(e => e.type === 'qr');
      if (!qrEl) return;

      const el = document.getElementById(qrEl.id);
      if (!el) return;

      const content = el.querySelector('.qr-content');
      content.innerHTML = '<span class="qr-loading">⏳</span>';

      const qrColor = document.getElementById('qr-color').value;
      const bgColor = document.getElementById('qr-bg-color').value;
      const moduleStyle = document.querySelector('#dot-pills .pill.active')?.dataset.module || currentModuleStyle;
      const eccLevel = document.querySelector('#ecc-pills .pill.active')?.dataset.ecc || 'H';
      currentModuleStyle = moduleStyle;
      const qrData = getQRData();

      // Ensure logo size is within safe bounds for the selected ECC
      syncLogoSizeConstraints(false);

      const eyeStyle = document.querySelector('#eye-pills .pill.active')?.dataset.eye || currentEyeStyle;
      currentEyeStyle = eyeStyle;

      // Normalize slider percentages to backend-friendly ratios
      const dotScale = 1; // fixed (removed dot density control)
      const dotGap = Math.max(0, Math.min(0.5, qrDotGap / 100));
      const eyeThickness = Math.max(0.7, Math.min(2, qrEyeThickness / 100));

      console.log('generateQR called with:', {
        data: qrData,
        qr_color: qrColor,
        bg_color: bgColor,
        module_style: moduleStyle,
        eye_style: eyeStyle,
        ecc_level: eccLevel,
        version: currentQRVersion
      });

      const formData = new FormData();
      formData.append('data', qrData);
      formData.append('qr_color', qrColor);
      formData.append('bg_color', bgColor);
      formData.append('box_size', '15');
      formData.append('border', '2');
      formData.append('dot_type', 'rounded');
      formData.append('ecc_level', eccLevel);
      formData.append('version', currentQRVersion.toString());
      formData.append('module_style', moduleStyle);
      formData.append('eye_style', eyeStyle);
      formData.append('logo_size', qrLogoSize.toString());
      formData.append('logo_radius', qrLogoRadius.toString());
      formData.append('dot_scale', dotScale.toString());
      formData.append('dot_gap', dotGap.toString());
      formData.append('eye_thickness', eyeThickness.toString());

      // Add logo if available (backend will also carve quiet area under it)
      if (qrLogoData) {
        const logoBlob = await fetch(qrLogoData).then(r => r.blob());
        formData.append('logo', logoBlob, 'logo.png');
      }

      try {
        const res = await fetch('/api/generate', { method: 'POST', body: formData });
        const result = await res.json();
        console.log('API response:', result);
        if (result.image) {
          qrImageCache = result.image; // Cache the image
          content.innerHTML = `<img class="qr-base" src="${result.image}" alt="QR" />`;

          // Backend may clamp logo size for scan safety; reflect it in UI.
          if (result.logo_size_clamped && typeof result.logo_size_used === 'number') {
            const slider = document.getElementById('logo-size');
            const label = document.getElementById('logo-size-label');
            qrLogoSize = result.logo_size_used;
            if (slider) slider.value = String(qrLogoSize);
            if (label) label.textContent = qrLogoSize + '%';
            if (typeof result.logo_size_max === 'number') {
              showToast(`Logo đã giới hạn ${result.logo_size_used}% (tối đa ${result.logo_size_max}%)`);
            } else {
              showToast(`Logo đã giới hạn ${result.logo_size_used}% để dễ quét`);
            }
            // Keep slider max in sync too
            syncLogoSizeConstraints(false);
          }
        } else {
          content.innerHTML = '<span class="qr-loading" style="color:#f43f5e">❌</span>';
        }
        // Update toolbar position after QR renders
        updateToolbarPosition();
      } catch (err) {
        console.error('Fetch error:', err);
        content.innerHTML = '<span class="qr-loading" style="color:#f43f5e">❌</span>';
      }
    }

    // Add QR element
    function addQRElement() {
      const id = 'el-' + Date.now();
      const size = 200;
      const canvasRect = canvas.getBoundingClientRect();
      const canvasW = parseInt(canvas.style.width);
      const canvasH = parseInt(canvas.style.height);

      saveToHistory();
      elements.push({
        id, type: 'qr',
        x: (canvasW - size) / 2,
        y: (canvasH - size) / 2,
        width: size,
        height: size,
        rotation: 0,
        opacity: 100
      });

      renderElements();
      updateEmptyQRNotice();
      updateQRPanelVisibility();
      generateQR();
    }

    // Helpers for text-based glyphs (numbers/letters) and solid music icons
    const textShapeSvg = (char) => `
      <svg viewBox="0 0 100 100" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <text x="50" y="55" text-anchor="middle" dominant-baseline="middle" font-family="Be Vietnam Pro, sans-serif" font-weight="800" font-size="64" fill="currentColor">${char}</text>
      </svg>
    `;
    const musicNoteSvg = `
      <svg viewBox="0 0 100 100" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <path fill="currentColor" d="M62 18v39.5a15 15 0 1 1-6-11.8V26l24-5v12l-14 3V18z" />
        <circle cx="41" cy="65" r="11" fill="currentColor" />
      </svg>
    `;
    const musicDoubleSvg = `
      <svg viewBox="0 0 100 100" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <path fill="currentColor" d="M36 54.5v18.5a13 13 0 1 1-6-11V41l26-5v18.5a13 13 0 1 1-6-11V31l26-5v14l-16 3.5V62a13 13 0 1 1-6-11V28.5z" />
      </svg>
    `;
    const solidSvg = (paths, viewBox = '0 0 24 24') => {
      const pathContent = Array.isArray(paths)
        ? paths.map(d => `<path fill="currentColor" d="${d}" />`).join('')
        : `<path fill="currentColor" d="${paths}" />`;
      return `
        <svg viewBox="${viewBox}" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          ${pathContent}
        </svg>
      `;
    };

    // Generic SVG loader for external icon sets (Phosphor)
    const svgCache = new Map();
    function normalizeSvgColors(svgText) {
      let normalized = svgText
        .replace(/stroke="(?!none)[^"]*"/gi, 'stroke="currentColor"')
        .replace(/fill="(?!none)[^"]*"/gi, 'fill="currentColor"');
      normalized = normalized.replace(/<svg([^>]*?)>/i, '<svg$1 width="100%" height="100%" preserveAspectRatio="xMidYMid meet">');
      return normalized;
    }
    async function loadSvg(path) {
      if (svgCache.has(path)) return svgCache.get(path);
      const res = await fetch(path);
      if (!res.ok) throw new Error(`SVG load failed: ${res.status}`);
      const text = await res.text();
      const normalized = normalizeSvgColors(text);
      svgCache.set(path, normalized);
      return normalized;
    }

    // Phosphor icon set (regular) via unpkg
    const phosphorBase = 'https://unpkg.com/@phosphor-icons/core@2.1.1/assets/regular/';
    const phosphorShapes = [
      { id: 'ph-star-four', name: 'Sao 4 cánh', svgPath: `${phosphorBase}star-four.svg` },
      { id: 'ph-star-half', name: 'Sao nửa', svgPath: `${phosphorBase}star-half.svg` },
      { id: 'ph-diamond', name: 'Kim cương', svgPath: `${phosphorBase}diamond.svg` },
      { id: 'ph-heart', name: 'Tim tròn', svgPath: `${phosphorBase}heart.svg` },
      { id: 'ph-heart-straight', name: 'Tim thẳng', svgPath: `${phosphorBase}heart-straight.svg` },
      { id: 'ph-drop', name: 'Giọt nước', svgPath: `${phosphorBase}drop.svg` },
      { id: 'ph-flame', name: 'Lửa', svgPath: `${phosphorBase}flame.svg` },
      { id: 'ph-leaf', name: 'Lá', svgPath: `${phosphorBase}leaf.svg` },
      { id: 'ph-snowflake', name: 'Bông tuyết', svgPath: `${phosphorBase}snowflake.svg` },
      { id: 'ph-sun', name: 'Mặt trời', svgPath: `${phosphorBase}sun.svg` },
      { id: 'ph-moon-stars', name: 'Trăng sao', svgPath: `${phosphorBase}moon-stars.svg` },
      { id: 'ph-cloud', name: 'Mây', svgPath: `${phosphorBase}cloud.svg` },
      { id: 'ph-cloud-sun', name: 'Mây nắng', svgPath: `${phosphorBase}cloud-sun.svg` },
      { id: 'ph-cloud-moon', name: 'Mây trăng', svgPath: `${phosphorBase}cloud-moon.svg` },
      { id: 'ph-sparkle', name: 'Lấp lánh', svgPath: `${phosphorBase}sparkle.svg` },
      { id: 'ph-crown', name: 'Vương miện', svgPath: `${phosphorBase}crown.svg` },
      { id: 'ph-trophy', name: 'Cúp', svgPath: `${phosphorBase}trophy.svg` },
      { id: 'ph-medal', name: 'Huy chương', svgPath: `${phosphorBase}medal.svg` },
      { id: 'ph-certificate', name: 'Chứng nhận', svgPath: `${phosphorBase}certificate.svg` },
      { id: 'ph-infinity', name: 'Vô cực', svgPath: `${phosphorBase}infinity.svg` },
      { id: 'ph-flower', name: 'Hoa', svgPath: `${phosphorBase}flower.svg` },
      { id: 'ph-flower-lotus', name: 'Hoa sen', svgPath: `${phosphorBase}flower-lotus.svg` },
      { id: 'ph-butterfly', name: 'Bướm', svgPath: `${phosphorBase}butterfly.svg` },
      { id: 'ph-paw-print', name: 'Dấu chân', svgPath: `${phosphorBase}paw-print.svg` },
      { id: 'ph-bird', name: 'Chim', svgPath: `${phosphorBase}bird.svg` },
      { id: 'ph-fish-simple', name: 'Cá', svgPath: `${phosphorBase}fish-simple.svg` },
      { id: 'ph-tree-evergreen', name: 'Cây thông', svgPath: `${phosphorBase}tree-evergreen.svg` },
      { id: 'ph-tree-palm', name: 'Cây cọ', svgPath: `${phosphorBase}tree-palm.svg` },
      { id: 'ph-mountains', name: 'Núi', svgPath: `${phosphorBase}mountains.svg` },
      { id: 'ph-waves', name: 'Sóng', svgPath: `${phosphorBase}waves.svg` },
      { id: 'ph-rainbow', name: 'Cầu vồng', svgPath: `${phosphorBase}rainbow.svg` },
      { id: 'ph-lightning', name: 'Sét', svgPath: `${phosphorBase}lightning.svg` },
      { id: 'ph-umbrella', name: 'Ô', svgPath: `${phosphorBase}umbrella.svg` },
      { id: 'ph-atom', name: 'Nguyên tử', svgPath: `${phosphorBase}atom.svg` },
      { id: 'ph-planet', name: 'Hành tinh', svgPath: `${phosphorBase}planet.svg` },
      { id: 'ph-globe', name: 'Địa cầu', svgPath: `${phosphorBase}globe.svg` },
      { id: 'ph-compass', name: 'La bàn', svgPath: `${phosphorBase}compass.svg` },
      { id: 'ph-map-pin', name: 'Pin', svgPath: `${phosphorBase}map-pin.svg` },
      { id: 'ph-navigation-arrow', name: 'Mũi tên định vị', svgPath: `${phosphorBase}navigation-arrow.svg` },
      { id: 'ph-airplane-tilt', name: 'Máy bay nghiêng', svgPath: `${phosphorBase}airplane-tilt.svg` },
      { id: 'ph-rocket', name: 'Tên lửa', svgPath: `${phosphorBase}rocket.svg` },
      { id: 'ph-rocket-launch', name: 'Tên lửa phóng', svgPath: `${phosphorBase}rocket-launch.svg` },
      { id: 'ph-anchor', name: 'Mỏ neo', svgPath: `${phosphorBase}anchor.svg` },
      { id: 'ph-sailboat', name: 'Thuyền buồm', svgPath: `${phosphorBase}sailboat.svg` },
      { id: 'ph-bicycle', name: 'Xe đạp', svgPath: `${phosphorBase}bicycle.svg` },
      { id: 'ph-car-simple', name: 'Xe hơi', svgPath: `${phosphorBase}car-simple.svg` },
      { id: 'ph-bus', name: 'Xe bus', svgPath: `${phosphorBase}bus.svg` },
      { id: 'ph-train', name: 'Tàu lửa', svgPath: `${phosphorBase}train.svg` },
      { id: 'ph-subway', name: 'Tàu điện', svgPath: `${phosphorBase}subway.svg` },
      { id: 'ph-balloon', name: 'Bóng bay', svgPath: `${phosphorBase}balloon.svg` },
      { id: 'ph-gift', name: 'Quà', svgPath: `${phosphorBase}gift.svg` },
      { id: 'ph-cake', name: 'Bánh kem', svgPath: `${phosphorBase}cake.svg` },
      { id: 'ph-camera', name: 'Máy ảnh', svgPath: `${phosphorBase}camera.svg` },
      { id: 'ph-video-camera', name: 'Máy quay', svgPath: `${phosphorBase}video-camera.svg` },
      { id: 'ph-music-notes', name: 'Nốt nhạc', svgPath: `${phosphorBase}music-notes.svg` },
      { id: 'ph-headphones', name: 'Tai nghe', svgPath: `${phosphorBase}headphones.svg` },
      { id: 'ph-microphone', name: 'Mic', svgPath: `${phosphorBase}microphone.svg` },
      { id: 'ph-game-controller', name: 'Tay cầm game', svgPath: `${phosphorBase}game-controller.svg` },
      { id: 'ph-dice-six', name: 'Xúc xắc', svgPath: `${phosphorBase}dice-six.svg` },
      { id: 'ph-puzzle-piece', name: 'Mảnh ghép', svgPath: `${phosphorBase}puzzle-piece.svg` },
      { id: 'ph-cube', name: 'Khối lập phương', svgPath: `${phosphorBase}cube.svg` },
      { id: 'ph-stack-simple', name: 'Chồng khối', svgPath: `${phosphorBase}stack-simple.svg` }
    ];


    // Shape catalog with simple base shapes + open-source icons
    const shapesCatalog = [
      // Basic shapes (first 9 shown by default)
      { id: 'rect', name: 'Vuông', style: '' },
      { id: 'rounded', name: 'Bo góc', style: 'border-radius:8px;' },
      { id: 'circle', name: 'Tròn', style: 'border-radius:50%;' },
      { id: 'pill', name: 'Pill', style: 'border-radius:999px;' },
      { id: 'triangle', name: 'Tam giác', style: 'clip-path:polygon(50% 0%, 0% 100%, 100% 100%);' },
      { id: 'triangle-down', name: 'Tam giác ngược', style: 'clip-path:polygon(50% 100%, 0% 0%, 100% 0%);' },
      { id: 'diamond', name: 'Kim cương', style: 'clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);' },
      { id: 'pentagon', name: 'Ngũ giác', style: 'clip-path:polygon(50% 0%, 100% 38%, 81% 100%, 19% 100%, 0% 38%);' },
      { id: 'hexagon', name: 'Lục giác', style: 'clip-path:polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);' },
      { id: 'star', name: 'Sao', style: 'clip-path:polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);' },
      { id: 'star-4', name: 'Sao 4', style: 'clip-path:polygon(50% 0%, 63% 37%, 100% 50%, 63% 63%, 50% 100%, 37% 63%, 0% 50%, 37% 37%);' },
      { id: 'heart', name: 'Trái tim', svg: solidSvg('M12 21.35 10.55 20.03C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.53L12 21.35Z') },
      { id: 'shield-check-solid', name: 'Khiên', svg: solidSvg(['M12 2 4 5v6c0 5.25 3.5 10.74 8 12 4.5-1.26 8-6.75 8-12V5l-8-3Z', 'M11 15 8 12l1.41-1.41L11 12.17l3.59-3.58L16 10l-5 5z']) },
      { id: 'user-solid', name: 'Người dùng', svg: solidSvg(['M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4Z', 'M4 19c0-3.31 3.58-5 8-5s8 1.69 8 5v2H4v-2Z']) },
      { id: 'users-solid', name: 'Nhóm', svg: solidSvg(['M16 11c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3Z', 'M8 11c1.66 0 3-1.34 3-3S9.66 5 8 5 5 6.34 5 8s1.34 3 3 3Z', 'M16 13c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4Z', 'M2 19v-2c0-1.66 2.69-2.92 5.38-2.99a9.5 9.5 0 0 1 2.14.2C7.39 14.6 5 15.88 5 17.5V19H2Z']) },
      { id: 'message-solid', name: 'Hộp chat', svg: solidSvg('M20 2H4a2 2 0 0 0-2 2v16l4-4h14a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2Z') },
      { id: 'phone-solid', name: 'Điện thoại', svg: solidSvg('M6.62 10.79a15.05 15.05 0 0 0 6.59 6.59l2.2-2.2a1 1 0 0 1 1.05-.24c1.15.38 2.38.59 3.54.59a1 1 0 0 1 1 1V20a2 2 0 0 1-2 2C10.07 22 2 13.93 2 4a2 2 0 0 1 2-2h3.25a1 1 0 0 1 1 1c0 1.21.2 2.39.59 3.54a1 1 0 0 1-.25 1.05l-2 2.2Z') },
      { id: 'map-pin-solid', name: 'Pin', svg: solidSvg('M12 2a7 7 0 0 0-7 7c0 5.25 7 13 7 13s7-7.75 7-13a7 7 0 0 0-7-7Zm0 9.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5Z') },
      { id: 'navigation-solid', name: 'Mũi tên', svg: solidSvg('M12 2 4 20l8-4 8 4-8-18Z') },
      { id: 'play-solid', name: 'Play', svg: solidSvg('M8 5v14l11-7-11-7Z') },
      { id: 'pause-solid', name: 'Pause', svg: solidSvg(['M6 5h4v14H6z', 'M14 5h4v14h-4z']) },
      { id: 'stop-solid', name: 'Stop', svg: solidSvg('M6 6h12v12H6z') },
      { id: 'forward-solid', name: 'Tua tới', svg: solidSvg(['M4 5v14l8-7-8-7Z', 'M13 5v14l8-7-8-7Z']) },
      { id: 'backward-solid', name: 'Tua ngược', svg: solidSvg(['M20 5v14l-8-7 8-7Z', 'M11 5v14L3 12l8-7Z']) },
      { id: 'camera-solid', name: 'Camera', svg: solidSvg(['M4 5h4l2-2h4l2 2h4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2Z', 'M12 17a5 5 0 1 0 0-10 5 5 0 0 0 0 10Z']) },
      { id: 'video-solid', name: 'Video', svg: solidSvg(['M4 6h10a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2Z', 'M18 8v8l4 3V5l-4 3Z']) },
      { id: 'bell-solid', name: 'Chuông', svg: solidSvg(['M18 8a6 6 0 1 0-12 0v5H4a1 1 0 0 0 0 2h16a1 1 0 0 0 0-2h-2V8Z', 'M12 21a2 2 0 0 0 2-2H10a2 2 0 0 0 2 2Z']) },
      { id: 'calendar-solid', name: 'Lịch', svg: solidSvg(['M19 4h-1V2h-2v2H8V2H6v2H5a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3Z', 'M20 19H4V10h16v9Z']) },
      { id: 'cloud-solid', name: 'Mây', svg: solidSvg('M6 18h12a4 4 0 0 0 0-8 6 6 0 0 0-11-2A4 4 0 0 0 6 18Z') },
      { id: 'moon-solid', name: 'Trăng', svg: solidSvg('M21 12.79A9 9 0 0 1 11.21 3 7 7 0 1 0 21 12.79Z') },
      { id: 'home-solid', name: 'Nhà', svg: solidSvg('M3 11 12 3 21 11v9a2 2 0 0 1-2 2h-4v-6h-6v6H5a2 2 0 0 1-2-2Z') },
      { id: 'search-solid', name: 'Tìm kiếm', svg: solidSvg(['M10 4a6 6 0 1 1 0 12 6 6 0 0 1 0-12Z', 'M15 13l5 5-2 2-5-5']) },
      { id: 'filter-solid', name: 'Lọc', svg: solidSvg('M4 4h16l-6 6v6.5l-4 3.5V10z') },
      { id: 'menu-solid', name: 'Menu', svg: solidSvg(['M3 6h18v2H3z', 'M3 11h18v2H3z', 'M3 16h18v2H3z']) },
      { id: 'more-horizontal-solid', name: 'Ba chấm ngang', svg: solidSvg(['M6 10a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z', 'M12 10a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z', 'M18 10a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z']) },
      { id: 'more-vertical-solid', name: 'Ba chấm dọc', svg: solidSvg(['M10 6a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z', 'M10 12a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z', 'M10 18a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z']) },
      { id: 'arrow-up-solid', name: 'Mũi tên lên', svg: solidSvg('M12 4l7 7h-4v9h-6v-9H5z') },
      { id: 'arrow-down-solid', name: 'Mũi tên xuống', svg: solidSvg('M12 20l-7-7h4V4h6v9h4z') },
      { id: 'arrow-left-solid', name: 'Mũi tên trái', svg: solidSvg('M4 12l7-7v4h9v6h-9v4z') },
      { id: 'arrow-right-solid', name: 'Mũi tên phải', svg: solidSvg('M20 12l-7 7v-4H4v-6h9V5z') },
      { id: 'inbox-solid', name: 'Hộp thư', svg: solidSvg(['M3 5h18v9h-4l-2 3h-6l-2-3H3z', 'M3 16h3.5l2 3h7l2-3H21v3a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z']) },
      { id: 'folder-solid', name: 'Thư mục', svg: solidSvg('M3 6h7l2 2h9a1 1 0 0 1 1 1v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2Z') },
      { id: 'folder-open-solid', name: 'Thư mục mở', svg: solidSvg(['M3 7h7l2-2h9a1 1 0 0 1 1 1v2H6.6L3 18.5V9a2 2 0 0 1 2-2Z', 'M5.4 12H22l-2.4 8H3l2.4-8Z']) },
      { id: 'file-check-solid', name: 'File', svg: solidSvg(['M6 2h8l4 4v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2Z', 'M14 2v4h4', 'M9 14l-2-2 1.4-1.4L9 11.2l4.6-4.6L15 8l-6 6z']) },
      { id: 'wallet-solid', name: 'Ví', svg: solidSvg(['M4 6h16a2 2 0 0 1 2 2v2h-4a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h4v2a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2Z', 'M18 12h4v4h-4z']) },
      { id: 'tag-solid', name: 'Tag', svg: solidSvg(['M3 9.5 12.5 3h7.5V10l-9.5 9.5a2 2 0 0 1-2.8 0L3 12.3V9.5Z', 'M16 7a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z']) },
      { id: 'droplet-solid', name: 'Giọt nước', svg: solidSvg('M12 2C8 7 6 10 6 13.5A6 6 0 0 0 18 13.5C18 10 16 7 12 2Z') },
      { id: 'bookmark-solid', name: 'Bookmark', svg: solidSvg('M6 3h12a2 2 0 0 1 2 2v16l-8-4-8 4V5a2 2 0 0 1 2-2Z') },

      // Open-source icon shapes (Lucide)
      { id: 'lucide-qr', name: 'QR (Lucide)', lib: 'lucide', icon: 'qr-code' },
      { id: 'lucide-image', name: 'Ảnh (Lucide)', lib: 'lucide', icon: 'image' },
      { id: 'lucide-camera', name: 'Camera (Lucide)', lib: 'lucide', icon: 'camera' },
      { id: 'lucide-qr', name: 'QR', lib: 'lucide', icon: 'qr-code' },
      { id: 'lucide-image', name: 'Ảnh', lib: 'lucide', icon: 'image' },
      { id: 'lucide-camera', name: 'Camera', lib: 'lucide', icon: 'camera' },
      { id: 'lucide-video', name: 'Video', lib: 'lucide', icon: 'video' },
      { id: 'lucide-music', name: 'Nhạc', lib: 'lucide', icon: 'music-2' },
      { id: 'lucide-mic', name: 'Mic', lib: 'lucide', icon: 'mic' },
      { id: 'lucide-map-pin', name: 'Vị trí', lib: 'lucide', icon: 'map-pin' },
      { id: 'lucide-navigation', name: 'La bàn', lib: 'lucide', icon: 'navigation' },
      { id: 'lucide-compass', name: 'Compass', lib: 'lucide', icon: 'compass' },
      { id: 'lucide-globe', name: 'Globe', lib: 'lucide', icon: 'globe-2' },
      { id: 'lucide-wifi', name: 'Wi-Fi', lib: 'lucide', icon: 'wifi' },
      { id: 'lucide-bluetooth', name: 'Bluetooth', lib: 'lucide', icon: 'bluetooth' },
      { id: 'lucide-smartphone', name: 'Điện thoại', lib: 'lucide', icon: 'smartphone' },
      { id: 'lucide-monitor', name: 'Màn hình', lib: 'lucide', icon: 'monitor' },
      { id: 'lucide-cpu', name: 'CPU', lib: 'lucide', icon: 'cpu' },
      { id: 'lucide-cloud', name: 'Mây', lib: 'lucide', icon: 'cloud' },
      { id: 'lucide-palette', name: 'Bảng màu', lib: 'lucide', icon: 'palette' },
      { id: 'lucide-layers', name: 'Layers', lib: 'lucide', icon: 'layers' },
      { id: 'lucide-sparkles', name: 'Sparkles', lib: 'lucide', icon: 'sparkles' },
      { id: 'lucide-badge-check', name: 'Badge', lib: 'lucide', icon: 'badge-check' },
      { id: 'lucide-check-circle', name: 'Check', lib: 'lucide', icon: 'check-circle-2' },
      { id: 'lucide-x-circle', name: 'X', lib: 'lucide', icon: 'x-circle' },
      { id: 'lucide-bell', name: 'Chuông', lib: 'lucide', icon: 'bell' },
      { id: 'lucide-calendar', name: 'Lịch', lib: 'lucide', icon: 'calendar' },
      { id: 'lucide-clock', name: 'Đồng hồ', lib: 'lucide', icon: 'clock-3' },
      { id: 'lucide-tag', name: 'Tag', lib: 'lucide', icon: 'tag' },
      { id: 'lucide-bookmark', name: 'Bookmark', lib: 'lucide', icon: 'bookmark' },
      { id: 'lucide-book', name: 'Sách', lib: 'lucide', icon: 'book-open' },
      { id: 'lucide-file', name: 'File', lib: 'lucide', icon: 'file-text' },
      { id: 'lucide-printer', name: 'Printer', lib: 'lucide', icon: 'printer' },
      { id: 'lucide-download', name: 'Download', lib: 'lucide', icon: 'download' },
      { id: 'lucide-upload', name: 'Upload', lib: 'lucide', icon: 'upload' },
      { id: 'lucide-share', name: 'Share', lib: 'lucide', icon: 'share-2' },
      { id: 'lucide-link', name: 'Link', lib: 'lucide', icon: 'link-2' },
      { id: 'lucide-lock', name: 'Khóa', lib: 'lucide', icon: 'lock' },
      { id: 'lucide-unlock', name: 'Mở khóa', lib: 'lucide', icon: 'unlock' },
      { id: 'lucide-shield', name: 'Khiên', lib: 'lucide', icon: 'shield' },
      { id: 'lucide-shield-check', name: 'Khiên check', lib: 'lucide', icon: 'shield-check' },
      { id: 'lucide-shopping-bag', name: 'Túi', lib: 'lucide', icon: 'shopping-bag' },
      { id: 'lucide-credit-card', name: 'Thẻ', lib: 'lucide', icon: 'credit-card' },
      { id: 'lucide-gift', name: 'Quà', lib: 'lucide', icon: 'gift' },
      { id: 'lucide-ticket', name: 'Vé', lib: 'lucide', icon: 'ticket' },
      { id: 'lucide-rocket', name: 'Rocket', lib: 'lucide', icon: 'rocket' },
      { id: 'lucide-briefcase', name: 'Cặp', lib: 'lucide', icon: 'briefcase' },
      { id: 'lucide-graduation-cap', name: 'Mũ tốt nghiệp', lib: 'lucide', icon: 'graduation-cap' },
      { id: 'lucide-flame', name: 'Lửa', lib: 'lucide', icon: 'flame' },
      { id: 'lucide-headphones', name: 'Tai nghe', lib: 'lucide', icon: 'headphones' },
      { id: 'lucide-radio', name: 'Radio', lib: 'lucide', icon: 'radio' },
      { id: 'num-1', name: 'Số 1', svg: textShapeSvg('1') },
      { id: 'num-2', name: 'Số 2', svg: textShapeSvg('2') },
      { id: 'num-3', name: 'Số 3', svg: textShapeSvg('3') },
      { id: 'num-4', name: 'Số 4', svg: textShapeSvg('4') },
      { id: 'num-5', name: 'Số 5', svg: textShapeSvg('5') },
      { id: 'num-6', name: 'Số 6', svg: textShapeSvg('6') },
      { id: 'num-7', name: 'Số 7', svg: textShapeSvg('7') },
      { id: 'num-8', name: 'Số 8', svg: textShapeSvg('8') },
      { id: 'num-9', name: 'Số 9', svg: textShapeSvg('9') },
      { id: 'letter-a', name: 'Chữ A', svg: textShapeSvg('A') },
      { id: 'letter-b', name: 'Chữ B', svg: textShapeSvg('B') },
      { id: 'letter-c', name: 'Chữ C', svg: textShapeSvg('C') },
      { id: 'letter-d', name: 'Chữ D', svg: textShapeSvg('D') },
      { id: 'letter-e', name: 'Chữ E', svg: textShapeSvg('E') },
      { id: 'letter-f', name: 'Chữ F', svg: textShapeSvg('F') },
      { id: 'letter-g', name: 'Chữ G', svg: textShapeSvg('G') },
      { id: 'letter-h', name: 'Chữ H', svg: textShapeSvg('H') },
      { id: 'letter-i', name: 'Chữ I', svg: textShapeSvg('I') },
      { id: 'letter-j', name: 'Chữ J', svg: textShapeSvg('J') },
      { id: 'letter-k', name: 'Chữ K', svg: textShapeSvg('K') },
      { id: 'letter-l', name: 'Chữ L', svg: textShapeSvg('L') },
      { id: 'letter-m', name: 'Chữ M', svg: textShapeSvg('M') },
      { id: 'letter-n', name: 'Chữ N', svg: textShapeSvg('N') },
      { id: 'letter-o', name: 'Chữ O', svg: textShapeSvg('O') },
      { id: 'letter-p', name: 'Chữ P', svg: textShapeSvg('P') },
      { id: 'letter-q', name: 'Chữ Q', svg: textShapeSvg('Q') },
      { id: 'letter-r', name: 'Chữ R', svg: textShapeSvg('R') },
      { id: 'letter-s', name: 'Chữ S', svg: textShapeSvg('S') },
      { id: 'letter-t', name: 'Chữ T', svg: textShapeSvg('T') },
      { id: 'letter-u', name: 'Chữ U', svg: textShapeSvg('U') },
      { id: 'letter-v', name: 'Chữ V', svg: textShapeSvg('V') },
      { id: 'letter-w', name: 'Chữ W', svg: textShapeSvg('W') },
      { id: 'letter-x', name: 'Chữ X', svg: textShapeSvg('X') },
      { id: 'letter-y', name: 'Chữ Y', svg: textShapeSvg('Y') },
      { id: 'letter-z', name: 'Chữ Z', svg: textShapeSvg('Z') }
    ];

    // Append Phosphor icon set (regular)
    shapesCatalog.push(...phosphorShapes);

    let shapesExpanded = false;
    
    function toggleMoreShapes() {
      shapesExpanded = !shapesExpanded;
      const extraGrid = document.getElementById('shapes-grid-extra');
      const btn = document.getElementById('toggle-shapes-btn');
      if (extraGrid) {
        extraGrid.style.display = shapesExpanded ? 'grid' : 'none';
      }
      if (btn) {
        btn.innerHTML = shapesExpanded 
          ? '<i class="fa-solid fa-chevron-up"></i> Thu gọn' 
          : '<i class="fa-solid fa-chevron-down"></i> Xem thêm hình dạng';
      }
    }

    function initShapesGrid() {
      const mainGrid = document.getElementById('shapes-grid-main');
      const extraGrid = document.getElementById('shapes-grid-extra');
      if (!mainGrid || !extraGrid) return;
      
      mainGrid.innerHTML = '';
      extraGrid.innerHTML = '';
      
      shapesCatalog.forEach((shape, idx) => {
        const div = document.createElement('div');
        div.className = 'shape-preview';
        div.onclick = () => addShapeElement(shape.id);
        div.title = shape.name;

        const isSvgShape = !!shape.svg || shape.lib === 'lucide' || !!shape.svgPath;
        const baseStyle = shape.style || '';
        const thumbClass = `shape-thumb ${isSvgShape ? 'svg-thumb' : ''}`;
        const thumbStyle = isSvgShape
          ? 'background:transparent;color:#fff;display:flex;align-items:center;justify-content:center;'
          : `background:#fff;${baseStyle}`;

        let thumbContent = '';
        if (shape.lib === 'lucide') {
          const iconName = shape.icon || shape.id.replace('lucide-', '');
          thumbContent = `<i data-lucide="${iconName}"></i>`;
        } else if (shape.svg) {
          thumbContent = shape.svg;
        }

        div.innerHTML = `
          <div class="${thumbClass}" style="${thumbStyle}">${thumbContent}</div>
          <span>${shape.name}</span>
        `;

        // Lazy load external SVG thumbnails
        const thumbDiv = div.querySelector('.shape-thumb');
        if (shape.svgPath && thumbDiv) {
          thumbDiv.innerHTML = '<span style="opacity:0.6">...</span>';
          loadSvg(shape.svgPath).then(svg => {
            thumbDiv.innerHTML = svg;
          }).catch(() => {
            thumbDiv.innerHTML = '<span style="opacity:0.6">!</span>';
          });
        }

        if (idx < 9) {
          mainGrid.appendChild(div);
        } else {
          extraGrid.appendChild(div);
        }
      });

      // Render Lucide icons inside the grid
      if (window.lucide) {
        window.lucide.createIcons({ attrs: { 'stroke-width': 2 } });
      }
    }

    // Add shape element
    function addShapeElement(shape = 'rect') {
      const id = 'el-' + Date.now();
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      const size = 120;
      
      // Default color for new shapes
      const defaultColor = '#7c3aed';
      
      saveToHistory();
      elements.push({
        id,
        type: 'shape',
        shapeType: shape,
        fill: defaultColor,
        stroke: '',
        x: canvasW / 2 - size / 2,
        y: canvasH / 2 - size / 2,
        width: size,
        height: size,
        rotation: 0,
        opacity: 100
      });
      renderElements();
    }

    function refreshSelectionStyles() {
      const handles = ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'];
      const isMultiSelect = selectedIds.size >= 2;
      
      elements.forEach(el => {
        const div = document.getElementById(el.id);
        if (!div) return;

        const isSelected = selectedIds.has(el.id);
        div.classList.toggle('selected', isSelected);
        div.classList.toggle('multi-selected', isSelected && isMultiSelect);

        // Remove old handles so we can re-render them if needed
        div.querySelectorAll('.resize-handle, .rotation-handle, .rotation-line').forEach(handle => handle.remove());

        if (isSelected && !isMultiSelect) {
          // Add resize handles only for single selection
          handles.forEach(pos => {
            const handle = document.createElement('div');
            handle.className = `resize-handle ${pos}`;
            handle.dataset.handle = pos;
            div.appendChild(handle);
          });
          
          // Add rotation handle (only for single selection)
          const rotLine = document.createElement('div');
          rotLine.className = 'rotation-line';
          div.appendChild(rotLine);
          
          const rotHandle = document.createElement('div');
          rotHandle.className = 'rotation-handle';
          rotHandle.innerHTML = '<i class="fa-solid fa-rotate"></i>';
          rotHandle.dataset.rotate = 'true';
          div.appendChild(rotHandle);
        }
      });
      
      // Update multi-select box if multiple elements selected
      updateMultiSelectBox();
      
      // Update floating toolbar visibility
      updateFloatingToolbar();
      
      // Update handle scales to compensate for current zoom level
      updateHandleScales();
    }

    function getCanvasPoint(e) {
      const rect = canvas.getBoundingClientRect();
      const scale = canvasZoom / 100;
      return {
        x: (e.clientX - rect.left) / scale,
        y: (e.clientY - rect.top) / scale
      };
    }

    function getCanvasPointFromPage(point) {
      const rect = canvas.getBoundingClientRect();
      const scale = canvasZoom / 100;
      return {
        x: (point.x - rect.left) / scale,
        y: (point.y - rect.top) / scale
      };
    }

    function rectIntersects(el, selection) {
      const x1 = Math.min(selection.x1, selection.x2);
      const y1 = Math.min(selection.y1, selection.y2);
      const x2 = Math.max(selection.x1, selection.x2);
      const y2 = Math.max(selection.y1, selection.y2);
      return !(el.x > x2 || el.x + el.width < x1 || el.y > y2 || el.y + el.height < y1);
    }

    function updateSelectionBox(e) {
      if (!isSelecting || !selectionStart || !wrapperSelectionBox) return;
      const wrapperRect = canvasWrapper.getBoundingClientRect();
      const currentPage = { x: e.clientX, y: e.clientY };
      lastSelectionPoint = currentPage;
      const x1p = Math.min(selectionStart.page.x, currentPage.x) - wrapperRect.left + canvasWrapper.scrollLeft;
      const y1p = Math.min(selectionStart.page.y, currentPage.y) - wrapperRect.top + canvasWrapper.scrollTop;
      const x2p = Math.max(selectionStart.page.x, currentPage.x) - wrapperRect.left + canvasWrapper.scrollLeft;
      const y2p = Math.max(selectionStart.page.y, currentPage.y) - wrapperRect.top + canvasWrapper.scrollTop;

      wrapperSelectionBox.style.left = x1p + 'px';
      wrapperSelectionBox.style.top = y1p + 'px';
      wrapperSelectionBox.style.width = (x2p - x1p) + 'px';
      wrapperSelectionBox.style.height = (y2p - y1p) + 'px';
      wrapperSelectionBox.style.display = 'block';

      // Compute canvas-space rectangle for hit-test
      const currentCanvas = getCanvasPointFromPage(currentPage);
      const x1 = Math.min(selectionStart.canvas.x, currentCanvas.x);
      const y1 = Math.min(selectionStart.canvas.y, currentCanvas.y);
      const x2 = Math.max(selectionStart.canvas.x, currentCanvas.x);
      const y2 = Math.max(selectionStart.canvas.y, currentCanvas.y);

      const hits = elements.filter(el => rectIntersects(el, { x1, y1, x2, y2 }));
      selectedIds.clear();
      hits.forEach(el => selectedIds.add(el.id));
      refreshSelectionStyles();
    }

    // Select element(s) - Canva style
    function selectElement(id, addToSelection = false) {
      // Deselect canvas when selecting element
      if (canvasSelected) {
        canvasSelected = false;
        canvas.style.outline = 'none';
        canvas.style.outlineOffset = '0';
        removeCanvasSelectionOverlay();
      }
      
      if (addToSelection) {
        // Shift+click: toggle selection
        if (selectedIds.has(id)) {
          selectedIds.delete(id);
        } else {
          selectedIds.add(id);
        }
      } else {
        // Normal click: select only this one
        selectedIds.clear();
        if (id) selectedIds.add(id);
      }
      refreshSelectionStyles();
      showElementProps();
      updateMobilePropsMode();
    }

    function clearSelection() {
      selectedIds.clear();
      canvasSelected = false;
      canvas.style.outline = 'none';
      canvas.style.outlineOffset = '0';
      removeCanvasSelectionOverlay();
      removeMultiSelectBox();
      refreshSelectionStyles();
      updateFloatingToolbar();
      showElementProps();
    }

    // ===== LAYER MANAGEMENT =====
    function moveLayerUp() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const selectedArr = [...selectedIds];
      // Sort by current index descending to move from top
      selectedArr.sort((a, b) => elements.findIndex(e => e.id === b) - elements.findIndex(e => e.id === a));
      selectedArr.forEach(id => {
        const idx = elements.findIndex(e => e.id === id);
        if (idx < elements.length - 1) {
          [elements[idx], elements[idx + 1]] = [elements[idx + 1], elements[idx]];
        }
      });
      renderElements();
    }

    function moveLayerDown() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const selectedArr = [...selectedIds];
      // Sort by current index ascending to move from bottom
      selectedArr.sort((a, b) => elements.findIndex(e => e.id === a) - elements.findIndex(e => e.id === b));
      selectedArr.forEach(id => {
        const idx = elements.findIndex(e => e.id === id);
        if (idx > 0) {
          [elements[idx], elements[idx - 1]] = [elements[idx - 1], elements[idx]];
        }
      });
      renderElements();
    }

    function moveLayerToTop() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const selected = elements.filter(e => selectedIds.has(e.id));
      const others = elements.filter(e => !selectedIds.has(e.id));
      elements = [...others, ...selected];
      renderElements();
    }

    function moveLayerToBottom() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const selected = elements.filter(e => selectedIds.has(e.id));
      const others = elements.filter(e => !selectedIds.has(e.id));
      elements = [...selected, ...others];
      renderElements();
    }

    // ===== FLOATING TOOLBAR =====
    function updateFloatingToolbar() {
      const toolbar = document.getElementById('floating-toolbar');
      if (!toolbar) return;
      
      // Always show toolbar (like Canva)
      toolbar.classList.add('visible');
      
      // Update button states based on selection
      const hasSelection = selectedIds.size > 0 || canvasSelected;
      const hasClipboard = clipboard.length > 0;
      const canUndo = historyIndex > 0;
      const canRedo = historyIndex < history.length - 1;
      
      // Get all buttons
      const undoBtn = toolbar.querySelector('[title*="Hoàn tác"]');
      const redoBtn = toolbar.querySelector('[title*="Làm lại"]');
      const copyBtn = toolbar.querySelector('[title*="Copy"]');
      const dupBtn = toolbar.querySelector('[title*="Nhân đôi"]');
      const delBtn = toolbar.querySelector('[title*="Xóa"]');
      const layerBtn = toolbar.querySelector('[title*="Vị trí"]');
      const pasteBtn = toolbar.querySelector('[title*="Dán"]');
      
      // Update disabled states
      if (undoBtn) undoBtn.style.opacity = canUndo ? '1' : '0.4';
      if (redoBtn) redoBtn.style.opacity = canRedo ? '1' : '0.4';
      if (copyBtn) copyBtn.style.opacity = hasSelection ? '1' : '0.4';
      if (dupBtn) dupBtn.style.opacity = hasSelection ? '1' : '0.4';
      if (delBtn) delBtn.style.opacity = hasSelection ? '1' : '0.4';
      if (layerBtn) layerBtn.style.opacity = hasSelection ? '1' : '0.4';
      if (pasteBtn) pasteBtn.style.opacity = hasClipboard ? '1' : '0.4';
      
      // Update toolbar position
      updateToolbarPosition();
      
      // Hide menus
      hideLayerMenu();
      hideMoreMenu();
    }
    
    function toggleLayerMenu() {
      const menu = document.getElementById('layer-menu');
      if (menu) {
        menu.classList.toggle('show');
        hideMoreMenu();
      }
    }
    
    function hideLayerMenu() {
      const menu = document.getElementById('layer-menu');
      if (menu) menu.classList.remove('show');
    }

    // ===== MOBILE: render 3-dots menu inside bottom panel =====
    let mobileMoreMenuOpen = false;
    let lastSidebarPanelBeforeMore = 'panel-qr';

    function setMobileSidebarOpen(open) {
      const sidebar = document.getElementById('sidebar');
      const mainArea = document.querySelector('.main-area');
      if (!sidebar || !mainArea) return;
      if (!isMobileViewport()) return;
      sidebar.classList.toggle('open', !!open);
      mainArea.classList.toggle('sidebar-collapsed', !open);
      mainArea.classList.toggle('sidebar-open', !!open);
    }

    function syncMoreMenuHost() {
      const menu = document.getElementById('more-menu');
      const hostDesktop = document.getElementById('more-menu-host-desktop');
      const hostMobile = document.getElementById('more-menu-host-mobile');
      if (!menu || !hostDesktop || !hostMobile) return;
      if (isMobileViewport()) {
        if (menu.parentElement !== hostMobile) hostMobile.appendChild(menu);
      } else {
        if (menu.parentElement !== hostDesktop) hostDesktop.appendChild(menu);
        mobileMoreMenuOpen = false;
        menu.classList.remove('show');
      }
    }

    function openMobileMorePanel() {
      if (!isMobileViewport()) return;
      syncMoreMenuHost();
      const tabs = document.querySelector('.sidebar-tabs');
      if (tabs) tabs.classList.add('hidden');
      const active = document.querySelector('.sidebar-panel.active');
      if (active && active.id && active.id !== 'panel-more') lastSidebarPanelBeforeMore = active.id;
      setActiveSidebarPanel('panel-more');
      setMobileSidebarOpen(true);
      const menu = document.getElementById('more-menu');
      if (menu) menu.classList.add('show');
    }

    function closeMobileMorePanel() {
      const menu = document.getElementById('more-menu');
      if (menu) menu.classList.remove('show');
      mobileMoreMenuOpen = false;
      if (!isMobileViewport()) return;
      const tabs = document.querySelector('.sidebar-tabs');
      if (tabs) tabs.classList.remove('hidden');
      // Restore state based on selection (props auto-switch) or last panel
      if (typeof updateMobilePropsMode === 'function') {
        updateMobilePropsMode();
      } else {
        const target = document.getElementById(lastSidebarPanelBeforeMore) ? lastSidebarPanelBeforeMore : 'panel-qr';
        setActiveSidebarPanel(target);
      }
    }
    
    function toggleMoreMenu() {
      const menu = document.getElementById('more-menu');
      if (typeof isMobileViewport === 'function' && isMobileViewport()) {
        hideLayerMenu();
        mobileMoreMenuOpen = !mobileMoreMenuOpen;
        if (mobileMoreMenuOpen) openMobileMorePanel();
        else closeMobileMorePanel();
        return;
      }
      if (menu) {
        menu.classList.toggle('show');
        hideLayerMenu();
      }
    }
    
    function hideMoreMenu() {
      const menu = document.getElementById('more-menu');
      if (typeof isMobileViewport === 'function' && isMobileViewport()) {
        closeMobileMorePanel();
        return;
      }
      if (menu) menu.classList.remove('show');
    }
    
    function selectAllElements() {
      elements.forEach(el => selectedIds.add(el.id));
      refreshSelectionStyles();
      updateMultiSelectBox();
      updateFloatingToolbar();
      showElementProps();
    }

    // ===== ALIGN, FLIP, RESET FUNCTIONS =====
    function alignSelected(alignment) {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      
      if (selectedIds.size === 1) {
        // Align to canvas
        const el = selected[0];
        if (alignment === 'left') el.x = 0;
        else if (alignment === 'center') el.x = (canvasW - el.width) / 2;
        else if (alignment === 'right') el.x = canvasW - el.width;
        else if (alignment === 'top') el.y = 0;
        else if (alignment === 'middle') el.y = (canvasH - el.height) / 2;
        else if (alignment === 'bottom') el.y = canvasH - el.height;
      } else {
        // Align selected elements to each other
        const bounds = getSelectionBounds();
        if (!bounds) return;
        
        selected.forEach(el => {
          if (alignment === 'left') el.x = bounds.x;
          else if (alignment === 'center') el.x = bounds.x + (bounds.width - el.width) / 2;
          else if (alignment === 'right') el.x = bounds.x + bounds.width - el.width;
          else if (alignment === 'top') el.y = bounds.y;
          else if (alignment === 'middle') el.y = bounds.y + (bounds.height - el.height) / 2;
          else if (alignment === 'bottom') el.y = bounds.y + bounds.height - el.height;
        });
      }
      
      renderElements();
      updateMultiSelectBox();
    }

    function flipSelected(direction) {
      if (canvasSelected && selectedIds.size === 0) {
        showToast(direction === 'vertical' ? 'Canvas không thể lật dọc' : 'Canvas không thể lật ngang');
        return;
      }
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      const bounds = getSelectionBounds();
      if (!bounds) return;
      
      selected.forEach(el => {
        if (direction === 'horizontal') {
          // Mirror X position within bounds
          const relX = el.x - bounds.x;
          el.x = bounds.x + bounds.width - relX - el.width;
          // Flip content
          el.flipX = !el.flipX;
        } else if (direction === 'vertical') {
          // Mirror Y position within bounds
          const relY = el.y - bounds.y;
          el.y = bounds.y + bounds.height - relY - el.height;
          // Flip content
          el.flipY = !el.flipY;
        }
      });
      
      renderElements();
      updateMultiSelectBox();
    }

    function resetRotation() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      elements.filter(el => selectedIds.has(el.id)).forEach(el => {
        el.rotation = 0;
      });
      
      renderElements();
      showElementProps();
    }

    function fitToCanvas() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      const padding = 20;
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      const bounds = getSelectionBounds();
      if (!bounds) return;
      
      // Calculate scale to fit
      const scaleX = (canvasW - padding * 2) / bounds.width;
      const scaleY = (canvasH - padding * 2) / bounds.height;
      const scale = Math.min(scaleX, scaleY, 2); // Max 2x scale
      
      // Calculate new center position
      const newCenterX = canvasW / 2;
      const newCenterY = canvasH / 2;
      const oldCenterX = bounds.x + bounds.width / 2;
      const oldCenterY = bounds.y + bounds.height / 2;
      
      selected.forEach(el => {
        // Scale relative to bounds center
        const relX = el.x - oldCenterX;
        const relY = el.y - oldCenterY;
        
        el.x = Math.round(newCenterX + relX * scale);
        el.y = Math.round(newCenterY + relY * scale);
        el.width = Math.round(el.width * scale);
        el.height = Math.round(el.height * scale);
        
        if (el.type === 'text' && el.fontSize) {
          el.fontSize = Math.max(8, Math.round(el.fontSize * scale));
        }
      });
      
      renderElements();
      updateMultiSelectBox();
      showElementProps();
    }
    
    // Center selected elements in canvas
    function centerInCanvas() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      const bounds = getSelectionBounds();
      if (!bounds) return;
      
      const offsetX = (canvasW - bounds.width) / 2 - bounds.x;
      const offsetY = (canvasH - bounds.height) / 2 - bounds.y;
      
      selected.forEach(el => {
        el.x = Math.round(el.x + offsetX);
        el.y = Math.round(el.y + offsetY);
      });
      
      renderElements();
      updateMultiSelectBox();
    }
    
    // Rotate selected elements by a specific angle
    function rotateSelected(angle) {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      elements.filter(el => selectedIds.has(el.id)).forEach(el => {
        el.rotation = normalizeRotation((el.rotation || 0) + angle);
      });
      
      renderElements();
      updateMultiSelectBox();
      showElementProps();
    }
    
    // Distribute selected elements evenly
    function distributeSelected(direction) {
      const selected = elements.filter(el => selectedIds.has(el.id));
      if (selected.length < 3) {
        showToast('Cần ít nhất 3 phần tử để phân bố');
        return;
      }
      
      saveToHistory();
      
      if (direction === 'horizontal') {
        // Sort by x position
        selected.sort((a, b) => a.x - b.x);
        const first = selected[0];
        const last = selected[selected.length - 1];
        const totalSpace = (last.x + last.width) - first.x;
        const totalWidths = selected.reduce((sum, el) => sum + el.width, 0);
        const gap = (totalSpace - totalWidths) / (selected.length - 1);
        
        let currentX = first.x + first.width + gap;
        for (let i = 1; i < selected.length - 1; i++) {
          selected[i].x = Math.round(currentX);
          currentX += selected[i].width + gap;
        }
      } else {
        // Sort by y position
        selected.sort((a, b) => a.y - b.y);
        const first = selected[0];
        const last = selected[selected.length - 1];
        const totalSpace = (last.y + last.height) - first.y;
        const totalHeights = selected.reduce((sum, el) => sum + el.height, 0);
        const gap = (totalSpace - totalHeights) / (selected.length - 1);
        
        let currentY = first.y + first.height + gap;
        for (let i = 1; i < selected.length - 1; i++) {
          selected[i].y = Math.round(currentY);
          currentY += selected[i].height + gap;
        }
      }
      
      renderElements();
      updateMultiSelectBox();
    }
    
    // Toggle lock on selected elements
    function toggleLockSelected() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      // Check if any is unlocked -> lock all, otherwise unlock all
      const anyUnlocked = selected.some(el => !el.locked);
      
      selected.forEach(el => {
        el.locked = anyUnlocked;
      });
      
      renderElements();
      showElementProps();
      showToast(anyUnlocked ? 'Đã khóa phần tử' : 'Đã mở khóa phần tử');
    }

    // ===== CONTEXT MENU =====
    let contextMenu = null;
    
    function showContextMenu(e, elementId = null) {
      hideContextMenu();
      
      // If right-clicking on an element, select it first
      if (elementId && !selectedIds.has(elementId)) {
        selectElement(elementId, false);
      }
      
      contextMenu = document.createElement('div');
      contextMenu.className = 'context-menu';
      
      const hasSelection = selectedIds.size > 0;
      const hasClipboard = clipboard.length > 0;
      
      const items = [
        { icon: 'fa-copy', label: 'Copy', shortcut: 'Ctrl+C', action: copySelected, disabled: !hasSelection },
        { icon: 'fa-paste', label: 'Dán', shortcut: 'Ctrl+V', action: pasteClipboard, disabled: !hasClipboard },
        { icon: 'fa-clone', label: 'Nhân đôi', shortcut: 'Ctrl+D', action: duplicateSelected, disabled: !hasSelection },
        { divider: true },
        { icon: 'fa-trash', label: 'Xóa', shortcut: 'Delete', action: deleteSelected, disabled: !hasSelection },
        { divider: true },
        { icon: 'fa-arrow-up', label: 'Đưa lên trên', action: moveLayerUp, disabled: !hasSelection },
        { icon: 'fa-arrow-down', label: 'Đưa xuống dưới', action: moveLayerDown, disabled: !hasSelection },
        { icon: 'fa-angles-up', label: 'Đưa lên trên cùng', action: moveLayerToTop, disabled: !hasSelection },
        { icon: 'fa-angles-down', label: 'Đưa xuống dưới cùng', action: moveLayerToBottom, disabled: !hasSelection },
        { divider: true },
        { icon: 'fa-check-double', label: 'Chọn tất cả', shortcut: 'Ctrl+A', action: () => {
          elements.forEach(el => selectedIds.add(el.id));
          refreshSelectionStyles();
          updateMultiSelectBox();
          showElementProps();
        }},
      ];
      
      items.forEach(item => {
        if (item.divider) {
          const div = document.createElement('div');
          div.className = 'context-menu-divider';
          contextMenu.appendChild(div);
        } else {
          const menuItem = document.createElement('div');
          menuItem.className = 'context-menu-item';
          if (item.disabled) {
            menuItem.style.opacity = '0.4';
            menuItem.style.pointerEvents = 'none';
          }
          menuItem.innerHTML = `
            <i class="fa-solid ${item.icon}"></i>
            <span>${item.label}</span>
            ${item.shortcut ? `<span class="shortcut">${item.shortcut}</span>` : ''}
          `;
          menuItem.onclick = () => {
            item.action();
            hideContextMenu();
          };
          contextMenu.appendChild(menuItem);
        }
      });
      
      // Position menu
      let x = e.clientX;
      let y = e.clientY;
      
      document.body.appendChild(contextMenu);
      
      // Adjust if menu goes off screen
      const rect = contextMenu.getBoundingClientRect();
      if (x + rect.width > window.innerWidth) x = window.innerWidth - rect.width - 5;
      if (y + rect.height > window.innerHeight) y = window.innerHeight - rect.height - 5;
      
      contextMenu.style.left = x + 'px';
      contextMenu.style.top = y + 'px';
    }
    
    function hideContextMenu() {
      if (contextMenu) {
        contextMenu.remove();
        contextMenu = null;
      }
    }

    // ===== UNDO/REDO SYSTEM =====
    function getCanvasState() {
      return {
        width: parseInt(canvas.style.width) || 400,
        height: parseInt(canvas.style.height) || 400,
        background: canvas.style.backgroundColor || '#ffffff',
        radius: parseInt(canvas.style.borderRadius) || 8,
        zoom: canvasZoom || 100
      };
    }

    function applyCanvasState(state) {
      if (!state) return;
      const w = state.width || 400;
      const h = state.height || 400;
      const clampedW = clampCanvasDimension(w);
      const clampedH = clampCanvasDimension(h);
      canvas.style.width = clampedW + 'px';
      canvas.style.height = clampedH + 'px';
      canvas.style.backgroundColor = state.background || '#ffffff';
      canvas.style.borderRadius = (state.radius !== undefined ? state.radius : 8) + 'px';
      canvasZoom = state.zoom !== undefined ? state.zoom : canvasZoom;
      updateCanvasTransform();
      // Sync inputs
      syncCanvasSizeInputs(clampedW, clampedH);
      const cbg = document.getElementById('canvas-bg'); if (cbg) cbg.value = state.background || '#ffffff';
      const pbg = document.getElementById('prop-canvas-bg'); if (pbg) pbg.value = state.background || '#ffffff';
      const rslider = document.getElementById('prop-canvas-radius'); if (rslider) rslider.value = state.radius || 8;
      const rlabel = document.getElementById('canvas-radius-label'); if (rlabel) rlabel.textContent = (state.radius || 8) + 'px';
      centerCanvasInView();
      updateToolbarPosition();
      renderCanvasSelectionOverlay();
    }

    function snapshotState() {
      return {
        elements: JSON.parse(JSON.stringify(elements)),
        canvas: getCanvasState()
      };
    }

    function saveToHistory() {
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      history.push(snapshotState());
      historyIndex = history.length - 1;
      if (history.length > 50) {
        history.shift();
        historyIndex--;
      }
    }

    function restoreFromHistory(idx) {
      const snap = history[idx];
      if (!snap) return;
      elements = JSON.parse(JSON.stringify(snap.elements || []));
      applyCanvasState(snap.canvas);
      selectedIds.clear();
      removeMultiSelectBox();
      renderElements();
      updateFloatingToolbar();
      showElementProps();
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        restoreFromHistory(historyIndex);
        showElementProps();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreFromHistory(historyIndex);
        showElementProps();
      }
    }

    // ===== CLIPBOARD (Copy/Paste/Duplicate) =====
    function copySelected() {
      if (canvasSelected && selectedIds.size === 0) {
        showToast('Canvas không thể copy');
        return;
      }
      if (selectedIds.size === 0) return;
      // Filter out QR elements - QR cannot be copied
      const nonQRElements = elements
        .filter(el => selectedIds.has(el.id) && el.type !== 'qr')
        .map(el => JSON.parse(JSON.stringify(el)));
      
      if (nonQRElements.length === 0) {
        showToast('Mã QR không thể copy');
        return;
      }
      
      clipboard = nonQRElements;
      // Show brief visual feedback
      showToast('Đã copy ' + clipboard.length + ' phần tử');
    }
    
    function showToast(message) {
      // Remove any existing toast
      const existing = document.querySelector('.toast-notification');
      if (existing) existing.remove();
      
      const toast = document.createElement('div');
      toast.className = 'toast-notification';
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: #10b981;
        color: #fff;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 12px;
        z-index: 9999;
        animation: fadeInOut 1.5s ease forwards;
      `;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 1500);
    }

    function pasteClipboard() {
      if (canvasSelected && selectedIds.size === 0) {
        showToast('Canvas không thể paste');
        return;
      }
      if (clipboard.length === 0) return;
      
      // Filter out QR elements in case they somehow got into clipboard
      const nonQRClipboard = clipboard.filter(el => el.type !== 'qr');
      if (nonQRClipboard.length === 0) {
        showToast('Mã QR không thể paste');
        return;
      }
      
      saveToHistory();
      const newIds = [];
      const offset = 20; // Offset from original position
      let counter = 0;
      nonQRClipboard.forEach(el => {
        const newEl = JSON.parse(JSON.stringify(el));
        newEl.id = 'el-' + Date.now() + '-' + (counter++) + '-' + Math.random().toString(36).substr(2, 5);
        newEl.x += offset;
        newEl.y += offset;
        elements.push(newEl);
        newIds.push(newEl.id);
      });
      selectedIds.clear();
      newIds.forEach(id => selectedIds.add(id));
      renderElements();
      updateMultiSelectBox();
      updateFloatingToolbar();
      showElementProps();
    }

    function duplicateSelected() {
      if (canvasSelected && selectedIds.size === 0) {
        showToast('Canvas không thể nhân đôi');
        return;
      }
      if (selectedIds.size === 0) return;
      
      // Filter out QR elements - QR cannot be duplicated
      const nonQRSelected = elements.filter(el => selectedIds.has(el.id) && el.type !== 'qr');
      
      if (nonQRSelected.length === 0) {
        showToast('Mã QR không thể nhân đôi');
        return;
      }
      
      saveToHistory();
      const newIds = [];
      const offset = 20;
      let counter = 0;
      nonQRSelected.forEach(el => {
        const newEl = JSON.parse(JSON.stringify(el));
        newEl.id = 'el-' + Date.now() + '-' + (counter++) + '-' + Math.random().toString(36).substr(2, 5);
        newEl.x += offset;
        newEl.y += offset;
        elements.push(newEl);
        newIds.push(newEl.id);
      });
      selectedIds.clear();
      newIds.forEach(id => selectedIds.add(id));
      renderElements();
      updateMultiSelectBox();
      updateFloatingToolbar();
      showElementProps();
    }

    function deleteSelected() {
      if (canvasSelected && selectedIds.size === 0) {
        showToast('Canvas không thể xóa');
        return;
      }
      if (selectedIds.size === 0) return;
      saveToHistory();
      elements = elements.filter(el => !selectedIds.has(el.id));
      selectedIds.clear();
      removeMultiSelectBox();
      renderElements();
      updateFloatingToolbar();
      showElementProps();
      updateEmptyQRNotice();
      updateQRPanelVisibility();
    }

    // ===== MULTI-SELECT BOUNDING BOX =====
    function getSelectionBounds() {
      const selected = elements.filter(el => selectedIds.has(el.id));
      if (selected.length === 0) return null;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      selected.forEach(el => {
        minX = Math.min(minX, el.x);
        minY = Math.min(minY, el.y);
        maxX = Math.max(maxX, el.x + el.width);
        maxY = Math.max(maxY, el.y + el.height);
      });
      return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    function removeMultiSelectBox() {
      if (multiSelectBox) {
        multiSelectBox.remove();
        multiSelectBox = null;
      }
    }

    function updateMultiSelectBox() {
      removeMultiSelectBox();
      if (selectedIds.size < 2) return;
      
      const bounds = getSelectionBounds();
      if (!bounds) return;
      
      const box = document.createElement('div');
      box.className = 'multi-select-box';
      box.style.left = bounds.x + 'px';
      box.style.top = bounds.y + 'px';
      box.style.width = bounds.width + 'px';
      box.style.height = bounds.height + 'px';
      
      // Apply zoom-compensated border width
      box.style.borderWidth = `${Math.max(1, 2 / (canvasZoom / 100))}px`;
      
      // Add handles
      const inverseScale = 100 / canvasZoom;
      ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'].forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `ms-handle ${pos}`;
        handle.dataset.msHandle = pos;
        
        // Apply inverse scale for consistent handle size
        let transform = `scale(${inverseScale})`;
        if (pos === 'n' || pos === 's') {
          transform += ' translateX(-50%)';
        } else if (pos === 'w' || pos === 'e') {
          transform += ' translateY(-50%)';
        }
        handle.style.transform = transform;
        
        box.appendChild(handle);
      });
      
      // Handle events for moving the entire group
      box.onmousedown = (e) => {
        if (e.target.dataset.msHandle) return; // Let handle event fire
        e.preventDefault();
        e.stopPropagation();
        const startPointer = getCanvasPoint(e);
        multiSelectDragging = {
          startPointer,
          elements: [...selectedIds].map(id => {
            const el = elements.find(e => e.id === id);
            return el ? { el, startX: el.x, startY: el.y } : null;
          }).filter(Boolean),
          startBounds: { ...bounds }
        };
        saveToHistory();
      };
      
      // Handle resize - Canva-style proportional scaling
      box.querySelectorAll('.ms-handle').forEach(handle => {
        handle.onmousedown = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const startPointer = getCanvasPoint(e);
          multiSelectResizing = {
            handle: handle.dataset.msHandle,
            startPointer,
            startBounds: { ...bounds },
            elements: [...selectedIds].map(id => {
              const el = elements.find(e => e.id === id);
              if (!el) return null;
              return {
                el,
                startX: el.x,
                startY: el.y,
                startW: el.width,
                startH: el.height,
                startFontSize: el.type === 'text' ? el.fontSize : null
              };
            }).filter(Boolean)
          };
          saveToHistory();
        };
      });
      
      canvas.appendChild(box);
      multiSelectBox = box;
    }

    function ensureEmptyQRNotice() {
      if (emptyQRNotice) return;
      emptyQRNotice = document.createElement('div');
      emptyQRNotice.className = 'canvas-empty-state';
      emptyQRNotice.innerHTML = `
        <div class="canvas-empty-card">
          <i class="fa-solid fa-qrcode"></i>
          <div class="title">Tạo QR</div>
          <div class="subtitle">Thêm mã QR mới để bắt đầu</div>
          <button class="cta-btn">Tạo QR mới</button>
        </div>
      `;
      const btn = emptyQRNotice.querySelector('.cta-btn');
      if (btn) {
        btn.onclick = (e) => {
          e.stopPropagation();
          addQRElement();
          generateQR();
        };
      }
    }

    function updateEmptyQRNotice() {
      ensureEmptyQRNotice();
      const hasQR = elements.some(el => el.type === 'qr');
      if (!hasQR) {
        if (!canvas.contains(emptyQRNotice)) canvas.appendChild(emptyQRNotice);
        emptyQRNotice.style.display = 'flex';
      } else if (emptyQRNotice && emptyQRNotice.parentElement) {
        emptyQRNotice.remove();
      }
    }

    // Update QR Panel visibility based on whether QR exists
    function updateQRPanelVisibility() {
      const hasQR = elements.some(el => el.type === 'qr');
      const createSection = document.getElementById('qr-create-section');
      const customizeSection = document.getElementById('qr-customize-section');
      
      if (createSection && customizeSection) {
        if (hasQR) {
          createSection.style.display = 'none';
          customizeSection.style.display = 'block';
        } else {
          createSection.style.display = 'block';
          customizeSection.style.display = 'none';
        }
      }
    }

    // Add text element
    function addTextElement(text = 'Text', fontSize = 16, bold = false) {
      const id = 'el-' + Date.now();
      const canvasW = parseInt(canvas.style.width);

      saveToHistory();
      elements.push({
        id, type: 'text',
        text, fontSize, bold,
        italic: false,
        underline: false,
        fontFamily: 'Be Vietnam Pro',
        color: '#1e293b',
        bgColor: '',
        shadow: false,
        opacity: 100,
        x: canvasW / 2 - 50,
        y: 20,
        width: 100,
        height: fontSize + 10,
        rotation: 0
      });

      renderElements();
      selectElement(id);
    }

    // Render all elements
    function renderElements() {
      // Save guides container before clearing
      const savedGuidesContainer = guidesContainer;

      // Clear only child elements, not guides container or multi-select box
      const children = Array.from(canvas.children).filter(child => 
        child !== guidesContainer && child !== selectionBox && child !== multiSelectBox
      );
      children.forEach(child => child.remove());

      elements.forEach(el => {
        const div = document.createElement('div');
        div.id = el.id;
        div.className = 'canvas-element' + (selectedIds.has(el.id) ? ' selected' : '');
        const opacity = el.opacity !== undefined ? el.opacity / 100 : 1;
        div.style.cssText = `left:${el.x}px;top:${el.y}px;width:${el.width}px;height:${el.height}px;`;
        setElementRotation(div, el);

        if (el.type === 'qr') {
          // Use cached QR image if available
          if (qrImageCache) {
            div.innerHTML = `<div class="qr-content"><img class="qr-base" src="${qrImageCache}" alt="QR" /></div>`;
          } else {
            div.innerHTML = '<div class="qr-content"><span class="qr-loading">⏳</span></div>';
          }
          const qrContent = div.querySelector('.qr-content');
          if (qrContent) qrContent.style.opacity = opacity;
        } else if (el.type === 'text') {
          const fontSize = fitTextToContainer(el);
          const fontFamily = el.fontFamily || 'Be Vietnam Pro';
          const fontWeight = el.bold ? '700' : '400';
          const fontStyle = el.italic ? 'italic' : 'normal';
          const textDecor = el.underline ? 'underline' : 'none';
          const bgColor = el.bgColor || 'transparent';
          const shadow = el.shadow ? '2px 2px 4px rgba(0,0,0,0.3)' : 'none';
          
          div.innerHTML = `<div class="text-content" style="
            font-size:${fontSize}px;
            color:${el.color};
            font-weight:${fontWeight};
            font-style:${fontStyle};
            text-decoration:${textDecor};
            font-family:'${fontFamily}', sans-serif;
            background:${bgColor};
            text-shadow:${shadow};
            opacity:${opacity};
          ">${el.text}</div>`;
          loadGoogleFont(fontFamily);
        } else if (el.type === 'shape') {
          const fill = el.fill || '#7c3aed';
          const stroke = el.stroke || '';
          const shape = el.shapeType || 'rect';
          const borderRadius = el.borderRadius || 0;
          const opacity = (el.opacity !== undefined ? el.opacity : 100) / 100;
          
          // Get shape style from catalog
          const shapeInfo = shapesCatalog.find(s => s.id === shape);
          let shapeStyle = shapeInfo ? shapeInfo.style : '';
          
          // Allow custom border radius for rect/rounded shapes
          if (['rect', 'rounded'].includes(shape) && borderRadius > 0) {
            shapeStyle = `border-radius:${borderRadius}px;`;
          }
          
          if (shapeInfo && (shapeInfo.lib === 'lucide' || shapeInfo.svg || shapeInfo.svgPath)) {
            const colorStyle = `color:${fill};opacity:${opacity};`;
            if (shapeInfo.lib === 'lucide') {
              const iconName = shapeInfo.icon || shapeInfo.id.replace('lucide-', '');
              div.innerHTML = `<div class="shape-base shape-svg" style="${colorStyle}"><i data-lucide="${iconName}"></i></div>`;
              setTimeout(() => {
                if (window.lucide) {
                  window.lucide.createIcons({ attrs: { stroke: stroke || fill, 'stroke-width': 2, 'stroke-linecap': 'round', 'stroke-linejoin': 'round' } });
                }
              }, 0);
            } else if (shapeInfo.svg) {
              div.innerHTML = `<div class="shape-base shape-svg" style="${colorStyle}">${shapeInfo.svg}</div>`;
            } else if (shapeInfo.svgPath) {
              div.innerHTML = `<div class="shape-base shape-svg" style="${colorStyle}"><span style="opacity:0.6">...</span></div>`;
              loadSvg(shapeInfo.svgPath).then(svg => {
                const container = div.querySelector('.shape-svg');
                if (container) container.innerHTML = svg;
              }).catch(() => {
                const container = div.querySelector('.shape-svg');
                if (container) container.innerHTML = '<span style="opacity:0.6">!</span>';
              });
            }
          } else {
            div.innerHTML = `<div class="shape-base" style="background:${fill};${stroke ? `border:2px solid ${stroke};` : ''}${shapeStyle}opacity:${opacity};"></div>`;
          }
        }

        canvas.appendChild(div);
      });

      // Restore guides container at end
      if (savedGuidesContainer && !canvas.contains(guidesContainer)) {
        canvas.appendChild(guidesContainer);
      }
      refreshSelectionStyles();
      updateEmptyQRNotice();
    }

    function setElementRotation(div, el) {
      if (!div) return;
      const flipX = el && el.flipX ? -1 : 1;
      const flipY = el && el.flipY ? -1 : 1;
      div.style.transform = `rotate(${normalizeRotation(el.rotation)}deg) scale(${flipX}, ${flipY})`;
    }

    // Fit text to container without clipping
    function fitTextToContainer(el) {
      if (el.type !== 'text') return el.fontSize;

      const padding = 8;
      const availableHeight = Math.max(el.height - padding, 20);
      const maxFontSize = Math.floor(availableHeight * 0.8);
      const minFontSize = 8;

      return Math.max(minFontSize, Math.min(el.fontSize, maxFontSize));
    }

    // Show element properties
    let lastSidebarPanelId = 'panel-qr';

    function isMobileViewport() {
      return window.innerWidth <= 750;
    }

    function syncElementPropsHost() {
      const props = document.getElementById('element-props');
      const hostDesktop = document.getElementById('element-props-host-desktop');
      const hostMobile = document.getElementById('element-props-host-mobile');
      if (!props || !hostDesktop || !hostMobile) return;
      if (isMobileViewport()) {
        if (props.parentElement !== hostMobile) hostMobile.appendChild(props);
      } else {
        if (props.parentElement !== hostDesktop) hostDesktop.appendChild(props);
      }
    }

    function setActiveSidebarPanel(panelId) {
      document.querySelectorAll('.sidebar-panel').forEach(p => p.classList.toggle('active', p.id === panelId));
      const panelKey = panelId.replace('panel-', '');
      document.querySelectorAll('.sidebar-tab').forEach(btn => btn.classList.toggle('active', btn.dataset.panel === panelKey));
    }

    function openMobilePropsPanel() {
      if (!isMobileViewport()) return;
      syncElementPropsHost();
      const tabs = document.querySelector('.sidebar-tabs');
      if (tabs) tabs.classList.add('hidden');
      const active = document.querySelector('.sidebar-panel.active');
      if (active && active.id && active.id !== 'panel-props') lastSidebarPanelId = active.id;
      setActiveSidebarPanel('panel-props');
    }

    function closeMobilePropsPanel() {
      if (!isMobileViewport()) return;
      const tabs = document.querySelector('.sidebar-tabs');
      if (tabs) tabs.classList.remove('hidden');
      const target = document.getElementById(lastSidebarPanelId) ? lastSidebarPanelId : 'panel-qr';
      setActiveSidebarPanel(target);
    }

    function updateMobilePropsMode() {
      syncElementPropsHost();
      const tabs = document.querySelector('.sidebar-tabs');
      if (!isMobileViewport()) {
        // Leaving mobile: restore normal sidebar behavior
        if (tabs) tabs.classList.remove('hidden');
        const active = document.querySelector('.sidebar-panel.active');
        if (active && active.id === 'panel-props') {
          const target = document.getElementById(lastSidebarPanelId) ? lastSidebarPanelId : 'panel-qr';
          setActiveSidebarPanel(target);
        }
        return;
      }
      if (typeof mobileMoreMenuOpen !== 'undefined' && mobileMoreMenuOpen) {
        // Don't fight the explicit "more" panel on mobile
        return;
      }
      const hasSelection = canvasSelected || selectedIds.size > 0;
      if (hasSelection) openMobilePropsPanel();
      else closeMobilePropsPanel();
    }

    function showElementProps() {
      syncElementPropsHost();
      const propsDiv = document.getElementById('element-props');

      // If canvas is selected, show canvas properties
      if (canvasSelected) {
        const canvasW = parseInt(canvas.style.width) || 400;
        const canvasH = parseInt(canvas.style.height) || 400;
        const canvasBg = rgbToHex(canvas.style.backgroundColor || '#ffffff');
        const canvasRadius = parseInt(canvas.style.borderRadius) || 8;
        
        propsDiv.innerHTML = `
        <div class="section">
          <div class="section-title" style="color:#10b981;"><i class="fa-solid fa-square"></i> Canvas</div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Chiều rộng</label>
            <input type="number" id="prop-canvas-w" value="${canvasW}" min="200" max="650" />
          </div>
          <div class="form-group">
            <label>Chiều cao</label>
            <input type="number" id="prop-canvas-h" value="${canvasH}" min="200" max="650" />
          </div>
        </div>
        <div class="form-group">
          <label>Màu nền</label>
          <div class="color-input-wrap">
            <input type="color" id="prop-canvas-bg" value="${canvasBg}" />
          </div>
        </div>
      `;
        
        document.getElementById('prop-canvas-w').oninput = (e) => {
          const clampedW = clampCanvasDimension(e.target.value);
          e.target.value = clampedW;
          const currentH = clampCanvasDimension(canvas.style.height);
          canvas.style.width = clampedW + 'px';
          canvas.style.height = currentH + 'px';
          syncCanvasSizeInputs(clampedW, currentH);
          showElementProps();
          updateToolbarPosition();
          saveToHistory();
        };
        document.getElementById('prop-canvas-h').oninput = (e) => {
          const clampedH = clampCanvasDimension(e.target.value);
          e.target.value = clampedH;
          const currentW = clampCanvasDimension(canvas.style.width);
          canvas.style.height = clampedH + 'px';
          canvas.style.width = currentW + 'px';
          syncCanvasSizeInputs(currentW, clampedH);
          showElementProps();
          updateToolbarPosition();
          saveToHistory();
        };
        document.getElementById('prop-canvas-bg').onchange = (e) => {
          const val = e.target.value;
          const base = document.getElementById('canvas-bg');
          if (base) base.value = val;
          updateCanvasBg(val, true);
        };
        const radiusSlider = document.getElementById('prop-canvas-radius');
        const radiusLabel = document.getElementById('canvas-radius-label');
        if (radiusSlider) {
          radiusSlider.oninput = () => {
            const r = radiusSlider.value;
            canvas.style.borderRadius = r + 'px';
            if (radiusLabel) radiusLabel.textContent = r + 'px';
          };
          radiusSlider.onchange = () => {
            saveToHistory();
          };
        }
        updateMobilePropsMode();
        return;
      }

      // Get first selected element for properties
      const selectedId = selectedIds.size > 0 ? [...selectedIds][0] : null;

      if (!selectedId) {
        propsDiv.innerHTML = `
        <p style="font-size:12px;color:#aaa;margin-top:4px;">Chọn một phần tử trên canvas để xem và chỉnh sửa thuộc tính.</p>
      `;
        updateMobilePropsMode();
        return;
      }

      const el = elements.find(e => e.id === selectedId);
      if (!el) return;

      const rotationValue = normalizeRotation(el.rotation);
      if (el.type === 'text') {
        propsDiv.innerHTML = `
        <div class="form-group">
          <label>Nội dung <small style="color:#888">(nhấp đúp để sửa trực tiếp)</small></label>
          <input type="text" id="prop-text" value="${el.text}" />
        </div>
        <div class="form-group">
          <label>Font chữ <small style="color:#888">(nhấp để chọn)</small></label>
          <div class="font-picker-wrapper">
            <input type="text" id="prop-fontfamily" class="font-picker-input" value="${el.fontFamily || 'Be Vietnam Pro'}" style="font-family:'${el.fontFamily || 'Be Vietnam Pro'}';" readonly />
            <div class="font-picker-dropdown" id="font-dropdown">
              <div class="font-picker-search">
                <input type="text" id="font-search" placeholder="Tìm font..." autocomplete="off" />
              </div>
              <div id="font-list"></div>
            </div>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Cỡ chữ</label>
            <input type="number" id="prop-fontsize" value="${el.fontSize}" min="10" max="120" />
          </div>
          <div class="form-group">
            <label>Góc xoay (°)</label>
            <input type="number" id="prop-rotation" value="${rotationValue}" min="-360" max="360" step="1" />
          </div>
        </div>
        <div class="form-group">
          <label>Kiểu chữ</label>
          <div class="pill-row">
            <button class="pill ${el.bold ? 'active' : ''}" id="prop-bold-btn" title="In đậm"><i class="fa-solid fa-bold"></i></button>
            <button class="pill ${el.italic ? 'active' : ''}" id="prop-italic-btn" title="In nghiêng"><i class="fa-solid fa-italic"></i></button>
            <button class="pill ${el.underline ? 'active' : ''}" id="prop-underline-btn" title="Gạch chân"><i class="fa-solid fa-underline"></i></button>
            <button class="pill ${el.shadow ? 'active' : ''}" id="prop-shadow-btn" title="Đổ bóng"><i class="fa-solid fa-clone"></i></button>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Màu chữ</label>
            <div class="color-input-wrap">
              <input type="color" id="prop-color" value="${el.color}" />
            </div>
          </div>
          <div class="form-group">
            <label>Nền chữ</label>
            <div class="color-input-wrap" style="position:relative">
              <input type="color" id="prop-bgcolor" value="${el.bgColor || '#ffffff'}" />
              ${el.bgColor ? '<span id="clear-bgcolor" style="position:absolute;top:-5px;right:-5px;background:#dc2626;color:#fff;border-radius:50%;width:14px;height:14px;font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;">×</span>' : ''}
            </div>
          </div>
        </div>
        <div class="form-group">
          <label>Độ trong suốt</label>
          <div class="opacity-row">
            <input type="range" id="prop-opacity" min="0" max="100" value="${el.opacity !== undefined ? el.opacity : 100}" />
            <span id="opacity-label">${el.opacity !== undefined ? el.opacity : 100}%</span>
          </div>
        </div>
        <button class="toolbar-btn" style="width:100%;justify-content:center;margin-top:8px;background:#dc2626" onclick="deleteSelected()">🗑 Xóa</button>
      `;

        // Event handlers
        document.getElementById('prop-text').oninput = (e) => { el.text = e.target.value; renderElements(); };
        
        // Custom Font Picker
        const fontInput = document.getElementById('prop-fontfamily');
        const fontDropdown = document.getElementById('font-dropdown');
        const fontList = document.getElementById('font-list');
        const fontSearch = document.getElementById('font-search');
        
        function renderFontList(filter = '') {
          const filtered = fontCatalog.filter(f => f.toLowerCase().includes(filter.toLowerCase()));
          fontList.innerHTML = filtered.map(f => `
            <div class="font-picker-item ${f === el.fontFamily ? 'selected' : ''}" 
                 data-font="${f}" 
                 style="font-family:'${f}';">${f}</div>
          `).join('');
          
          // Preload fonts for visible items
          filtered.slice(0, 15).forEach(f => loadGoogleFont(f));
          
          // Click handler for font items
          fontList.querySelectorAll('.font-picker-item').forEach(item => {
            item.onclick = () => {
              const font = item.dataset.font;
              el.fontFamily = font;
              fontInput.value = font;
              fontInput.style.fontFamily = `'${font}'`;
              loadGoogleFont(font);
              renderElements();
              fontDropdown.classList.remove('show');
            };
          });
        }
        
        fontInput.onclick = () => {
          fontDropdown.classList.toggle('show');
          if (fontDropdown.classList.contains('show')) {
            renderFontList();
            fontSearch.value = '';
            fontSearch.focus();
          }
        };
        
        fontSearch.oninput = () => renderFontList(fontSearch.value);
        fontSearch.onclick = (e) => e.stopPropagation();
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function closeFontDropdown(e) {
          if (!e.target.closest('.font-picker-wrapper')) {
            fontDropdown.classList.remove('show');
          }
        }, { once: false });
        
        document.getElementById('prop-fontsize').oninput = (e) => { el.fontSize = parseInt(e.target.value); el.height = el.fontSize + 10; renderElements(); };
        document.getElementById('prop-color').oninput = (e) => { el.color = e.target.value; renderElements(); };
        
        // Style toggle buttons
        document.getElementById('prop-bold-btn').onclick = () => { el.bold = !el.bold; showElementProps(); renderElements(); };
        document.getElementById('prop-italic-btn').onclick = () => { el.italic = !el.italic; showElementProps(); renderElements(); };
        document.getElementById('prop-underline-btn').onclick = () => { el.underline = !el.underline; showElementProps(); renderElements(); };
        document.getElementById('prop-shadow-btn').onclick = () => { el.shadow = !el.shadow; showElementProps(); renderElements(); };
        
        // Background color
        document.getElementById('prop-bgcolor').oninput = (e) => { el.bgColor = e.target.value; renderElements(); };
        const clearBg = document.getElementById('clear-bgcolor');
        if (clearBg) clearBg.onclick = () => { el.bgColor = ''; showElementProps(); renderElements(); };
        
        // Opacity
        const opacitySlider = document.getElementById('prop-opacity');
        const opacityLabel = document.getElementById('opacity-label');
        if (opacitySlider) {
          opacitySlider.oninput = () => {
            el.opacity = parseInt(opacitySlider.value);
            if (opacityLabel) opacityLabel.textContent = el.opacity + '%';
            renderElements();
          };
        }
      } else if (el.type === 'qr') {
        propsDiv.innerHTML = `
        <div class="form-group">
          <label>Kích thước</label>
          <input type="number" id="prop-qr-size" value="${el.width}" min="100" max="400" />
        </div>
        <div class="form-group">
          <label>Góc xoay (°)</label>
          <input type="number" id="prop-rotation" value="${rotationValue}" min="-360" max="360" step="1" />
        </div>
        <div class="form-group">
          <label>Độ trong suốt</label>
          <div class="opacity-row">
            <input type="range" id="prop-opacity" min="0" max="100" value="${el.opacity !== undefined ? el.opacity : 100}" />
            <span id="opacity-label">${el.opacity !== undefined ? el.opacity : 100}%</span>
          </div>
        </div>
      `;

        document.getElementById('prop-qr-size').oninput = (e) => {
          const size = parseInt(e.target.value);
          el.width = size;
          el.height = size;
          renderElements();
        };
        
        // Opacity
        const opacitySlider = document.getElementById('prop-opacity');
        const opacityLabel = document.getElementById('opacity-label');
        if (opacitySlider) {
          opacitySlider.oninput = () => {
            el.opacity = parseInt(opacitySlider.value);
            if (opacityLabel) opacityLabel.textContent = el.opacity + '%';
            renderElements();
          };
        }
      } else if (el.type === 'shape') {
        const shapeInfo = shapesCatalog.find(s => s.id === el.shapeType);
        const shapeName = shapeInfo ? shapeInfo.name : el.shapeType;
        const canRoundCorners = ['rect', 'rounded'].includes(el.shapeType);
        const borderRadius = el.borderRadius || 0;
        
        propsDiv.innerHTML = `
        <div class="section">
          <div class="section-title" style="color:#7c3aed;"><i class="fa-solid fa-shapes"></i> ${shapeName}</div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Chiều rộng</label>
            <input type="number" id="prop-shape-w" value="${el.width}" min="20" max="800" />
          </div>
          <div class="form-group">
            <label>Chiều cao</label>
            <input type="number" id="prop-shape-h" value="${el.height}" min="20" max="800" />
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Màu nền</label>
            <div class="color-input-wrap">
              <input type="color" id="prop-shape-fill" value="${el.fill || '#2563eb'}" />
            </div>
          </div>
          <div class="form-group">
            <label>Viền</label>
            <div class="color-input-wrap" style="position:relative">
              <input type="color" id="prop-shape-stroke" value="${el.stroke || '#000000'}" />
              ${el.stroke ? '<span id="clear-stroke" style="position:absolute;top:-5px;right:-5px;background:#dc2626;color:#fff;border-radius:50%;width:14px;height:14px;font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;">×</span>' : ''}
            </div>
          </div>
        </div>
        ${canRoundCorners ? `
        <div class="form-group">
          <label>Bo góc</label>
          <div class="opacity-row">
            <input type="range" id="prop-shape-radius" min="0" max="50" value="${borderRadius}" />
            <span id="shape-radius-label">${borderRadius}px</span>
          </div>
        </div>
        ` : ''}
        <div class="form-group">
          <label>Góc xoay (°)</label>
          <input type="number" id="prop-rotation" value="${rotationValue}" min="-360" max="360" step="1" />
        </div>
        <div class="form-group">
          <label>Độ trong suốt</label>
          <div class="opacity-row">
            <input type="range" id="prop-opacity" min="0" max="100" value="${el.opacity !== undefined ? el.opacity : 100}" />
            <span id="opacity-label">${el.opacity !== undefined ? el.opacity : 100}%</span>
          </div>
        </div>
        <button class="toolbar-btn" style="width:100%;justify-content:center;margin-top:8px;background:#dc2626" onclick="deleteSelected()">🗑 Xóa</button>
      `;

        document.getElementById('prop-shape-w').oninput = (e) => { el.width = parseInt(e.target.value); renderElements(); };
        document.getElementById('prop-shape-h').oninput = (e) => { el.height = parseInt(e.target.value); renderElements(); };
        document.getElementById('prop-shape-fill').oninput = (e) => { el.fill = e.target.value; renderElements(); };
        document.getElementById('prop-shape-stroke').oninput = (e) => { el.stroke = e.target.value; showElementProps(); renderElements(); };
        
        const clearStroke = document.getElementById('clear-stroke');
        if (clearStroke) clearStroke.onclick = () => { el.stroke = ''; showElementProps(); renderElements(); };
        
        if (canRoundCorners) {
          const radiusSlider = document.getElementById('prop-shape-radius');
          const radiusLabel = document.getElementById('shape-radius-label');
          if (radiusSlider) {
            radiusSlider.oninput = () => {
              el.borderRadius = parseInt(radiusSlider.value);
              if (radiusLabel) radiusLabel.textContent = el.borderRadius + 'px';
              renderElements();
            };
          }
        }
        
        // Opacity
        const opacitySlider = document.getElementById('prop-opacity');
        const opacityLabel = document.getElementById('opacity-label');
        if (opacitySlider) {
          opacitySlider.oninput = () => {
            el.opacity = parseInt(opacitySlider.value);
            if (opacityLabel) opacityLabel.textContent = el.opacity + '%';
            renderElements();
          };
        }
      }
      const rotationInput = document.getElementById('prop-rotation');
      if (rotationInput) {
        const updateRotation = (e) => {
          const sanitized = normalizeRotation(e.target.value);
          el.rotation = sanitized;
          rotationInput.value = sanitized;
          updateElementPosition(el);
        };
        rotationInput.oninput = updateRotation;
        rotationInput.onchange = updateRotation;
      }

      updateMobilePropsMode();
    }

    // Track currently editing text element
    let editingTextId = null;
    
    // Start inline text editing (double-click like Canva)
    function startInlineEdit(el) {
      if (el.type !== 'text') return;
      
      editingTextId = el.id;
      const div = document.getElementById(el.id);
      if (!div) return;
      
      const textContent = div.querySelector('.text-content');
      if (!textContent) return;
      
      div.classList.add('editing');
      textContent.classList.add('editing');
      textContent.contentEditable = 'true';
      textContent.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(textContent);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
      
      // Save on blur
      textContent.onblur = () => {
        el.text = textContent.textContent || 'Text';
        exitInlineEdit();
        renderElements();
      };
      
      // Save on Enter (but allow Shift+Enter for newline)
      textContent.onkeydown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          textContent.blur();
        }
        if (e.key === 'Escape') {
          e.preventDefault();
          textContent.blur();
        }
        // Stop propagation so Delete doesn't delete the element
        e.stopPropagation();
      };
    }
    
    // Exit inline editing
    function exitInlineEdit() {
      if (!editingTextId) return;
      
      const div = document.getElementById(editingTextId);
      if (div) {
        div.classList.remove('editing');
        const textContent = div.querySelector('.text-content');
        if (textContent) {
          textContent.classList.remove('editing');
          textContent.contentEditable = 'false';
        }
      }
      editingTextId = null;
    }

    // Canvas events - Canva style
    function setupCanvasEvents() {
      
      // Start selection from wrapper background (outside canvas)
      canvasWrapper.onmousedown = (e) => {
        if (e.button !== 0) return;
        if (e.target.closest('.canvas-element') || e.target.closest('.canvas-selection-overlay') || e.target.closest('.multi-select-box')) return;
        const wrapperRect = canvasWrapper.getBoundingClientRect();
        const pagePoint = { x: e.clientX, y: e.clientY };
        selectionStart = {
          page: pagePoint,
          canvas: getCanvasPointFromPage(pagePoint)
        };
        isSelecting = true;
        selectionStartedOnWrapper = true;
        lastSelectionPoint = { ...pagePoint };
        if (wrapperSelectionBox) {
          wrapperSelectionBox.style.left = (pagePoint.x - wrapperRect.left + canvasWrapper.scrollLeft) + 'px';
          wrapperSelectionBox.style.top = (pagePoint.y - wrapperRect.top + canvasWrapper.scrollTop) + 'px';
          wrapperSelectionBox.style.width = '0px';
          wrapperSelectionBox.style.height = '0px';
          wrapperSelectionBox.style.display = 'none';
        }
        if (!e.shiftKey) clearSelection();
      };

      // Canvas handle interactions (resize / rotate)
      document.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        const handle = e.target.closest('[data-canvas-handle]');
        const rotHandle = e.target.closest('[data-canvas-rotate]');
        if (!handle && !rotHandle) return;
        canvasSelected = true;
        selectedIds.clear();
        showElementProps();
        renderCanvasSelectionOverlay();

        const rect = canvas.getBoundingClientRect();
        const startPointer = { x: e.clientX, y: e.clientY };
        if (handle) {
          e.preventDefault();
          saveToHistory();
          canvasResizing = {
            handle: handle.dataset.canvasHandle,
            startPointer,
            startW: parseInt(canvas.style.width) || rect.width,
            startH: parseInt(canvas.style.height) || rect.height
          };
        } else if (rotHandle) {
          e.preventDefault();
          saveToHistory();
          const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
          canvasRotating = {
            center,
            startPointer,
            startAngle: Math.atan2(startPointer.y - center.y, startPointer.x - center.x),
            startRotation: canvasRotation
          };
        }
      });

      // Double-click to edit text inline
      canvas.ondblclick = (e) => {
        const target = e.target.closest('.canvas-element');
        if (!target) return;
        
        const el = elements.find(el => el.id === target.id);
        if (el && el.type === 'text') {
          e.preventDefault();
          startInlineEdit(el);
        }
      };
      
      // Right-click context menu
      canvas.oncontextmenu = (e) => {
        e.preventDefault();
        const target = e.target.closest('.canvas-element');
        const elementId = target ? target.id : null;
        showContextMenu(e, elementId);
      };
      
      canvasWrapper.oncontextmenu = (e) => {
        e.preventDefault();
        const target = e.target.closest('.canvas-element');
        const elementId = target ? target.id : null;
        showContextMenu(e, elementId);
      };
      
      // Hide context menu on click anywhere
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
          hideContextMenu();
        }
        // Hide floating toolbar menus
        if (!e.target.closest('.floating-toolbar-dropdown') && !e.target.closest('.floating-toolbar-menu')) {
          hideLayerMenu();
          hideMoreMenu();
        }
      });
      
      canvas.onmousedown = (e) => {
        if (e.button !== 0) return;
        
        // Hide context menu
        hideContextMenu();
        
        // Deselect canvas when clicking on canvas content
        if (canvasSelected) {
          canvasSelected = false;
          canvas.style.outline = 'none';
          canvas.style.outlineOffset = '0';
          removeCanvasSelectionOverlay();
        }
        
        // If clicking outside the editing element, exit edit mode
        if (editingTextId) {
          const target = e.target.closest('.canvas-element');
          if (!target || target.id !== editingTextId) {
            exitInlineEdit();
          } else {
            // Allow clicking inside the editing text
            return;
          }
        }

        const canvasPoint = getCanvasPoint(e);

        const target = e.target.closest('.canvas-element');
        const handle = e.target.closest('.resize-handle');
        const rotateHandle = e.target.closest('.rotation-handle');

        if (rotateHandle) {
          // Start rotating
          const elId = rotateHandle.closest('.canvas-element')?.id;
          if (!elId || !selectedIds.has(elId)) return;

          const el = elements.find(e => e.id === elId);
          if (!el) return;

          e.preventDefault();
          saveToHistory();
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          rotating = {
            el,
            centerX,
            centerY,
            startAngle: Math.atan2(canvasPoint.y - centerY, canvasPoint.x - centerX),
            startRotation: normalizeRotation(el.rotation)
          };
        } else if (handle) {
          // Start resizing - only if element is selected
          const elId = handle.closest('.canvas-element')?.id;
          if (!elId || !selectedIds.has(elId)) return;

          const el = elements.find(e => e.id === elId);
          if (!el) return;

          e.preventDefault();
          saveToHistory();
          resizing = {
            el,
            handle: handle.dataset.handle,
            startPointer: canvasPoint,
            startW: el.width,
            startH: el.height,
            startElX: el.x,
            startElY: el.y,
            startFontSize: el.fontSize || 16
          };
        } else if (target) {
          // Click on element
          e.preventDefault();
          const id = target.id;

          if (e.shiftKey) {
            // Shift+click: add/remove from selection
            selectElement(id, true);
          } else if (!selectedIds.has(id)) {
            // Click on unselected element: select it
            selectElement(id, false);
          }
          // If already selected, prepare for drag

          // Start dragging all selected elements
          const el = elements.find(e => e.id === id);
          if (el) {
            saveToHistory();
            dragging = {
              startPointer: canvasPoint,
              elements: [...selectedIds].map(id => {
                const el = elements.find(e => e.id === id);
                return el ? { el, startX: el.x, startY: el.y } : null;
              }).filter(Boolean)
            };
          }
        } else {
          // Click on empty canvas background - start selection box
          e.preventDefault();
          const wrapperRect = canvasWrapper.getBoundingClientRect();
          const pagePoint = { x: e.clientX, y: e.clientY };
          selectionStart = {
            page: pagePoint,
            canvas: getCanvasPointFromPage(pagePoint)
          };
          isSelecting = true;
          selectionStartedOnCanvas = true; // Track that we clicked on canvas background
          lastSelectionPoint = { ...pagePoint };

          if (wrapperSelectionBox) {
            wrapperSelectionBox.style.left = (pagePoint.x - wrapperRect.left + canvasWrapper.scrollLeft) + 'px';
            wrapperSelectionBox.style.top = (pagePoint.y - wrapperRect.top + canvasWrapper.scrollTop) + 'px';
            wrapperSelectionBox.style.width = '0px';
            wrapperSelectionBox.style.height = '0px';
            wrapperSelectionBox.style.display = 'none';
          }

          // Clear selection unless shift is held
          if (!e.shiftKey) {
            clearSelection();
          }
        }
      };

      document.onmousemove = (e) => {
        if (isSelecting) {
          updateSelectionBox(e);
          return;
        }

        // Multi-select group dragging
        if (multiSelectDragging) {
          const pointer = getCanvasPoint(e);
          const dx = pointer.x - multiSelectDragging.startPointer.x;
          const dy = pointer.y - multiSelectDragging.startPointer.y;
          multiSelectDragging.elements.forEach(({ el, startX, startY }) => {
            el.x = Math.round(startX + dx);
            el.y = Math.round(startY + dy);
            updateElementPosition(el);
          });
          // Update box position
          if (multiSelectBox) {
            multiSelectBox.style.left = (multiSelectDragging.startBounds.x + dx) + 'px';
            multiSelectBox.style.top = (multiSelectDragging.startBounds.y + dy) + 'px';
          }
          return;
        }

        // Multi-select group resizing - Canva-style proportional scaling
        if (multiSelectResizing) {
          const pointer = getCanvasPoint(e);
          const dx = pointer.x - multiSelectResizing.startPointer.x;
          const dy = pointer.y - multiSelectResizing.startPointer.y;
          const h = multiSelectResizing.handle;
          const b = multiSelectResizing.startBounds;
          
          // Calculate new bounds based on handle being dragged
          let newX = b.x, newY = b.y, newW = b.width, newH = b.height;
          
          // Corner handles - proportional by default
          const isCorner = ['nw', 'ne', 'sw', 'se'].includes(h);
          
          if (isCorner) {
            // Calculate aspect ratio for proportional scaling
            const aspectRatio = b.width / b.height;
            
            if (h === 'se') {
              // Southeast - scale from top-left anchor
              const delta = Math.max(dx, dy / aspectRatio * aspectRatio);
              newW = Math.max(50, b.width + delta);
              newH = Math.max(50, b.height + delta / aspectRatio);
            } else if (h === 'nw') {
              // Northwest - scale from bottom-right anchor
              const delta = Math.max(-dx, -dy / aspectRatio * aspectRatio);
              newW = Math.max(50, b.width + delta);
              newH = Math.max(50, b.height + delta / aspectRatio);
              newX = b.x + b.width - newW;
              newY = b.y + b.height - newH;
            } else if (h === 'ne') {
              // Northeast - scale from bottom-left anchor
              const delta = Math.max(dx, -dy / aspectRatio * aspectRatio);
              newW = Math.max(50, b.width + delta);
              newH = Math.max(50, b.height + delta / aspectRatio);
              newY = b.y + b.height - newH;
            } else if (h === 'sw') {
              // Southwest - scale from top-right anchor
              const delta = Math.max(-dx, dy / aspectRatio * aspectRatio);
              newW = Math.max(50, b.width + delta);
              newH = Math.max(50, b.height + delta / aspectRatio);
              newX = b.x + b.width - newW;
            }
          } else {
            // Edge handles - free scaling on one axis
            if (h === 'e') newW = Math.max(50, b.width + dx);
            if (h === 'w') { newW = Math.max(50, b.width - dx); newX = b.x + b.width - newW; }
            if (h === 's') newH = Math.max(50, b.height + dy);
            if (h === 'n') { newH = Math.max(50, b.height - dy); newY = b.y + b.height - newH; }
          }
          
          // Calculate scale factors from original bounds
          const scaleX = newW / b.width;
          const scaleY = newH / b.height;
          const uniformScale = Math.min(scaleX, scaleY);
          
          // Apply transformations to each element
          multiSelectResizing.elements.forEach(({ el, startX, startY, startW, startH, startFontSize }) => {
            // Scale position relative to new bounds origin
            const relX = (startX - b.x) / b.width;
            const relY = (startY - b.y) / b.height;
            
            el.x = Math.round(newX + relX * newW);
            el.y = Math.round(newY + relY * newH);
            el.width = Math.max(20, Math.round(startW * scaleX));
            el.height = Math.max(20, Math.round(startH * scaleY));
            
            // Scale font proportionally for text elements
            if (el.type === 'text' && startFontSize) {
              el.fontSize = Math.max(8, Math.round(startFontSize * uniformScale));
              // Update DOM immediately for live preview
              const div = document.getElementById(el.id);
              if (div) {
                const textContent = div.querySelector('.text-content');
                if (textContent) {
                  const fontSize = fitTextToContainer(el);
                  textContent.style.fontSize = fontSize + 'px';
                }
              }
            }
            
            updateElementPosition(el);
          });
          
          // Update bounding box
          if (multiSelectBox) {
            multiSelectBox.style.left = newX + 'px';
            multiSelectBox.style.top = newY + 'px';
            multiSelectBox.style.width = newW + 'px';
            multiSelectBox.style.height = newH + 'px';
          }
          return;
        }

        // Canvas resizing
        if (canvasResizing) {
          const dx = e.clientX - canvasResizing.startPointer.x;
          const dy = e.clientY - canvasResizing.startPointer.y;
          let newW = canvasResizing.startW;
          let newH = canvasResizing.startH;
          const h = canvasResizing.handle;
          if (h.includes('e')) newW = Math.max(MIN_CANVAS_SIZE, canvasResizing.startW + dx);
          if (h.includes('w')) newW = Math.max(MIN_CANVAS_SIZE, canvasResizing.startW - dx);
          if (h.includes('s')) newH = Math.max(MIN_CANVAS_SIZE, canvasResizing.startH + dy);
          if (h.includes('n')) newH = Math.max(MIN_CANVAS_SIZE, canvasResizing.startH - dy);

          const clampedW = clampCanvasDimension(newW);
          const clampedH = clampCanvasDimension(newH);

          const oldRect = canvas.getBoundingClientRect();
          canvas.style.width = clampedW + 'px';
          canvas.style.height = clampedH + 'px';
          syncCanvasSizeInputs(clampedW, clampedH);
          updateCanvasTransform();
          
          const newRect = canvas.getBoundingClientRect();
          keepCanvasViewStable(oldRect, newRect);
          centerCanvasInView();

          renderCanvasSelectionOverlay();
          renderElements();
          showElementProps();
          return;
        }

        // Canvas rotating
        if (canvasRotating) {
          const pointer = { x: e.clientX, y: e.clientY };
          const currentAngle = Math.atan2(pointer.y - canvasRotating.center.y, pointer.x - canvasRotating.center.x);
          let delta = (currentAngle - canvasRotating.startAngle) * (180 / Math.PI);
          let newRot = canvasRotating.startRotation + delta;
          // Snap to 15deg when Shift, otherwise 5deg threshold to common angles
          if (e.shiftKey) {
            newRot = Math.round(newRot / 15) * 15;
          } else {
            const snaps = [0, 45, 90, 135, 180, -45, -90, -135, -180];
            for (const s of snaps) {
              if (Math.abs(newRot - s) < 5) { newRot = s; break; }
            }
          }
          while (newRot > 180) newRot -= 360;
          while (newRot < -180) newRot += 360;
          canvasRotation = newRot;
          updateCanvasTransform();
          return;
        }

        clearGuides();

        const pointer = getCanvasPoint(e);

        // Handle rotation
        if (rotating) {
          const currentAngle = Math.atan2(pointer.y - rotating.centerY, pointer.x - rotating.centerX);
          let deltaAngle = (currentAngle - rotating.startAngle) * (180 / Math.PI);
          let newRotation = rotating.startRotation + deltaAngle;
          
          // Auto-snap to common angles (0, 45, 90, 135, 180, -45, -90, -135)
          const snapAngles = [0, 45, 90, 135, 180, -45, -90, -135, -180];
          const snapThreshold = e.shiftKey ? 0 : 5; // More precise with Shift
          
          // Snap to 15 degree increments when holding Shift
          if (e.shiftKey) {
            newRotation = Math.round(newRotation / 15) * 15;
          } else {
            // Auto-snap to common angles
            for (const snapAngle of snapAngles) {
              if (Math.abs(newRotation - snapAngle) < snapThreshold) {
                newRotation = snapAngle;
                break;
              }
            }
          }
          
          // Normalize to -180 to 180
          while (newRotation > 180) newRotation -= 360;
          while (newRotation < -180) newRotation += 360;
          
          rotating.el.rotation = Math.round(newRotation);
          updateElementPosition(rotating.el);
          showElementProps(); // Real-time update
          return;
        }

        if (dragging && dragging.elements.length > 0) {
          const dx = pointer.x - dragging.startPointer.x;
          const dy = pointer.y - dragging.startPointer.y;

          // Move all selected elements
          dragging.elements.forEach(({ el, startX, startY }) => {
            el.x = Math.round(startX + dx);
            el.y = Math.round(startY + dy);
          });

          // Smart snap logic for primary element
          if (dragging.elements.length >= 1) {
            const el = dragging.elements[0].el;
            const canvasW = parseInt(canvas.style.width);
            const canvasH = parseInt(canvas.style.height);
            const centerX = (canvasW - el.width) / 2;
            const centerY = (canvasH - el.height) / 2;
            const snapDist = 8;
            
            // Get other elements (not being dragged)
            const otherElements = elements.filter(other => !selectedIds.has(other.id));
            
            // Element edges
            const elLeft = el.x;
            const elRight = el.x + el.width;
            const elTop = el.y;
            const elBottom = el.y + el.height;
            const elCenterX = el.x + el.width / 2;
            const elCenterY = el.y + el.height / 2;

            let snappedH = false, snappedV = false;
            
            // Snap to canvas
            if (Math.abs(elCenterX - canvasW / 2) < snapDist) { el.x = centerX; snappedH = true; showGuide('vertical', canvasW / 2); }
            if (Math.abs(elLeft) < snapDist) { el.x = 0; snappedH = true; showGuide('vertical', 0); }
            if (Math.abs(elRight - canvasW) < snapDist) { el.x = canvasW - el.width; snappedH = true; showGuide('vertical', canvasW); }
            if (Math.abs(elCenterY - canvasH / 2) < snapDist) { el.y = centerY; snappedV = true; showGuide('horizontal', canvasH / 2); }
            if (Math.abs(elTop) < snapDist) { el.y = 0; snappedV = true; showGuide('horizontal', 0); }
            if (Math.abs(elBottom - canvasH) < snapDist) { el.y = canvasH - el.height; snappedV = true; showGuide('horizontal', canvasH); }
            
            // Snap to other elements
            for (const other of otherElements) {
              const otherLeft = other.x;
              const otherRight = other.x + other.width;
              const otherTop = other.y;
              const otherBottom = other.y + other.height;
              const otherCenterX = other.x + other.width / 2;
              const otherCenterY = other.y + other.height / 2;
              
              // Vertical alignments (X axis)
              if (!snappedH) {
                // Left to left
                if (Math.abs(elLeft - otherLeft) < snapDist) { el.x = otherLeft; snappedH = true; showGuide('vertical', otherLeft); }
                // Right to right
                else if (Math.abs(elRight - otherRight) < snapDist) { el.x = otherRight - el.width; snappedH = true; showGuide('vertical', otherRight); }
                // Center to center
                else if (Math.abs(elCenterX - otherCenterX) < snapDist) { el.x = otherCenterX - el.width / 2; snappedH = true; showGuide('vertical', otherCenterX); }
                // Left to right
                else if (Math.abs(elLeft - otherRight) < snapDist) { el.x = otherRight; snappedH = true; showGuide('vertical', otherRight); }
                // Right to left
                else if (Math.abs(elRight - otherLeft) < snapDist) { el.x = otherLeft - el.width; snappedH = true; showGuide('vertical', otherLeft); }
              }
              
              // Horizontal alignments (Y axis)
              if (!snappedV) {
                // Top to top
                if (Math.abs(elTop - otherTop) < snapDist) { el.y = otherTop; snappedV = true; showGuide('horizontal', otherTop); }
                // Bottom to bottom
                else if (Math.abs(elBottom - otherBottom) < snapDist) { el.y = otherBottom - el.height; snappedV = true; showGuide('horizontal', otherBottom); }
                // Center to center
                else if (Math.abs(elCenterY - otherCenterY) < snapDist) { el.y = otherCenterY - el.height / 2; snappedV = true; showGuide('horizontal', otherCenterY); }
                // Top to bottom
                else if (Math.abs(elTop - otherBottom) < snapDist) { el.y = otherBottom; snappedV = true; showGuide('horizontal', otherBottom); }
                // Bottom to top
                else if (Math.abs(elBottom - otherTop) < snapDist) { el.y = otherTop - el.height; snappedV = true; showGuide('horizontal', otherTop); }
              }
              
              if (snappedH && snappedV) break;
            }
          }

          // Update positions in DOM
          dragging.elements.forEach(({ el }) => updateElementPosition(el));
          showElementProps(); // Real-time update
        }

        // Canva-style single element resize
        if (resizing) {
          const dx = pointer.x - resizing.startPointer.x;
          const dy = pointer.y - resizing.startPointer.y;
          const h = resizing.handle;
          const isCorner = ['nw', 'ne', 'sw', 'se'].includes(h);
          const aspectRatio = resizing.startW / resizing.startH;
          
          let newW = resizing.startW;
          let newH = resizing.startH;
          let newX = resizing.startElX;
          let newY = resizing.startElY;
          
          if (isCorner) {
            // Corner handles - proportional scaling (Canva behavior)
            // Use the larger delta to determine scale
            let scale = 1;
            
            if (h === 'se') {
              // Scale based on diagonal movement
              const avgDelta = (dx + dy) / 2;
              newW = Math.max(30, resizing.startW + avgDelta);
              newH = Math.max(30, newW / aspectRatio);
            } else if (h === 'nw') {
              const avgDelta = (-dx + -dy) / 2;
              newW = Math.max(30, resizing.startW + avgDelta);
              newH = Math.max(30, newW / aspectRatio);
              newX = resizing.startElX + resizing.startW - newW;
              newY = resizing.startElY + resizing.startH - newH;
            } else if (h === 'ne') {
              const avgDelta = (dx + -dy) / 2;
              newW = Math.max(30, resizing.startW + avgDelta);
              newH = Math.max(30, newW / aspectRatio);
              newY = resizing.startElY + resizing.startH - newH;
            } else if (h === 'sw') {
              const avgDelta = (-dx + dy) / 2;
              newW = Math.max(30, resizing.startW + avgDelta);
              newH = Math.max(30, newW / aspectRatio);
              newX = resizing.startElX + resizing.startW - newW;
            }
          } else {
            // Edge handles - free scaling on one axis
            if (h === 'e') newW = Math.max(30, resizing.startW + dx);
            if (h === 'w') { newW = Math.max(30, resizing.startW - dx); newX = resizing.startElX + resizing.startW - newW; }
            if (h === 's') newH = Math.max(20, resizing.startH + dy);
            if (h === 'n') { newH = Math.max(20, resizing.startH - dy); newY = resizing.startElY + resizing.startH - newH; }
          }
          
          // QR always square
          if (resizing.el.type === 'qr') {
            const size = Math.max(newW, newH);
            if (isCorner) {
              newW = newH = size;
            }
          }
          
          // Scale font proportionally for text
          if (resizing.el.type === 'text') {
            const scale = Math.min(newW / resizing.startW, newH / resizing.startH);
            resizing.el.fontSize = Math.max(8, Math.round(resizing.startFontSize * scale));
          }
          
          resizing.el.width = Math.round(newW);
          resizing.el.height = Math.round(newH);
          resizing.el.x = Math.round(newX);
          resizing.el.y = Math.round(newY);
          
          updateElementPosition(resizing.el);
          
          // Live font update
          if (resizing.el.type === 'text') {
            const div = document.getElementById(resizing.el.id);
            if (div) {
              const textContent = div.querySelector('.text-content');
              if (textContent) {
                const fontSize = fitTextToContainer(resizing.el);
                textContent.style.fontSize = fontSize + 'px';
              }
            }
          }
          
          showElementProps();
        }
      };

      document.onmouseup = (e) => {
        if (isSelecting) {
          const startPoint = selectionStart?.page;
          const endPoint = lastSelectionPoint || (e ? { x: e.clientX, y: e.clientY } : null);
          isSelecting = false;
          if (selectionBox) selectionBox.style.display = 'none';
          if (wrapperSelectionBox) wrapperSelectionBox.style.display = 'none';
          
          if (startPoint && endPoint) {
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const distance = Math.hypot(dx, dy);
            
            if (distance < 6) {
              // Short click - just tap
              if (selectionStartedOnCanvas) {
                // Clicked on canvas background - select canvas
                selectedIds.clear();
                refreshSelectionStyles();
                removeMultiSelectBox();
                highlightCanvasSelection();
              } else if (selectionStartedOnWrapper) {
                // Clicked on wrapper (outside canvas) - clear all
                selectedIds.clear();
                refreshSelectionStyles();
                removeMultiSelectBox();
              }
            }
          }
          
          selectionStartedOnWrapper = false;
          selectionStartedOnCanvas = false;
          selectionStart = null;
          lastSelectionPoint = null;
          showElementProps();
        }

        if (dragging || resizing || rotating) {
          // Don't call renderElements - just update handles if needed
          if (selectedIds.size > 0) {
            renderElements();
          }
        }

        // Multi-select drag/resize end
        if (multiSelectDragging || multiSelectResizing) {
          multiSelectDragging = null;
          multiSelectResizing = null;
          updateMultiSelectBox();
          renderElements();
        }

        if (canvasResizing || canvasRotating) {
          if (canvasResizing) {
            saveToHistory();
            showElementProps();
          }
          canvasResizing = null;
          canvasRotating = null;
          renderCanvasSelectionOverlay();
        }

        clearGuides();
        dragging = null;
        resizing = null;
        rotating = null;
      };
    }

    // Update element position (fast, no re-render)
    function updateElementPosition(el) {
      const div = document.getElementById(el.id);
      if (div) {
        div.style.left = el.x + 'px';
        div.style.top = el.y + 'px';
        div.style.width = el.width + 'px';
        div.style.height = el.height + 'px';
        setElementRotation(div, el);
      }
    }

    // Center all elements in the canvas
    function centerAllElements() {
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      
      elements.forEach(el => {
        el.x = (canvasW - el.width) / 2;
        el.y = (canvasH - el.height) / 2;
      });
    }

    // Zoom canvas - Canva style
    function zoomCanvas(delta, e = null) {
      // If the user manually zooms, don't let auto-fit shrink it back.
      viewportZoomMode = 'manual';
      const oldZoom = canvasZoom;
      
      if (delta === 0) {
        canvasZoom = 100;
      } else {
        canvasZoom = Math.max(10, Math.min(400, canvasZoom + delta));
      }
      updateCanvasTransform();
      centerCanvasInView();
      updateZoomLabels();
    }
    
    // Auto-fit canvas to viewport - ensures canvas is visible without overflow
    function autoFitCanvasToViewport(forceApply = false) {
      const canvasEl = document.getElementById('canvas');
      const wrapperEl = document.getElementById('canvas-wrapper');
      if (!canvasEl || !wrapperEl) return;

      // If user manually zoomed, don't auto-fit unless forced.
      if (!forceApply && typeof viewportZoomMode !== 'undefined' && viewportZoomMode === 'manual') return;
      if (forceApply && typeof viewportZoomMode !== 'undefined') viewportZoomMode = 'auto';
      
      const canvasW = parseInt(canvasEl.style.width) || 400;
      const canvasH = parseInt(canvasEl.style.height) || 400;
      
      // Get available space with padding
      const padding = window.innerWidth <= 480 ? 24 : window.innerWidth <= 750 ? 32 : 80;
      const availableW = wrapperEl.clientWidth - padding * 2;
      const availableH = (wrapperEl.clientHeight - getBottomOverlayInset()) - padding * 2;
      
      if (availableW <= 0 || availableH <= 0) return;
      
      // Calculate zoom to fit
      const scaleX = availableW / canvasW;
      const scaleY = availableH / canvasH;
      let fitZoom = Math.min(scaleX, scaleY) * 100;
      // Clamp; keep fractional for smooth updates
      fitZoom = Math.max(10, Math.min(400, fitZoom));
      
      // Only adjust if canvas would overflow or is much smaller than available space
      const currentScale = canvasZoom / 100;
      const scaledW = canvasW * currentScale;
      const scaledH = canvasH * currentScale;
      
      const isOverflowing = scaledW > availableW || scaledH > availableH;
      const isTooSmall = scaledW < availableW * 0.3 && scaledH < availableH * 0.3;
      
      if (forceApply || isOverflowing || isTooSmall) {
        canvasZoom = fitZoom;
        updateCanvasTransform();
        updateZoomLabels();
        centerCanvasInView();
      }
    }

    // Real-time viewport fitting (smooth) using requestAnimationFrame
    let viewportUpdateRaf = null;
    let viewportForceFit = false;
    let viewportZoomMode = 'auto'; // 'auto' | 'manual'

    function updateZoomLabels() {
      const text = Math.round(canvasZoom || 100) + '%';
      document.querySelectorAll('#zoom-value, #zoom-value-mobile').forEach(el => {
        el.textContent = text;
      });

      const slider = document.getElementById('zoom-slider-mobile');
      if (slider) slider.value = String(Math.round(canvasZoom || 100));
      const sliderLabel = document.getElementById('zoom-slider-value-mobile');
      if (sliderLabel) sliderLabel.textContent = text;
    }

    function setupMobileZoomSlider() {
      const slider = document.getElementById('zoom-slider-mobile');
      if (!slider) return;
      slider.addEventListener('input', () => {
        viewportZoomMode = 'manual';
        const next = Number(slider.value);
        if (!Number.isFinite(next)) return;
        canvasZoom = Math.max(10, Math.min(400, next));
        updateCanvasTransform();
        centerCanvasInView();
        updateToolbarPosition();
        renderCanvasSelectionOverlay();
        updateZoomLabels();
      });
    }

    function fitViewport() {
      viewportZoomMode = 'auto';
      scheduleViewportUpdate(true);
    }

    function computeFitZoomTarget() {
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      const padding = window.innerWidth <= 480 ? 24 : window.innerWidth <= 750 ? 32 : 80;
      const availableW = canvasWrapper.clientWidth - padding * 2;
      const availableH = (canvasWrapper.clientHeight - getBottomOverlayInset()) - padding * 2;
      if (availableW <= 0 || availableH <= 0) return null;
      const scaleX = availableW / canvasW;
      const scaleY = availableH / canvasH;
      const targetZoom = Math.max(10, Math.min(400, Math.min(scaleX, scaleY) * 100));
      return { targetZoom, availableW, availableH, canvasW, canvasH };
    }

    function scheduleViewportUpdate(forceFit = false) {
      if (forceFit) viewportZoomMode = 'auto';
      viewportForceFit = viewportForceFit || forceFit;
      if (viewportUpdateRaf) return;
      viewportUpdateRaf = requestAnimationFrame(runViewportUpdate);
    }

    function runViewportUpdate() {
      viewportUpdateRaf = null;
      const info = computeFitZoomTarget();
      if (!info) return;

      const { targetZoom, availableW, availableH, canvasW, canvasH } = info;
      const currentScale = canvasZoom / 100;
      const scaledW = canvasW * currentScale;
      const scaledH = canvasH * currentScale;
      const isOverflowing = scaledW > availableW || scaledH > availableH;
      const isTooSmall = scaledW < availableW * 0.3 && scaledH < availableH * 0.3;
      const shouldFit = viewportForceFit || (viewportZoomMode === 'auto' && (isOverflowing || isTooSmall));

      if (shouldFit) {
        const alpha = viewportForceFit ? 0.55 : 0.35;
        const nextZoom = Math.max(10, Math.min(400, canvasZoom + (targetZoom - canvasZoom) * alpha));
        if (Math.abs(nextZoom - canvasZoom) > 0.02) {
          canvasZoom = nextZoom;
          updateCanvasTransform();
          updateZoomLabels();
        }
      }

      centerCanvasInView();
      updateToolbarPosition();
      renderCanvasSelectionOverlay();

      if (shouldFit && Math.abs(targetZoom - canvasZoom) > 0.25) {
        viewportUpdateRaf = requestAnimationFrame(runViewportUpdate);
      } else {
        viewportForceFit = false;
      }
    }
    
    // Debounce function for resize events
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    
    // Setup scroll wheel zoom like Canva
    function setupScrollZoom() {
      let pendingDelta = 0;
      let rafId = 0;
      let lastEvent = null;

      const scheduleApply = () => {
        if (rafId) return;
        rafId = requestAnimationFrame(() => {
          rafId = 0;
          const d = pendingDelta;
          pendingDelta = 0;
          if (!d) return;
          zoomCanvas(d, lastEvent || undefined);
        });
      };

      canvasWrapper.addEventListener('wheel', (e) => {
        // Trackpad pinch-to-zoom usually comes as wheel + ctrlKey in Chromium.
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          lastEvent = e;

          const abs = Math.abs(e.deltaY);
          // Adaptive steps: trackpad/pinch sends small deltas frequently; don't jump 10% each tick.
          let step;
          if (abs < 8) step = 0.5;
          else if (abs < 16) step = 1;
          else if (abs < 40) step = 2;
          else if (abs < 100) step = 4;
          else step = 8;

          const delta = e.deltaY > 0 ? -step : step;
          pendingDelta += delta;
          // Clamp burst so a fast swipe doesn't overshoot wildly.
          pendingDelta = Math.max(-30, Math.min(30, pendingDelta));
          scheduleApply();
        }
      }, { passive: false });
    }

    // ===== LOCATION PICKER (Leaflet) =====
    let locationPickerMap = null;
    let locationPickerMarker = null;
    let locationPickerSelected = null; // {lat, lng}

    let locationPickerTileLayer = null;
    let locationPickerTileSourceIndex = 0;
    let locationPickerTileChecked = false;
    let locationPickerTileErrors = 0;
    let locationPickerInvalidateTimer = null;
    let locationPickerLocalTilesAvailable = null; // null = unknown, boolean once checked
    let locationPickerLocalTilesZoomMax = null;

    const locationPickerTileSources = [
      {
        id: 'carto_light_all',
        name: 'CARTO (khuyến nghị)',
        kind: 'xyz',
        url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
        subdomains: 'abcd',
        maxZoom: 19,
        attribution: '',
      },
      {
        id: 'local_mbtiles',
        name: 'Local MBTiles',
        kind: 'xyz',
        url: '/tiles/{z}/{x}/{y}.png',
        maxZoom: 20,
        attribution: '',
      },
      {
        id: 'neutral_grid',
        name: 'Neutral Grid',
        kind: 'grid',
        maxZoom: 20,
        attribution: '',
      },
    ];

    function locationPickerGetCenterFromInputs() {
      const latInput = document.getElementById('loc-lat');
      const lngInput = document.getElementById('loc-lng');
      const initialLat = latInput && latInput.value ? parseFloat(latInput.value) : 21.0285;
      const initialLng = lngInput && lngInput.value ? parseFloat(lngInput.value) : 105.8542;
      const lat = isFinite(initialLat) ? initialLat : 21.0285;
      const lng = isFinite(initialLng) ? initialLng : 105.8542;
      return [lat, lng];
    }

    function locationPickerToast(msg) {
      if (typeof showToast === 'function') showToast(msg);
      else console.log('[LocationPicker]', msg);
    }

    async function locationPickerDetectLocalTiles() {
      if (locationPickerLocalTilesAvailable !== null) return locationPickerLocalTilesAvailable;
      try {
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), 1200);
        const res = await fetch('/tiles/status', { cache: 'no-store', signal: ctrl.signal });
        clearTimeout(t);
        if (!res.ok) {
          locationPickerLocalTilesAvailable = false;
          return false;
        }
        const info = await res.json();
        locationPickerLocalTilesAvailable = !!(info && info.found && info.is_raster);
        locationPickerLocalTilesZoomMax = (info && Number.isFinite(info.max_zoom)) ? info.max_zoom : null;

        // If we know the dataset's max native zoom, tell Leaflet to upscale beyond it.
        // This avoids 404s when the user zooms in but the MBTiles doesn't contain high zoom levels.
        if (locationPickerLocalTilesAvailable && Number.isFinite(locationPickerLocalTilesZoomMax)) {
          const src = (locationPickerTileSources || []).find(s => s && s.id === 'local_mbtiles');
          if (src) {
            src.maxNativeZoom = locationPickerLocalTilesZoomMax;
            // Keep maxZoom high so Leaflet can zoom further (it will scale tiles at maxNativeZoom).
            src.maxZoom = Math.max(src.maxZoom || 20, locationPickerLocalTilesZoomMax);
          }
        }
        return locationPickerLocalTilesAvailable;
      } catch {
        locationPickerLocalTilesAvailable = false;
        return false;
      }
    }

    function nextAnimationFrame() {
      return new Promise(resolve => requestAnimationFrame(() => resolve()));
    }

    async function waitForElementNonZeroSize(el, maxFrames = 60) {
      if (!el) return false;
      for (let i = 0; i < maxFrames; i++) {
        const w = el.clientWidth;
        const h = el.clientHeight;
        if (w > 0 && h > 0) return true;
        await nextAnimationFrame();
      }
      return el.clientWidth > 0 && el.clientHeight > 0;
    }

    function testImageUrl(url, timeoutMs = 2500) {
      return new Promise(resolve => {
        const img = new Image();
        let done = false;
        const finish = (ok) => {
          if (done) return;
          done = true;
          clearTimeout(timer);
          img.onload = null;
          img.onerror = null;
          resolve(ok);
        };
        const timer = setTimeout(() => finish(false), timeoutMs);
        img.referrerPolicy = 'no-referrer';
        img.onload = () => finish(true);
        img.onerror = () => finish(false);
        img.src = url + (url.includes('?') ? '&' : '?') + 't=' + Date.now();
      });
    }

    function locationPickerGetActiveTileSource() {
      const idx = Math.max(0, Math.min(locationPickerTileSources.length - 1, locationPickerTileSourceIndex));
      return locationPickerTileSources[idx];
    }

    function locationPickerBuildTileLayer(source) {
      if (!source) return null;

      if (source.kind === 'composite') {
        const layers = Array.isArray(source.layers) ? source.layers : [];
        const built = layers.map(layerSpec => {
          if (!layerSpec) return null;
          const opts = {
            maxZoom: layerSpec.maxZoom || source.maxZoom || 19,
            attribution: layerSpec.attribution || source.attribution || '',
            crossOrigin: false,
          };
          if (layerSpec.pane) opts.pane = layerSpec.pane;
          if (Number.isFinite(layerSpec.maxNativeZoom)) opts.maxNativeZoom = layerSpec.maxNativeZoom;
          if (layerSpec.subdomains) opts.subdomains = layerSpec.subdomains;
          return L.tileLayer(layerSpec.url, opts);
        }).filter(Boolean);

        return L.layerGroup(built);
      }

      if (source.kind === 'grid') {
        const layer = L.gridLayer({
          maxZoom: source.maxZoom || 20,
          attribution: source.attribution || '',
          tileSize: 256,
        });

        layer.createTile = (coords) => {
          const tile = document.createElement('canvas');
          tile.width = 256;
          tile.height = 256;
          const ctx = tile.getContext('2d');
          if (!ctx) return tile;

          // Background
          ctx.fillStyle = '#1e1e2e';
          ctx.fillRect(0, 0, 256, 256);

          // Grid lines
          ctx.strokeStyle = 'rgba(148, 163, 184, 0.18)';
          ctx.lineWidth = 1;
          for (let i = 0; i <= 256; i += 32) {
            ctx.beginPath();
            ctx.moveTo(i + 0.5, 0);
            ctx.lineTo(i + 0.5, 256);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, i + 0.5);
            ctx.lineTo(256, i + 0.5);
            ctx.stroke();
          }

          // Border
          ctx.strokeStyle = 'rgba(148, 163, 184, 0.28)';
          ctx.strokeRect(0.5, 0.5, 255, 255);

          // Tile label (no external data, no boundaries)
          ctx.fillStyle = 'rgba(148, 163, 184, 0.85)';
          ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
          ctx.fillText(`z:${coords.z} x:${coords.x} y:${coords.y}`, 10, 20);

          return tile;
        };

        return layer;
      }

      // Default: URL tile layer (e.g. local MBTiles server)
      const opts = {
        maxZoom: source.maxZoom || 19,
        attribution: source.attribution || '',
        crossOrigin: false,
      };
      if (Number.isFinite(source.maxNativeZoom)) opts.maxNativeZoom = source.maxNativeZoom;
      if (source.subdomains) opts.subdomains = source.subdomains;
      return L.tileLayer(source.url, opts);
    }

    function locationPickerApplyTileSource(index, reason = '') {
      if (!locationPickerMap || !window.L) return;
      const nextIndex = Math.max(0, Math.min(locationPickerTileSources.length - 1, index));
      locationPickerTileSourceIndex = nextIndex;
      locationPickerTileErrors = 0;
      const src = locationPickerGetActiveTileSource();

      if (locationPickerTileLayer && locationPickerMap.hasLayer(locationPickerTileLayer)) {
        locationPickerMap.removeLayer(locationPickerTileLayer);
      }
      locationPickerTileLayer = locationPickerBuildTileLayer(src);
      locationPickerTileLayer.addTo(locationPickerMap);

      // Track errors and auto-switch when blocked (only meaningful for URL tile sources)
      const onTileError = () => {
        locationPickerTileErrors += 1;
        if (locationPickerTileErrors >= 3) {
          locationPickerSwitchToNextTileSource('tileerror');
        }
      };

      if (locationPickerTileLayer) {
        if (typeof locationPickerTileLayer.on === 'function') {
          locationPickerTileLayer.on('tileerror', onTileError);
        } else if (typeof locationPickerTileLayer.eachLayer === 'function') {
          locationPickerTileLayer.eachLayer((l) => {
            if (l && typeof l.on === 'function') l.on('tileerror', onTileError);
          });
        }
      }

      // Avoid noisy toast on init when using the neutral grid (single-source offline mode)
      const isSingleSource = locationPickerTileSources.length <= 1;
      const isInit = reason === 'init';
      if (!(isSingleSource && isInit)) {
        const msg = reason ? `Đã chuyển tile: ${src.name} (${reason})` : `Đã chuyển tile: ${src.name}`;
        locationPickerToast(msg);
      }
    }

    function locationPickerSwitchToNextTileSource(trigger = '') {
      if (!locationPickerMap) return;
      const next = locationPickerTileSourceIndex + 1;
      if (next >= locationPickerTileSources.length) {
        locationPickerToast('Không tải được tile local. Đang dùng lưới (offline).');
        return;
      }
      const reason = trigger ? `fallback: ${trigger}` : 'fallback';
      locationPickerApplyTileSource(next, reason);
      invalidateLocationPickerMapSizeSoon();
    }

    async function verifyLocationPickerTilesOnce() {
      if (locationPickerTileChecked) return;
      locationPickerTileChecked = true;
      // If this URL can't be reached, the active tile endpoint is likely blocked by network/adblock.
      const src = locationPickerGetActiveTileSource();
      const testUrl = src && src.testUrl ? src.testUrl : null;
      if (!testUrl) return;
      const ok = await testImageUrl(testUrl, 2500);
      if (!ok) {
        locationPickerSwitchToNextTileSource('connectivity');
      }
    }

    function invalidateLocationPickerMapSizeSoon() {
      if (!locationPickerMap) return;
      if (locationPickerInvalidateTimer) {
        clearTimeout(locationPickerInvalidateTimer);
        locationPickerInvalidateTimer = null;
      }

      // 1) Double-rAF: ensures layout has been calculated after display:none -> flex.
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (!locationPickerMap) return;
          locationPickerMap.invalidateSize(true);
        });
      });

      // 2) If modal animates (opacity/transform), size may stabilize only after transition ends.
      const overlay = document.getElementById('location-picker-modal');
      const modal = overlay ? overlay.querySelector('.modal') : null;
      if (modal) {
        const onEnd = (ev) => {
          if (!locationPickerMap) return;
          // Only respond to the modal's own transition end.
          if (ev && ev.target !== modal) return;
          locationPickerMap.invalidateSize(true);
        };
        modal.addEventListener('transitionend', onEnd, { once: true });
      }

      // 3) Fallback timer for animations that don't fire transitionend (or are interrupted).
      locationPickerInvalidateTimer = setTimeout(() => {
        if (!locationPickerMap) return;
        locationPickerMap.invalidateSize(true);
      }, 350);
    }

    async function ensureLocationPickerMapInitialized(center) {
      if (!window.L) {
        locationPickerToast('Leaflet chưa tải xong. Vui lòng thử lại sau 1-2 giây.');
        return false;
      }

      const mapEl = document.getElementById('location-map');
      if (!mapEl) {
        locationPickerToast('Không tìm thấy #location-map');
        return false;
      }

      // Wait until the modal is visible and the map container has a real size.
      // This prevents Leaflet from initializing with width/height = 0.
      const sized = await waitForElementNonZeroSize(mapEl, 90);
      if (!sized) {
        // Emergency: ensure a non-zero height to avoid a white map.
        // Prefer CSS; this is a last-resort safety net.
        if (!mapEl.style.height) mapEl.style.height = '320px';
        await nextAnimationFrame();
      }

      if (!locationPickerMap) {
        // Use an inline SVG marker so it never breaks due to missing Leaflet default icon images.
        const locationPickerMarkerIcon = L.divIcon({
          className: 'qrio-leaflet-marker',
          html: `
            <svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true">
              <path d="M16 31s10-9.2 10-17A10 10 0 0 0 6 14c0 7.8 10 17 10 17z" fill="#7c3aed"/>
              <circle cx="16" cy="14" r="4.2" fill="#ffffff" fill-opacity="0.95"/>
              <circle cx="16" cy="14" r="2.4" fill="#1e1e2e" fill-opacity="0.25"/>
            </svg>`,
          iconSize: [32, 32],
          iconAnchor: [16, 31],
          popupAnchor: [0, -28],
        });

        const hasLocalTiles = await locationPickerDetectLocalTiles();
        // Prefer external tiles on production (user request). If they fail, Leaflet tileerror fallback will switch.
        // If no local mbtiles, fallback chain is: CARTO -> Local MBTiles (if any) -> Neutral Grid.
        const preferredIndex = 0;
        const initialZoom = (hasLocalTiles && Number.isFinite(locationPickerLocalTilesZoomMax))
          ? Math.min(13, locationPickerLocalTilesZoomMax)
          : 13;

        locationPickerMap = L.map('location-map', {
          center,
          zoom: initialZoom,
          zoomControl: true,
        });

        // Tiles: prefer external basemap, fall back to local MBTiles, then neutral grid.
        locationPickerTileSourceIndex = preferredIndex;
        locationPickerApplyTileSource(locationPickerTileSourceIndex, 'init');

        if (!hasLocalTiles) {
          // Keep message subtle; external tiles should work on production.
          // If external tiles are blocked by network/CSP, fallback logic will switch.
        }

        locationPickerMarker = L.marker(center, { draggable: true, icon: locationPickerMarkerIcon }).addTo(locationPickerMap);
        locationPickerSelected = { lat: center[0], lng: center[1] };
        updateLocationPickerCoordsLabel(locationPickerSelected.lat, locationPickerSelected.lng);

        locationPickerMap.on('click', (ev) => {
          const latlng = ev.latlng;
          setLocationPickerSelection(latlng.lat, latlng.lng, true);
        });

        locationPickerMarker.on('dragend', () => {
          const pos = locationPickerMarker.getLatLng();
          setLocationPickerSelection(pos.lat, pos.lng, false);
        });
      }

      // Recenter + marker each open
      if (locationPickerMap) {
        locationPickerMap.setView(center, locationPickerMap.getZoom() || 13, { animate: false });
      }
      if (locationPickerMarker) {
        locationPickerMarker.setLatLng(center);
      }
      locationPickerSelected = { lat: center[0], lng: center[1] };
      updateLocationPickerCoordsLabel(locationPickerSelected.lat, locationPickerSelected.lng);

      // Kick off a one-time connectivity check in background.
      // If primary endpoint is blocked, auto-switch to fallback.
      verifyLocationPickerTilesOnce();

      return true;
    }

    async function openLocationPickerModal() {
      const overlay = document.getElementById('location-picker-modal');
      if (!overlay) return;

      // Show modal first, then wait for layout.
      overlay.style.display = 'flex';

      // Allow the browser to apply styles/layout, including any opening animation.
      await nextAnimationFrame();
      await nextAnimationFrame();

      const center = locationPickerGetCenterFromInputs();
      const ok = await ensureLocationPickerMapInitialized(center);
      if (!ok) return;

      // Invalidate size at the correct time(s) so Leaflet re-measures container.
      invalidateLocationPickerMapSizeSoon();
    }

    function closeLocationPickerModal() {
      const modal = document.getElementById('location-picker-modal');
      if (!modal) return;
      if (locationPickerInvalidateTimer) {
        clearTimeout(locationPickerInvalidateTimer);
        locationPickerInvalidateTimer = null;
      }
      modal.style.display = 'none';
    }

    function updateLocationPickerCoordsLabel(lat, lng) {
      const el = document.getElementById('location-picker-coords');
      if (!el) return;
      el.textContent = `Đã chọn: ${lat.toFixed(6)}, ${lng.toFixed(6)}`;
    }

    function setLocationPickerSelection(lat, lng, pan = true) {
      if (!isFinite(lat) || !isFinite(lng)) return;
      locationPickerSelected = { lat, lng };
      if (locationPickerMarker) locationPickerMarker.setLatLng([lat, lng]);
      if (pan && locationPickerMap) locationPickerMap.panTo([lat, lng]);
      updateLocationPickerCoordsLabel(lat, lng);
    }

    function confirmLocationFromMap() {
      if (!locationPickerSelected) return;
      const latInput = document.getElementById('loc-lat');
      const lngInput = document.getElementById('loc-lng');
      if (latInput) latInput.value = locationPickerSelected.lat.toFixed(6);
      if (lngInput) lngInput.value = locationPickerSelected.lng.toFixed(6);

      // Regenerate QR immediately
      if (typeof generateQR === 'function') generateQR();
      if (typeof showToast === 'function') showToast('Đã chọn vị trí');
      closeLocationPickerModal();
    }

    // Update canvas background
    function updateCanvasBg(color = null, commit = false) {
      const val = color || (document.getElementById('canvas-bg')?.value) || '#ffffff';
      canvas.style.backgroundColor = val;
      const propBg = document.getElementById('prop-canvas-bg');
      if (propBg) propBg.value = val;
      if (commit) saveToHistory();
      showElementProps();
    }

    // Update canvas size - elements stay at their absolute position
    function updateCanvasSize() {
      saveToHistory();
      const widthInput = document.getElementById('canvas-width');
      const heightInput = document.getElementById('canvas-height');
      let newW = widthInput ? parseInt(widthInput.value) || 400 : 400;
      let newH = heightInput ? parseInt(heightInput.value) || 400 : 400;
      newW = clampCanvasDimension(newW);
      newH = clampCanvasDimension(newH);
      syncCanvasSizeInputs(newW, newH);
      
      canvas.style.width = newW + 'px';
      canvas.style.height = newH + 'px';
      updateCanvasTransform();
      renderElements();
      centerCanvasInView();
      updateToolbarPosition();
      showElementProps();
    }

    // Align selected element(s)
    function alignSelected(align) {
      if (selectedIds.size === 0) return;

      const canvasW = parseInt(canvas.style.width);
      const canvasH = parseInt(canvas.style.height);

      selectedIds.forEach(id => {
        const el = elements.find(e => e.id === id);
        if (!el) return;

        switch (align) {
          case 'left': el.x = 0; break;
          case 'right': el.x = canvasW - el.width; break;
          case 'center-h': el.x = (canvasW - el.width) / 2; break;
          case 'top': el.y = 0; break;
          case 'bottom': el.y = canvasH - el.height; break;
          case 'center-v': el.y = (canvasH - el.height) / 2; break;
        }
      });

      renderElements();
    }

    // Export state
    let exportFormat = 'png';
    let exportScale = 2;
    let exportQuality = 92;
    let exportRadius = 8;
    let exportSizeMode = 'scale'; // 'scale' or 'custom'
    let exportCustomWidth = 800;
    let exportCustomHeight = 800;
    let exportLockRatio = true;
    let exportAspectRatio = 1;
    
    // Open export modal
    function downloadImage() {
      openExportModal();
    }
    
    function openExportModal() {
      const modal = document.getElementById('export-modal');
      modal.style.display = 'flex';
      
      // Get canvas size and set initial custom sizes
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      exportAspectRatio = canvasW / canvasH;
      exportCustomWidth = canvasW * exportScale;
      exportCustomHeight = canvasH * exportScale;
      document.getElementById('export-width').value = exportCustomWidth;
      document.getElementById('export-height').value = exportCustomHeight;
      
      // Setup format pills
      document.querySelectorAll('#format-pills .pill').forEach(pill => {
        pill.onclick = () => {
          document.querySelectorAll('#format-pills .pill').forEach(p => p.classList.remove('active'));
          pill.classList.add('active');
          exportFormat = pill.dataset.format;
          // Show/hide quality slider based on format
          const qualityGroup = document.getElementById('quality-group');
          qualityGroup.style.display = (exportFormat === 'jpg') ? 'block' : 'none';
          updateExportPreview();
        };
      });
      
      // Initial quality visibility
      document.getElementById('quality-group').style.display = (exportFormat === 'jpg') ? 'block' : 'none';
      
      // Setup size pills
      document.querySelectorAll('#size-pills .pill').forEach(pill => {
        pill.onclick = () => {
          document.querySelectorAll('#size-pills .pill').forEach(p => p.classList.remove('active'));
          pill.classList.add('active');
          exportScale = parseInt(pill.dataset.scale);
          updateExportPreview();
        };
      });
      
      // Quality slider
      const qualitySlider = document.getElementById('export-quality');
      const qualityLabel = document.getElementById('quality-label');
      qualitySlider.oninput = () => {
        exportQuality = parseInt(qualitySlider.value);
        qualityLabel.textContent = exportQuality + '%';
      };
      
      // Radius slider
      const radiusSlider = document.getElementById('export-radius');
      const radiusLabel = document.getElementById('radius-label');
      radiusSlider.oninput = () => {
        exportRadius = parseInt(radiusSlider.value);
        radiusLabel.textContent = exportRadius + 'px';
        updateExportPreview();
      };
      
      updateExportPreview();
    }
    
    function setSizeMode(mode) {
      exportSizeMode = mode;
      document.getElementById('size-mode-scale').classList.toggle('active', mode === 'scale');
      document.getElementById('size-mode-custom').classList.toggle('active', mode === 'custom');
      document.getElementById('scale-options').style.display = mode === 'scale' ? 'block' : 'none';
      document.getElementById('custom-size-options').style.display = mode === 'custom' ? 'block' : 'none';
      
      if (mode === 'custom') {
        const canvasEl = document.getElementById('canvas');
        const canvasW = parseInt(canvasEl.style.width);
        const canvasH = parseInt(canvasEl.style.height);
        exportCustomWidth = canvasW * exportScale;
        exportCustomHeight = canvasH * exportScale;
        document.getElementById('export-width').value = exportCustomWidth;
        document.getElementById('export-height').value = exportCustomHeight;
      }
      
      updateExportPreview();
    }
    
    function updateExportSize() {
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      const widthInput = document.getElementById('export-width');
      const heightInput = document.getElementById('export-height');
      
      exportCustomWidth = parseInt(widthInput.value) || canvasW;
      exportCustomHeight = parseInt(heightInput.value) || canvasH;
      
      // Clamp values
      exportCustomWidth = Math.min(4096, Math.max(100, exportCustomWidth));
      exportCustomHeight = Math.min(4096, Math.max(100, exportCustomHeight));
      
      widthInput.value = exportCustomWidth;
      heightInput.value = exportCustomHeight;
      
      updateExportPreview();
    }
    
    function toggleLockRatio() {
      exportLockRatio = !exportLockRatio;
      const btn = document.getElementById('lock-ratio-btn');
      btn.innerHTML = exportLockRatio ? '<i class="fa-solid fa-lock"></i>' : '<i class="fa-solid fa-lock-open"></i>';
      btn.classList.toggle('active', exportLockRatio);
      
      if (exportLockRatio) {
        const canvasEl = document.getElementById('canvas');
        const canvasW = parseInt(canvasEl.style.width);
        const canvasH = parseInt(canvasEl.style.height);
        exportAspectRatio = canvasW / canvasH;
      }
    }
    
    // Update height when width changes (if locked)
    document.addEventListener('DOMContentLoaded', () => {
      const widthInput = document.getElementById('export-width');
      const heightInput = document.getElementById('export-height');
      
      if (widthInput) {
        widthInput.addEventListener('input', () => {
          if (exportLockRatio) {
            const w = parseInt(widthInput.value) || 800;
            heightInput.value = Math.round(w / exportAspectRatio);
          }
        });
      }
      
      if (heightInput) {
        heightInput.addEventListener('input', () => {
          if (exportLockRatio) {
            const h = parseInt(heightInput.value) || 800;
            widthInput.value = Math.round(h * exportAspectRatio);
          }
        });
      }
    });
    
    function closeExportModal() {
      document.getElementById('export-modal').style.display = 'none';
    }
    
    function getExportDimensions() {
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      
      if (exportSizeMode === 'custom') {
        return { width: exportCustomWidth, height: exportCustomHeight };
      } else {
        return { width: canvasW * exportScale, height: canvasH * exportScale };
      }
    }
    
    function updateExportPreview() {
      const previewCanvas = document.getElementById('export-preview-canvas');
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      
      previewCanvas.width = canvasW;
      previewCanvas.height = canvasH;
      const ctx = previewCanvas.getContext('2d');
      
      // Draw with rounded corners
      ctx.save();
      if (exportRadius > 0) {
        ctx.beginPath();
        ctx.roundRect(0, 0, canvasW, canvasH, exportRadius);
        ctx.clip();
      }
      
      // Background
      ctx.fillStyle = canvasEl.style.backgroundColor || '#fff';
      ctx.fillRect(0, 0, canvasW, canvasH);
      
      // Draw elements
      drawElementsToContext(ctx, 1);
      ctx.restore();
      
      // Update size info
      const dims = getExportDimensions();
      const sizeInfo = document.getElementById('export-size-info');
      const fileSizeEstimate = Math.round((dims.width * dims.height * 4) / 1024);
      sizeInfo.textContent = `${dims.width} × ${dims.height} px (~${fileSizeEstimate > 1024 ? (fileSizeEstimate/1024).toFixed(1) + ' MB' : fileSizeEstimate + ' KB'})`;
    }
    
    function drawElementsToContext(ctx, scale) {
      for (const el of elements) {
        const angle = (normalizeRotation(el.rotation) * Math.PI) / 180;
        const opacity = el.opacity !== undefined ? el.opacity / 100 : 1;
        const flipX = el && el.flipX ? -1 : 1;
        const flipY = el && el.flipY ? -1 : 1;
        
        if (el.type === 'qr') {
          const baseImg = document.querySelector(`#${el.id} img.qr-base`) || document.querySelector(`#${el.id} .qr-content img`);
          if (baseImg) {
            ctx.save();
            ctx.globalAlpha = opacity;
            const centerX = el.x + el.width / 2;
            const centerY = el.y + el.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(angle);
            ctx.scale(flipX, flipY);
            ctx.drawImage(baseImg, -el.width / 2, -el.height / 2, el.width, el.height);
            ctx.restore();
          }
        } else if (el.type === 'text') {
          ctx.save();
          ctx.globalAlpha = opacity;
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          ctx.scale(flipX, flipY);
          
          if (el.bgColor) {
            ctx.fillStyle = el.bgColor;
            ctx.fillRect(-el.width / 2, -el.height / 2, el.width, el.height);
          }
          
          const fontFamily = el.fontFamily || 'Be Vietnam Pro';
          const fontWeight = el.bold ? 'bold' : 'normal';
          const fontStyle = el.italic ? 'italic' : 'normal';
          ctx.font = `${fontStyle} ${fontWeight} ${el.fontSize}px "${fontFamily}", sans-serif`;
          ctx.fillStyle = el.color;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          if (el.shadow) {
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
          }
          
          ctx.fillText(el.text, 0, 0);
          
          if (el.underline) {
            ctx.shadowColor = 'transparent';
            const textWidth = ctx.measureText(el.text).width;
            ctx.beginPath();
            ctx.strokeStyle = el.color;
            ctx.lineWidth = Math.max(1, el.fontSize / 15);
            ctx.moveTo(-textWidth / 2, el.fontSize / 3);
            ctx.lineTo(textWidth / 2, el.fontSize / 3);
            ctx.stroke();
          }
          
          ctx.restore();
        } else if (el.type === 'shape') {
          ctx.save();
          ctx.globalAlpha = opacity;
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          ctx.scale(flipX, flipY);
          
          const w = el.width;
          const h = el.height;
          const fill = el.fill || '#7c3aed';
          const stroke = el.stroke || '';
          const shape = el.shapeType || 'rect';
          
          ctx.fillStyle = fill;
          if (stroke) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 2;
          }
          
          ctx.beginPath();
          
          // Draw different shapes
          switch (shape) {
            case 'circle':
            case 'ellipse':
              ctx.ellipse(0, 0, w / 2, h / 2, 0, 0, Math.PI * 2);
              break;
            case 'triangle':
              ctx.moveTo(0, -h / 2);
              ctx.lineTo(w / 2, h / 2);
              ctx.lineTo(-w / 2, h / 2);
              ctx.closePath();
              break;
            case 'diamond':
            case 'rhombus':
              ctx.moveTo(0, -h / 2);
              ctx.lineTo(w / 2, 0);
              ctx.lineTo(0, h / 2);
              ctx.lineTo(-w / 2, 0);
              ctx.closePath();
              break;
            case 'pentagon':
              drawPolygon(ctx, 5, w / 2, h / 2);
              break;
            case 'hexagon':
              drawPolygon(ctx, 6, w / 2, h / 2);
              break;
            case 'octagon':
              drawPolygon(ctx, 8, w / 2, h / 2);
              break;
            case 'star':
            case 'star-4':
            case 'star-5':
            case 'star-6':
              const points = shape === 'star-4' ? 4 : (shape === 'star-6' ? 6 : 5);
              drawStar(ctx, points, w / 2, h / 2, w / 4, h / 4);
              break;
            case 'heart':
              drawHeart(ctx, w, h);
              break;
            case 'arrow-right':
            case 'arrow-left':
            case 'arrow-up':
            case 'arrow-down':
              drawArrow(ctx, w, h, shape);
              break;
            case 'cross':
            case 'plus':
              drawCross(ctx, w, h);
              break;
            case 'rounded':
              const r = Math.min(el.borderRadius || 12, w / 2, h / 2);
              ctx.roundRect(-w / 2, -h / 2, w, h, r);
              break;
            default:
              // Default rectangle
              ctx.rect(-w / 2, -h / 2, w, h);
          }
          
          ctx.fill();
          if (stroke) ctx.stroke();
          ctx.restore();
        }
      }
    }
    
    // Helper functions for drawing shapes on canvas
    function drawPolygon(ctx, sides, rx, ry) {
      for (let i = 0; i < sides; i++) {
        const angle = (Math.PI * 2 * i / sides) - Math.PI / 2;
        const x = Math.cos(angle) * rx;
        const y = Math.sin(angle) * ry;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
    }
    
    function drawStar(ctx, points, outerRx, outerRy, innerRx, innerRy) {
      for (let i = 0; i < points * 2; i++) {
        const angle = (Math.PI * 2 * i / (points * 2)) - Math.PI / 2;
        const rx = i % 2 === 0 ? outerRx : innerRx;
        const ry = i % 2 === 0 ? outerRy : innerRy;
        const x = Math.cos(angle) * rx;
        const y = Math.sin(angle) * ry;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
    }
    
    function drawHeart(ctx, w, h) {
      const x = -w / 2;
      const y = -h / 2;
      ctx.moveTo(x + w / 2, y + h / 4);
      ctx.bezierCurveTo(x + w / 2, y, x, y, x, y + h / 4);
      ctx.bezierCurveTo(x, y + h / 2, x + w / 2, y + h * 0.7, x + w / 2, y + h);
      ctx.bezierCurveTo(x + w / 2, y + h * 0.7, x + w, y + h / 2, x + w, y + h / 4);
      ctx.bezierCurveTo(x + w, y, x + w / 2, y, x + w / 2, y + h / 4);
      ctx.closePath();
    }
    
    function drawArrow(ctx, w, h, direction) {
      const hw = w / 2, hh = h / 2;
      ctx.save();
      if (direction === 'arrow-left') ctx.rotate(Math.PI);
      else if (direction === 'arrow-up') ctx.rotate(-Math.PI / 2);
      else if (direction === 'arrow-down') ctx.rotate(Math.PI / 2);
      
      ctx.moveTo(hw, 0);
      ctx.lineTo(0, -hh);
      ctx.lineTo(0, -hh / 3);
      ctx.lineTo(-hw, -hh / 3);
      ctx.lineTo(-hw, hh / 3);
      ctx.lineTo(0, hh / 3);
      ctx.lineTo(0, hh);
      ctx.closePath();
      ctx.restore();
    }
    
    function drawCross(ctx, w, h) {
      const t = Math.min(w, h) / 3;
      ctx.moveTo(-t / 2, -h / 2);
      ctx.lineTo(t / 2, -h / 2);
      ctx.lineTo(t / 2, -t / 2);
      ctx.lineTo(w / 2, -t / 2);
      ctx.lineTo(w / 2, t / 2);
      ctx.lineTo(t / 2, t / 2);
      ctx.lineTo(t / 2, h / 2);
      ctx.lineTo(-t / 2, h / 2);
      ctx.lineTo(-t / 2, t / 2);
      ctx.lineTo(-w / 2, t / 2);
      ctx.lineTo(-w / 2, -t / 2);
      ctx.lineTo(-t / 2, -t / 2);
      ctx.closePath();
    }
    
    async function doExport() {
      const canvasEl = document.getElementById('canvas');
      const filename = (getProjectNameValue() || 'qr_design').replace(/[\\\/\:\*\?\"\<\>\|]+/g, ' ').trim() || 'qr_design';
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      
      // Get export dimensions
      const dims = getExportDimensions();
      const scaleX = dims.width / canvasW;
      const scaleY = dims.height / canvasH;
      
      const cvs = document.createElement('canvas');
      cvs.width = dims.width;
      cvs.height = dims.height;
      const ctx = cvs.getContext('2d');
      ctx.scale(scaleX, scaleY);
      
      // Draw with rounded corners (scaled)
      const scaledRadius = exportRadius * Math.min(scaleX, scaleY);
      ctx.save();
      if (exportRadius > 0) {
        ctx.beginPath();
        ctx.roundRect(0, 0, canvasW, canvasH, exportRadius);
        ctx.clip();
      }
      
      // Background
      ctx.fillStyle = canvasEl.style.backgroundColor || '#fff';
      ctx.fillRect(0, 0, canvasW, canvasH);
      
      // Draw elements
      drawElementsToContext(ctx, scaleX);
      ctx.restore();
      
      // Export based on format
      const link = document.createElement('a');
      
      if (exportFormat === 'png') {
        link.download = filename + '.png';
        link.href = cvs.toDataURL('image/png');
        link.click();
      } else if (exportFormat === 'jpg') {
        link.download = filename + '.jpg';
        link.href = cvs.toDataURL('image/jpeg', exportQuality / 100);
        link.click();
      } else if (exportFormat === 'svg') {
        // Create SVG (simplified - just embed the PNG)
        const dataUrl = cvs.toDataURL('image/png');
        const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${dims.width}" height="${dims.height}">
  <image xlink:href="${dataUrl}" width="${dims.width}" height="${dims.height}"/>
</svg>`;
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        link.download = filename + '.svg';
        link.href = URL.createObjectURL(blob);
        link.click();
      } else if (exportFormat === 'pdf') {
        // For PDF we need jsPDF library - fallback to PNG
        alert('PDF export requires jsPDF library. Downloading as PNG instead.');
        link.download = filename + '.png';
        link.href = cvs.toDataURL('image/png');
        link.click();
      }
      
      closeExportModal();
    }

    // Download image (legacy - now opens modal)
    async function downloadImageDirect() {
      const canvasEl = document.getElementById('canvas');
      const filename = (getProjectNameValue() || 'qr_design').replace(/[\\\/\:\*\?\"\<\>\|]+/g, ' ').trim() || 'qr_design';

      // Use html2canvas approach - create a canvas manually
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);

      const cvs = document.createElement('canvas');
      cvs.width = canvasW * 2; // 2x for quality
      cvs.height = canvasH * 2;
      const ctx = cvs.getContext('2d');
      ctx.scale(2, 2);

      // Background
      ctx.fillStyle = canvasEl.style.backgroundColor || '#fff';
      ctx.fillRect(0, 0, canvasW, canvasH);

      // Draw elements
      for (const el of elements) {
        const angle = (normalizeRotation(el.rotation) * Math.PI) / 180;
        const opacity = el.opacity !== undefined ? el.opacity / 100 : 1;
        
        if (el.type === 'qr') {
          const baseImg = document.querySelector(`#${el.id} img.qr-base`) || document.querySelector(`#${el.id} .qr-content img`);
          if (baseImg) {
            ctx.save();
            ctx.globalAlpha = opacity;
            const centerX = el.x + el.width / 2;
            const centerY = el.y + el.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(angle);
            ctx.drawImage(baseImg, -el.width / 2, -el.height / 2, el.width, el.height);
            ctx.restore();
          }
        } else if (el.type === 'text') {
          ctx.save();
          ctx.globalAlpha = opacity;
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          
          // Background
          if (el.bgColor) {
            ctx.fillStyle = el.bgColor;
            ctx.fillRect(-el.width / 2, -el.height / 2, el.width, el.height);
          }
          
          // Font styling
          const fontFamily = el.fontFamily || 'Be Vietnam Pro';
          const fontWeight = el.bold ? 'bold' : 'normal';
          const fontStyle = el.italic ? 'italic' : 'normal';
          ctx.font = `${fontStyle} ${fontWeight} ${el.fontSize}px "${fontFamily}", sans-serif`;
          ctx.fillStyle = el.color;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Shadow
          if (el.shadow) {
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
          }
          
          ctx.fillText(el.text, 0, 0);
          
          // Underline
          if (el.underline) {
            ctx.shadowColor = 'transparent';
            const textWidth = ctx.measureText(el.text).width;
            ctx.beginPath();
            ctx.strokeStyle = el.color;
            ctx.lineWidth = Math.max(1, el.fontSize / 15);
            ctx.moveTo(-textWidth / 2, el.fontSize / 3);
            ctx.lineTo(textWidth / 2, el.fontSize / 3);
            ctx.stroke();
          }
          
          ctx.restore();
        }
      }

      // Download
      const link = document.createElement('a');
      link.download = filename + '.png';
      link.href = cvs.toDataURL('image/png');
      link.click();
    }

    // Copy to clipboard
    async function copyToClipboard() {
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);

      const cvs = document.createElement('canvas');
      cvs.width = canvasW * 2;
      cvs.height = canvasH * 2;
      const ctx = cvs.getContext('2d');
      ctx.scale(2, 2);

      ctx.fillStyle = canvasEl.style.backgroundColor || '#fff';
      ctx.fillRect(0, 0, canvasW, canvasH);

      for (const el of elements) {
        const angle = (normalizeRotation(el.rotation) * Math.PI) / 180;
        const opacity = el.opacity !== undefined ? el.opacity / 100 : 1;
        
        if (el.type === 'qr') {
          const baseImg = document.querySelector(`#${el.id} img.qr-base`) || document.querySelector(`#${el.id} .qr-content img`);
          if (baseImg) {
            ctx.save();
            ctx.globalAlpha = opacity;
            const centerX = el.x + el.width / 2;
            const centerY = el.y + el.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(angle);
            ctx.drawImage(baseImg, -el.width / 2, -el.height / 2, el.width, el.height);
            ctx.restore();
          }
        } else if (el.type === 'text') {
          ctx.save();
          ctx.globalAlpha = opacity;
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          
          // Background
          if (el.bgColor) {
            ctx.fillStyle = el.bgColor;
            ctx.fillRect(-el.width / 2, -el.height / 2, el.width, el.height);
          }
          
          // Font styling
          const fontFamily = el.fontFamily || 'Be Vietnam Pro';
          const fontWeight = el.bold ? 'bold' : 'normal';
          const fontStyle = el.italic ? 'italic' : 'normal';
          ctx.font = `${fontStyle} ${fontWeight} ${el.fontSize}px "${fontFamily}", sans-serif`;
          ctx.fillStyle = el.color;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Shadow
          if (el.shadow) {
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
          }
          
          ctx.fillText(el.text, 0, 0);
          
          // Underline
          if (el.underline) {
            ctx.shadowColor = 'transparent';
            const textWidth = ctx.measureText(el.text).width;
            ctx.beginPath();
            ctx.strokeStyle = el.color;
            ctx.lineWidth = Math.max(1, el.fontSize / 15);
            ctx.moveTo(-textWidth / 2, el.fontSize / 3);
            ctx.lineTo(textWidth / 2, el.fontSize / 3);
            ctx.stroke();
          }
          
          ctx.restore();
        }
      }

      cvs.toBlob(blob => {
        navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })])
          .then(() => alert('✅ Đã copy!'))
          .catch(err => alert('❌ ' + err.message));
      });
    }

    // Keyboard shortcut for delete/backspace - only when not editing
    document.addEventListener('keydown', (e) => {
      // Skip if we're in an input, textarea, or contenteditable
      const activeEl = document.activeElement;
      const isEditing = activeEl && (
        activeEl.tagName === 'INPUT' ||
        activeEl.tagName === 'TEXTAREA' ||
        activeEl.contentEditable === 'true' ||
        activeEl.closest('[contenteditable="true"]')
      );
      
      if (isEditing) return;
      
      // Ctrl/Cmd + C: Copy
      if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
        if (selectedIds.size > 0) {
          e.preventDefault();
          copySelected();
        }
      }
      
      // Ctrl/Cmd + V: Paste
      if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
        if (clipboard.length > 0) {
          e.preventDefault();
          pasteClipboard();
        }
      }
      
      // Ctrl/Cmd + D: Duplicate
      if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        if (selectedIds.size > 0) {
          e.preventDefault();
          duplicateSelected();
        }
      }
      
      // Ctrl/Cmd + Z: Undo (always works)
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
        updateFloatingToolbar();
      }
      
      // Ctrl/Cmd + Shift + Z or Ctrl + Y: Redo (always works)
      if ((e.ctrlKey || e.metaKey) && ((e.key === 'z' && e.shiftKey) || e.key === 'y')) {
        e.preventDefault();
        redo();
        updateFloatingToolbar();
      }
      
      // Ctrl/Cmd + A: Select all
      if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
        e.preventDefault();
        elements.forEach(el => selectedIds.add(el.id));
        refreshSelectionStyles();
        updateMultiSelectBox();
        showElementProps();
      }
      
      // Delete or Backspace: Delete selected
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectedIds.size > 0) {
          e.preventDefault();
          deleteSelected();
        }
      }
      
      // Escape to exit inline editing or clear selection
      if (e.key === 'Escape') {
        if (editingTextId) {
          exitInlineEdit();
        } else {
          clearSelection();
        }
      }
      
      // Arrow keys: move selected elements
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        if (selectedIds.size > 0) {
          e.preventDefault();
          const step = e.shiftKey ? 10 : 1;
          const dx = e.key === 'ArrowLeft' ? -step : e.key === 'ArrowRight' ? step : 0;
          const dy = e.key === 'ArrowUp' ? -step : e.key === 'ArrowDown' ? step : 0;
          saveToHistory();
          elements.filter(el => selectedIds.has(el.id)).forEach(el => {
            el.x += dx;
            el.y += dy;
            updateElementPosition(el);
          });
          updateMultiSelectBox();
          showElementProps();
        }
      }
    });

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded fired, calling init...');
      init();
    });

    // Also call immediately in case DOM is already loaded
    if (document.readyState === 'loading') {
      console.log('Document still loading, will wait for DOMContentLoaded');
    } else {
      console.log('Document already loaded, calling init immediately');
      init();
    }
  </script>
</body>
</html>