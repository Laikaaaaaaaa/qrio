<!doctype html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title data-i18n="meta.title">Qrio - Trình chỉnh sửa mã QR miễn phí</title>
  <meta name="description" content="Thiết kế mã QR chuyên nghiệp với trình chỉnh sửa mạnh mẽ. Tùy chỉnh màu sắc, kiểu dáng, thêm logo và xuất ảnh HD." />
  <meta name="robots" content="index, follow" />
  <link rel="canonical" href="https://qrio.site/edit.html" />
  
  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://qrio.site/edit.html" />
  <meta property="og:title" content="Qrio - Trình chỉnh sửa mã QR" />
  <meta property="og:description" content="Thiết kế mã QR chuyên nghiệp với trình chỉnh sửa mạnh mẽ." />
  <meta property="og:image" content="https://qrio.site/static/logo/logo.png" />
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:url" content="https://qrio.site/edit.html" />
  <meta name="twitter:title" content="Qrio Editor" />
  <meta name="twitter:description" content="Thiết kế mã QR chuyên nghiệp." />
  <meta name="twitter:image" content="https://qrio.site/static/logo/logo.png" />

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebPage",
      "name": "Qrio - Trình chỉnh sửa mã QR",
      "url": "https://qrio.site/edit.html",
      "inLanguage": "vi"
    }
  </script>
  
  <!-- Theme color -->
  <meta name="theme-color" content="#7c3aed" />
  
  <link rel="icon" type="image/x-icon" href="/static/logo/favicon_io%20(3)/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/static/logo/favicon_io%20(3)/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/static/logo/favicon_io%20(3)/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/static/logo/favicon_io%20(3)/apple-touch-icon.png">
  <link rel="manifest" href="/static/logo/favicon_io%20(3)/site.webmanifest">
  <link rel="icon" type="image/png" sizes="48x48" href="/static/logo/logo.png">
  <link rel="shortcut icon" href="/static/logo/logo.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700;800&family=Roboto:wght@400;700&family=Open+Sans:wght@400;700&family=Montserrat:wght@400;700&family=Playfair+Display:wght@400;700&family=Dancing+Script:wght@400;700&family=Pacifico&family=Lobster&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: 'Be Vietnam Pro', system-ui, sans-serif;
      background: #1e1e2e;
      color: #fff;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    :root {
      --sidebar-width: 320px;
      --mobile-header-height: 44px;
      --floating-toolbar-height: 52px;
      --floating-toolbar-gap: 12px;
      --desktop-floating-top: 76px;
      --mobile-main-top: calc(var(--mobile-header-height) + var(--floating-toolbar-height) + var(--floating-toolbar-gap));
    }

    /* LAYOUT */
    .app-layout {
      display: flex;
      height: 100vh;
    }

    /* SIDEBAR */
    .sidebar {
      width: var(--sidebar-width);
      background: #2a2a3e;
      display: flex;
      flex-direction: column;
      border-right: 1px solid #3a3a50;
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 14px 18px;
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logo-box {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background: transparent;
    }

    .logo-box img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .sidebar-header h1 {
      font-size: 16px;
      font-weight: 700;
    }

    .sidebar-home-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 8px 14px;
      background: rgba(255,255,255,0.15);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      transition: background 0.15s;
    }

    .sidebar-home-btn:hover {
      background: rgba(255,255,255,0.25);
    }

    /* TABS */
    .sidebar-tabs {
      display: flex;
      border-bottom: 1px solid #3a3a50;
    }

    .sidebar-tabs.hidden {
      display: none;
    }

    .sidebar-tab {
      flex: 1;
      padding: 12px;
      text-align: center;
      font-size: 11px;
      font-weight: 600;
      color: #888;
      cursor: pointer;
      border: none;
      background: transparent;
      transition: 0.2s;
    }

    .sidebar-tab:hover {
      color: #fff;
    }

    .sidebar-tab.active {
      color: #7c3aed;
      border-bottom: 2px solid #7c3aed;
      margin-bottom: -1px;
    }

    /* SIDEBAR CONTENT */
    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .sidebar-panel {
      display: none;
    }

    .sidebar-panel.active {
      display: block;
    }

    .section {
      margin-bottom: 16px;
      background: #232336;
      border-radius: 8px;
      padding: 12px;
    }
    
    .mobile-bottom-controls {
      display: none;
      align-items: center;
      gap: 10px;
      flex: 1;
      min-width: 0;
    }
    
    .mobile-bottom-controls input[type="text"] {
      flex: 1;
      min-width: 0;
      max-width: 45vw;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.20);
      color: #fff;
      font-size: 12px;
      outline: none;
    }
    
    .mobile-zoom-slider {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.20);
      flex: 1;
      min-width: 0;
      max-width: 45vw;
    }
    
    .mobile-zoom-slider input[type="range"] {
      flex: 1;
      min-width: 0;
    }
    
    .mobile-zoom-slider span {
      font-size: 11px;
      color: rgba(255,255,255,0.85);
      min-width: 44px;
      text-align: right;
      flex-shrink: 0;
    }

    .section-title {
      font-size: 11px;
      font-weight: 700;
      color: #7c3aed;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid #3a3a50;
    }

    /* QR TYPES */
    .types-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .type-btn {
      padding: 10px 6px;
      border-radius: 6px;
      background: #3a3a50;
      border: 2px solid transparent;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: 0.2s;
      color: #aaa;
    }

    .type-btn:hover {
      background: #4a4a60;
      color: #fff;
    }

    .type-btn.active {
      background: #4f46e5;
      border-color: #7c3aed;
      color: #fff;
    }

    .type-btn .icon {
      font-size: 16px;
    }

    .type-btn .label {
      font-size: 9px;
      font-weight: 600;
    }

    /* QR image */
    .qr-content img.qr-base {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* FORMS */
    .form-group {
      margin-bottom: 10px;
    }

    .form-group:last-child {
      margin-bottom: 0;
    }

    .form-group label {
      display: block;
      font-size: 10px;
      font-weight: 600;
      color: #aaa;
      margin-bottom: 4px;
    }

    .form-group input[type="text"],
    .form-group input[type="url"],
    .form-group input[type="email"],
    .form-group input[type="tel"],
    .form-group input[type="number"],
    .form-group input[type="datetime-local"],
    .form-group input[type="date"],
    .form-group input[type="time"],
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: 8px 10px;
      border: 2px solid #3a3a50;
      border-radius: 6px;
      font-size: 11px;
      font-family: inherit;
      background: #1e1e2e;
      color: #fff;
      transition: 0.2s;
    }

    /* Improve native datetime picker on dark backgrounds */
    .form-group input[type="datetime-local"],
    .form-group input[type="date"],
    .form-group input[type="time"] {
      color-scheme: dark;
    }
    .form-group input[type="datetime-local"]::-webkit-calendar-picker-indicator,
    .form-group input[type="date"]::-webkit-calendar-picker-indicator,
    .form-group input[type="time"]::-webkit-calendar-picker-indicator {
      filter: invert(1);
      opacity: 0.8;
    }

    .form-group input:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline: none;
      border-color: #7c3aed;
    }

    /* Custom Font Picker */
    .font-picker-wrapper {
      position: relative;
    }
    .font-picker-input {
      cursor: pointer;
    }
    .font-picker-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 250px;
      overflow-y: auto;
      background: #1e1e2e;
      border: 2px solid #7c3aed;
      border-radius: 6px;
      z-index: 1000;
      display: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }
    .font-picker-dropdown.show {
      display: block;
      animation: fadeInSlide 0.2s ease;
    }
    @keyframes fadeInSlide {
      from { opacity: 0; transform: translateY(-8px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .font-picker-item {
      padding: 10px 12px;
      cursor: pointer;
      font-size: 14px;
      color: #e2e8f0;
      border-bottom: 1px solid #2a2a3a;
      transition: background 0.15s;
    }
    .font-picker-item:last-child {
      border-bottom: none;
    }
    .font-picker-item:hover {
      background: #2d2d40;
    }
    .font-picker-item.selected {
      background: #4f46e5;
      color: #fff;
    }
    .font-picker-search {
      position: sticky;
      top: 0;
      background: #1e1e2e;
      padding: 8px;
      border-bottom: 1px solid #3a3a50;
    }
    .font-picker-search input {
      width: 100%;
      padding: 8px 10px;
      border: 2px solid #3a3a50;
      border-radius: 6px;
      background: #2a2a3a;
      color: #fff;
      font-size: 12px;
    }
    .font-picker-search input:focus {
      outline: none;
      border-color: #7c3aed;
    }

    .style-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }

    .style-btn,
    .finder-btn {
      border: 1px solid #3a3a50;
      background: #1f1f2f;
      color: #fff;
      border-radius: 8px;
      padding: 10px;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      transition: 0.2s;
    }

    .style-btn.active,
    .finder-btn.active {
      border-color: #7c3aed;
      background: #332c5c;
      color: #e5dbff;
    }

    .style-btn i,
    .finder-btn i {
      font-size: 20px;
    }

    .finder-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 6px;
      margin-top: 8px;
    }

    .finder-group {
      margin-bottom: 12px;
    }

    .custom-shape {
      font-size: 11px;
      color: #aaa;
      margin-top: 6px;
    }

    .form-group input[type="range"] {
      width: 100%;
      cursor: pointer;
    }

    .version-hint {
      font-size: 11px;
      color: #aaa;
      margin-top: 4px;
    }

    .form-group textarea {
      min-height: 50px;
      resize: vertical;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    /* Event datetime inputs are wider (date + time); stack to avoid clipping in the sidebar */
    #form-event .form-row {
      grid-template-columns: 1fr;
    }

    .special-form {
      display: none;
    }

    .special-form.active {
      display: block;
    }

    /* COLOR PICKER */
    .color-picker-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .color-input-wrap {
      position: relative;
      width: 36px;
      height: 36px;
      flex-shrink: 0;
      border-radius: 6px;
      overflow: hidden;
      border: 2px solid #3a3a50;
    }

    .color-input-wrap input[type="color"] {
      width: 50px;
      height: 50px;
      border: none;
      cursor: pointer;
      padding: 0;
      margin: -7px;
    }

    .color-presets {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .color-dot {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: 0.15s;
    }

    .color-dot:hover {
      transform: scale(1.1);
    }

    .color-dot.active {
      border-color: #fff;
      box-shadow: 0 0 0 2px #7c3aed;
    }

    /* PILLS */
    .pill-row {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .pill {
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      background: #3a3a50;
      color: #aaa;
      border: none;
      transition: 0.15s;
    }

    .pill:hover {
      background: #4a4a60;
      color: #fff;
    }

    .pill.active {
      background: #4f46e5;
      color: #fff;
    }

    /* SHAPES GRID */
    .shapes-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .shape-preview {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 10px 6px;
      background: #3a3a50;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s;
      border: 2px solid transparent;
    }

    .shape-preview:hover {
      background: #4a4a60;
      border-color: #6366f1;
      transform: translateY(-2px);
    }

    .shape-thumb {
      width: 36px;
      height: 36px;
      flex-shrink: 0;
    }

    .shape-thumb.svg-thumb {
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      color: #fff;
    }

    .shape-thumb svg,
    .shape-thumb i {
      width: 100%;
      height: 100%;
      display: block;
    }

    .shape-preview span {
      font-size: 10px;
      color: #aaa;
      text-align: center;
      line-height: 1.2;
    }

    .shape-preview:hover span {
      color: #fff;
    }

    /* MAIN AREA */
    .main-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #1e1e2e;
      min-width: 0;
    }

    /* TOOLBAR */
    .toolbar {
      padding: 8px 16px;
      background: #2a2a3e;
      border-bottom: 1px solid #3a3a50;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .toolbar-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .selection-hint {
      font-size: 10px;
      color: #aaa;
      margin-left: 10px;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 10px;
      border-right: 1px solid #3a3a50;
    }

    .toolbar-group:last-child {
      border-right: none;
    }

    .toolbar-label {
      font-size: 10px;
      color: #888;
    }

    .toolbar-input {
      padding: 5px 8px;
      border: 1px solid #3a3a50;
      border-radius: 4px;
      background: #1e1e2e;
      color: #fff;
      font-size: 11px;
      width: 100px;
    }

    .toolbar-input:focus {
      outline: none;
      border-color: #7c3aed;
    }

    .toolbar-btn {
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      background: #3a3a50;
      color: #fff;
      transition: 0.15s;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .toolbar-btn:hover {
      background: #4a4a60;
    }

    .toolbar-btn.primary {
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
    }

    .toolbar-btn.primary:hover {
      opacity: 0.9;
    }

    /* ZOOM CONTROLS */
    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .zoom-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: none;
      background: #3a3a50;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .zoom-btn:hover {
      background: #4a4a60;
    }

    .zoom-value {
      font-size: 11px;
      color: #aaa;
      min-width: 45px;
      text-align: center;
    }

    /* CANVAS AREA */
    /* Canvas uses top-left origin so elements don't shift when resizing */
    .canvas-wrapper {
      flex: 1;
      overflow: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      position: relative;
      background:
        linear-gradient(45deg, #252535 25%, transparent 25%),
        linear-gradient(-45deg, #252535 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #252535 75%),
        linear-gradient(-45deg, transparent 75%, #252535 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      background-color: #1e1e2e;
    }

    .canvas-stage {
      position: relative;
      flex-shrink: 0;
      margin: 0 auto;
    }

    /* CANVAS */
    .canvas {
      position: absolute;
      left: 0;
      top: 0;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      transform-origin: top left; /* top-left origin keeps elements stable when resizing */
      overflow: hidden;
      transition: outline 0.15s ease;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      flex-shrink: 0;
      margin: 0;
    }

    /* SHAPES */
    .shape-base { width: 100%; height: 100%; }
    .shape-base.shape-svg {
      display: flex;
      align-items: center;
      justify-content: center;
      color: inherit;
    }

    .shape-base.shape-svg svg,
    .shape-base.shape-svg i {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .canvas * {
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    .canvas-empty-state {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 30;
    }

    .canvas-empty-card {
      pointer-events: auto;
      background: rgba(17, 24, 39, 0.8);
      border: 1px dashed #3a3a50;
      border-radius: 14px;
      padding: 18px 20px;
      min-width: 220px;
      text-align: center;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      animation: fadeInEmpty 0.25s ease;
    }

    .canvas-empty-card i {
      display: inline-flex;
      width: 46px;
      height: 46px;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      color: #fff;
      margin-bottom: 10px;
    }

    .canvas-empty-card .title {
      font-weight: 700;
      font-size: 16px;
      color: #e2e8f0;
      margin-bottom: 4px;
    }

    .canvas-empty-card .subtitle {
      font-size: 12px;
      color: #94a3b8;
      margin-bottom: 12px;
    }

    .canvas-empty-card .cta-btn {
      padding: 10px 14px;
      border-radius: 10px;
      border: none;
      background: linear-gradient(135deg, #10b981, #22c55e);
      color: #0b3b33;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .canvas-empty-card .cta-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(16, 185, 129, 0.35);
    }

    @keyframes fadeInEmpty {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .canvas.selected {
      outline: 2px solid #10b981;
      outline-offset: 4px;
    }

    /* WRAPPER SELECTION BOX */
    .wrapper-selection-box {
      position: absolute;
      border: 1px dashed rgba(99, 102, 241, 0.8);
      background: rgba(99, 102, 241, 0.1);
      pointer-events: none;
      z-index: 25;
    }

    /* GUIDES */
    .guides-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
      display: block;
    }

    .guide {
      position: absolute;
      background: transparent;
      border-top: 1px dashed #f43f5e;
      z-index: 51;
      pointer-events: none;
      opacity: 0.8;
    }

    .guide.horizontal {
      height: 0;
      left: 0;
      right: 0;
      width: 100%;
    }

    .guide.vertical {
      width: 0;
      border-left: 1px dashed #f43f5e;
      border-top: none;
      top: 0;
      bottom: 0;
      height: 100%;
    }

    .selection-box {
      position: absolute;
      border: 1px dashed rgba(99, 102, 241, 0.8);
      background: rgba(99, 102, 241, 0.15);
      pointer-events: none;
      z-index: 45;
    }

    /* CANVAS ELEMENT */
    .canvas-element {
      position: absolute;
      cursor: move;
      display: flex;
      align-items: center;
      justify-content: center;
      transform-origin: center center;
    }

    .canvas-element.selected {
      outline: 2px solid #4f46e5;
      outline-offset: 2px;
    }

    .canvas-element.selected::after {
      content: '';
      position: absolute;
      inset: -4px;
      border: 1px dashed #7c3aed;
      pointer-events: none;
    }

    /* When multi-selected, hide individual handles - only show border */
    .canvas-element.selected.multi-selected .resize-handle,
    .canvas-element.selected.multi-selected .rotation-handle,
    .canvas-element.selected.multi-selected .rotation-line {
      display: none !important;
    }

    .canvas-element.selected.multi-selected::after {
      border: none;
    }

    /* RESIZE HANDLES - use inverse scale to maintain consistent size at any zoom */
    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #fff;
      border: 2px solid #4f46e5;
      border-radius: 2px;
      z-index: 10;
      transform-origin: center center;
    }

    .resize-handle.nw {
      top: -5px;
      left: -5px;
      cursor: nw-resize;
    }

    .resize-handle.ne {
      top: -5px;
      right: -5px;
      cursor: ne-resize;
    }

    .resize-handle.sw {
      bottom: -5px;
      left: -5px;
      cursor: sw-resize;
    }

    .resize-handle.se {
      bottom: -5px;
      right: -5px;
      cursor: se-resize;
    }

    .resize-handle.n {
      top: -5px;
      left: 50%;
      cursor: n-resize;
    }

    .resize-handle.s {
      bottom: -5px;
      left: 50%;
      cursor: s-resize;
    }

    .resize-handle.w {
      left: -5px;
      top: 50%;
      cursor: w-resize;
    }

    .resize-handle.e {
      right: -5px;
      top: 50%;
      cursor: e-resize;
    }

    /* ROTATION HANDLE */
    /* ROTATION HANDLE - use inverse scale to maintain consistent size */
    .rotation-handle {
      position: absolute;
      top: -35px;
      left: 50%;
      width: 20px;
      height: 20px;
      background: #fff;
      border: 2px solid #4f46e5;
      border-radius: 50%;
      cursor: grab;
      z-index: 15;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #4f46e5;
      transform-origin: center center;
    }
    
    .rotation-handle:hover {
      background: #4f46e5;
      color: #fff;
    }
    
    .rotation-handle:active {
      cursor: grabbing;
    }
    
    .rotation-line {
      position: absolute;
      top: -15px;
      left: 50%;
      width: 1px;
      height: 15px;
      background: #4f46e5;
      z-index: 14;
      transform-origin: center top;
    }

    /* MULTI-SELECT BOUNDING BOX */
    .multi-select-box {
      position: absolute;
      border: 2px solid #10b981;
      background: rgba(16, 185, 129, 0.05);
      pointer-events: auto;
      z-index: 100;
    }
    
    .multi-select-box .ms-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #fff;
      border: 2px solid #10b981;
      border-radius: 2px;
      z-index: 101;
      transform-origin: center center;
    }
    
    .multi-select-box .ms-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
    .multi-select-box .ms-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
    .multi-select-box .ms-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
    .multi-select-box .ms-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
    .multi-select-box .ms-handle.n { top: -5px; left: 50%; cursor: n-resize; }
    .multi-select-box .ms-handle.s { bottom: -5px; left: 50%; cursor: s-resize; }
    .multi-select-box .ms-handle.w { left: -5px; top: 50%; cursor: w-resize; }
    .multi-select-box .ms-handle.e { right: -5px; top: 50%; cursor: e-resize; }

    /* CONTEXT MENU */
    .context-menu {
      position: fixed;
      background: #2a2a3e;
      border: 1px solid #3a3a50;
      border-radius: 8px;
      padding: 6px 0;
      min-width: 180px;
      z-index: 9999;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }
    
    .context-menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 14px;
      cursor: pointer;
      font-size: 12px;
      color: #e2e8f0;
      transition: background 0.15s;
    }
    
    .context-menu-item:hover {
      background: #3a3a50;
    }
    
    .context-menu-item i {
      width: 16px;
      text-align: center;
      color: #94a3b8;
    }
    
    .context-menu-item .shortcut {
      margin-left: auto;
      font-size: 10px;
      color: #64748b;
    }
    
    .context-menu-divider {
      height: 1px;
      background: #3a3a50;
      margin: 4px 0;
    }
    
    .context-menu-submenu {
      position: relative;
    }
    
    .context-menu-submenu::after {
      content: '▸';
      position: absolute;
      right: 10px;
      color: #64748b;
    }

    /* MOBILE TOP TOOLBAR */
    .mobile-toolbar {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 44px;
      background: #1e1e2e;
      border-bottom: 1px solid #3a3a50;
      z-index: 100;
      padding: 0 8px;
      align-items: center;
      gap: 2px;
      overflow-x: auto;
    }
    
    .mobile-toolbar::-webkit-scrollbar {
      display: none;
    }
    
    .mobile-toolbar-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 4px 8px;
      background: transparent;
      border: none;
      color: #94a3b8;
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      min-width: 40px;
      white-space: nowrap;
    }
    
    .mobile-toolbar-btn:hover,
    .mobile-toolbar-btn:active {
      background: #3a3a50;
      color: #fff;
    }
    
    .mobile-toolbar-btn span {
      font-size: 9px;
      margin-top: 2px;
    }
    
    .mobile-toolbar-divider {
      width: 1px;
      height: 24px;
      background: #3a3a50;
      margin: 0 4px;
    }

    /* FLOATING TOOLBAR (like Canva) - appears when elements selected */
    .floating-toolbar {
      position: fixed;
      top: var(--desktop-floating-top);
      left: 0;
      transform: none;
      display: none;
      align-items: center;
      gap: 4px;
      background: #1e1e2e;
      border: 1px solid #3a3a50;
      border-radius: 12px;
      padding: 8px 12px;
      z-index: 500;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    
    .floating-toolbar.visible {
      display: flex;
    }
    
    .floating-toolbar-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      background: transparent;
      border: none;
      color: #94a3b8;
      font-size: 16px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.15s;
    }
    
    .floating-toolbar-btn:hover {
      background: #3a3a50;
      color: #fff;
    }
    
    .floating-toolbar-btn.active {
      background: #4f46e5;
      color: #fff;
    }
    
    .floating-toolbar-divider {
      width: 1px;
      height: 24px;
      background: #3a3a50;
      margin: 0 4px;
    }
    
    .floating-toolbar-dropdown {
      position: relative;
    }
    
    .floating-toolbar-menu {
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #2a2a3e;
      border: 1px solid #3a3a50;
      border-radius: 8px;
      padding: 6px 0;
      min-width: 140px;
      margin-top: 8px;
      display: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      max-height: 70vh;
      overflow-y: auto;
      z-index: 1000;
    }
    
    /* Position the more-menu on the right side */
    #more-menu {
      left: auto;
      right: 0;
      transform: none;
    }

    /* When showing the 3-dots menu inside the mobile bottom panel */
    #panel-more #more-menu {
      position: static;
      left: auto;
      right: auto;
      top: auto;
      transform: none;
      margin-top: 0;
      display: block;
      max-height: none;
      box-shadow: none;
      border: 1px solid #3a3a50;
    }
    
    .floating-toolbar-menu.show {
      display: block;
      animation: fadeInMenu 0.15s ease;
    }
    
    @keyframes fadeInMenu {
      from { opacity: 0; transform: translateY(-4px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .floating-toolbar-menu-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 9px 14px;
      font-size: 12px;
      color: #e2e8f0;
      cursor: pointer;
      transition: background 0.1s;
    }
    
    .floating-toolbar-menu-item:hover {
      background: #3a3a50;
    }
    
    .floating-toolbar-menu-item i {
      width: 16px;
      text-align: center;
      color: #94a3b8;
      font-size: 12px;
    }
    
    .floating-toolbar-menu-item:hover i {
      color: #e2e8f0;
    }

    /* MOBILE HEADER */
    .mobile-header {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 44px;
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      z-index: 200;
      padding: 0 12px;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }

    .mobile-header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .mobile-bottom-logo-link {
      display: none;
      align-items: center;
      justify-content: center;
      text-decoration: none;
    }

    .mobile-bottom-logo-link img {
      width: 28px;
      height: 28px;
      object-fit: contain;
      display: block;
    }

    @media (max-width: 750px) {
      .sidebar-home-btn {
        display: none;
      }

      .mobile-bottom-logo-link {
        display: inline-flex;
      }
    }

    .mobile-header .home-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(255,255,255,0.15);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
      transition: background 0.15s;
    }

    .mobile-header .home-btn:hover {
      background: rgba(255,255,255,0.25);
    }

    .mobile-header .download-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: #10b981;
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
    }

    .mobile-header .download-btn:hover {
      background: #059669;
    }

    .mobile-header-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      min-width: 0;
      justify-content: center;
    }

    .mobile-file-pill {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.18);
      min-width: 0;
      max-width: 48vw;
    }

    .mobile-file-pill .mobile-file-label {
      font-size: 10px;
      color: rgba(255,255,255,0.75);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .mobile-file-pill input {
      border: none;
      outline: none;
      background: transparent;
      color: #fff;
      font-size: 12px;
      min-width: 0;
      width: 100%;
    }

    @media (max-width: 750px) {
      .sidebar-header {
        background: linear-gradient(135deg, #0b0423, #372175);
        border-bottom: 1px solid rgba(255,255,255,0.08);
        box-shadow: 0 12px 30px rgba(0, 4, 40, 0.65);
      }
    }

    .mobile-zoom-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px;
      border-radius: 10px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.18);
      flex-shrink: 0;
    }

    .mobile-zoom-controls .zoom-btn {
      width: 30px;
      height: 30px;
      border-radius: 8px;
      background: rgba(255,255,255,0.12);
    }

    .mobile-zoom-controls .zoom-btn:hover {
      background: rgba(255,255,255,0.18);
    }

    .mobile-zoom-controls .zoom-value {
      color: rgba(255,255,255,0.85);
      min-width: 44px;
      font-size: 11px;
    }

    /* TOAST NOTIFICATION */
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
      15% { opacity: 1; transform: translateX(-50%) translateY(0); }
      85% { opacity: 1; transform: translateX(-50%) translateY(0); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
    }

    /* OPACITY SLIDER */
    .opacity-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .opacity-row input[type="range"] {
      flex: 1;
    }
    
    .opacity-row span {
      font-size: 10px;
      color: #aaa;
      min-width: 35px;
      text-align: right;
    }

    /* GRADIENT PICKER */
    .gradient-toggle {
      padding: 4px 8px;
      font-size: 10px;
      background: #3a3a50;
      border: none;
      border-radius: 4px;
      color: #aaa;
      cursor: pointer;
    }
    
    .gradient-toggle.active {
      background: #4f46e5;
      color: #fff;
    }

    /* EXPORT MODAL */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(4px);
    }
    
    .modal {
      background: #2a2a3e;
      border-radius: 12px;
      width: 500px;
      max-width: 90vw;
      max-height: 85vh;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      padding: 16px 20px;
      border-bottom: 1px solid #3a3a50;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }
    
    .modal-header h3 {
      font-size: 16px;
      font-weight: 600;
      margin: 0;
    }
    
    .modal-close {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      border: none;
      background: #3a3a50;
      color: #fff;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .modal-close:hover {
      background: #dc2626;
    }
    
    .modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    
    .export-preview {
      background: 
        linear-gradient(45deg, #1a1a2a 25%, transparent 25%),
        linear-gradient(-45deg, #1a1a2a 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #1a1a2a 75%),
        linear-gradient(-45deg, transparent 75%, #1a1a2a 75%);
      background-size: 16px 16px;
      background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
      background-color: #232336;
      border-radius: 8px;
      padding: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
      min-height: 150px;
      max-height: 200px;
    }
    
    .export-preview canvas {
      max-width: 100%;
      max-height: 160px;
      border-radius: 8px;
    }
    
    .export-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .export-filename-hint {
      margin-top: 6px;
      font-size: 11px;
      color: #a8a8b8;
      opacity: 0.9;
    }
    
    .export-size-mode {
      background: #1e1e2e;
      padding: 12px;
      border-radius: 8px;
    }
    
    .export-info {
      text-align: center;
      padding: 12px;
      background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
      border-radius: 8px;
      font-size: 13px;
      color: #a8a8b8;
      border: 1px solid #3a3a50;
    }
    
    #quality-group {
      transition: all 0.2s;
    }
    
    #lock-ratio-btn.active {
      background: #7c3aed;
      color: white;
    }
    
    .modal-footer {
      padding: 16px 20px;
      border-top: 1px solid #3a3a50;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-shrink: 0;
    }

    /* TEXT ELEMENT */
    .gradient-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
    }
    
    .gradient-toggle {
      padding: 4px 8px;
      font-size: 10px;
      background: #3a3a50;
      border: none;
      border-radius: 4px;
      color: #aaa;
      cursor: pointer;
    }
    
    .gradient-toggle.active {
      background: #4f46e5;
      color: #fff;
    }

    /* TEXT ELEMENT */
    .text-content {
      text-align: center;
      white-space: normal;
      overflow: hidden;
      padding: 4px 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      word-break: break-word;
      line-height: 1.2;
      border-radius: 4px;
    }

    /* Inline text editing */
    .text-content.editing {
      cursor: text;
      outline: 2px solid #7c3aed;
      background: rgba(255,255,255,0.95);
    }

    .text-content[contenteditable="true"] {
      user-select: text;
    }

    .canvas-element.editing {
      cursor: text;
    }

    /* QR ELEMENT */
    .qr-content img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .qr-loading {
      color: #888;
      font-size: 12px;
    }

    /* ELEMENT TOOLBAR */
    .element-toolbar {
      position: absolute;
      top: -40px;
      left: 50%;
      transform: translateX(-50%);
      background: #2a2a3e;
      border-radius: 6px;
      padding: 4px;
      display: flex;
      gap: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      white-space: nowrap;
    }

    .element-toolbar button {
      padding: 4px 8px;
      border: none;
      background: transparent;
      color: #fff;
      font-size: 11px;
      cursor: pointer;
      border-radius: 4px;
    }

    .element-toolbar button:hover {
      background: #3a3a50;
    }

    /* RIGHT PANEL */
    .right-panel {
      width: 240px;
      background: #2a2a3e;
      border-left: 1px solid #3a3a50;
      padding: 12px;
      overflow-y: auto;
      flex-shrink: 0;
    }

    .right-panel .section-title {
      font-size: 10px;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: #4a4a60;
      border-radius: 3px;
    }


    /* CANVAS HANDLES */
    .canvas-selection-overlay {
      position: absolute;
      pointer-events: none;
      z-index: 30;
      border: 2px solid #10b981;
      border-radius: 10px;
      box-sizing: border-box;
    }

    .canvas-selection-overlay .canvas-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #10b981;
      border: 2px solid #0f766e;
      border-radius: 4px;
      pointer-events: auto;
    }

    .canvas-selection-overlay .canvas-handle.nw { top: -8px; left: -8px; cursor: nw-resize; }
    .canvas-selection-overlay .canvas-handle.ne { top: -8px; right: -8px; cursor: ne-resize; }
    .canvas-selection-overlay .canvas-handle.sw { bottom: -8px; left: -8px; cursor: sw-resize; }
    .canvas-selection-overlay .canvas-handle.se { bottom: -8px; right: -8px; cursor: se-resize; }

    .canvas-selection-overlay .canvas-rotation-line {
      position: absolute;
      top: -32px;
      left: 50%;
      transform: translateX(-50%);
      width: 2px;
      height: 24px;
      background: #10b981;
      pointer-events: none;
    }

    .canvas-selection-overlay .canvas-rotation-handle {
      position: absolute;
      top: -50px;
      left: 50%;
      transform: translateX(-50%);
      width: 20px;
      height: 20px;
      background: #10b981;
      border: 2px solid #0f766e;
      border-radius: 50%;
      cursor: grab;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #0b3b33;
      font-size: 10px;
    }

    .canvas-selection-overlay .canvas-rotation-handle:active { cursor: grabbing; }
    /* MOBILE TOGGLE */
    .mobile-toggle {
      display: none;
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, #4f46e5, #7c3aed);
      border: none;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 4px 15px rgba(79, 70, 229, 0.4);
    }

    .mobile-toggle:hover {
      transform: scale(1.05);
    }

    /* RESPONSIVE */
    
    /* 750–1300px: tablet/small-desktop layout (right panel moves below canvas) */
    @media (max-width: 1300px) {
      .app-layout {
        flex-wrap: wrap;
      }
      
      .sidebar {
        width: 280px;
        flex-shrink: 0;
        height: 100vh;
        max-height: 100vh;
        overflow: hidden;
        min-height: 0;
      }

      .sidebar-content {
        min-height: 0;
      }
      
      .main-area {
        flex: 1;
        min-width: 300px;
      }
      
      .right-panel {
        position: fixed;
        bottom: 0;
        left: 280px;
        right: 0;
        top: auto;
        width: auto;
        height: auto;
        max-height: 35vh;
        border-left: none;
        border-top: 1px solid #3a3a50;
        z-index: 60;
        overflow-y: auto;
      }

      /* Panel is fixed at bottom; give wrapper extra scroll room and avoid vertical auto-centering */
      .canvas-wrapper {
        align-items: center;
        padding-bottom: calc(24px + 35vh);
      }
      
    }
    
    @media (max-width: 1024px) {
      .right-panel {
        left: 260px;
      }
      
      .sidebar {
        width: 260px;
      }
      
      .toolbar {
        flex-wrap: wrap;
        gap: 8px;
        padding: 8px 12px;
      }
      
      .toolbar-group {
        padding: 0 6px;
      }
    }
    
    /* 600–1200px now uses the <=1200px layout (no special 600–900 layout) */

    /* Mobile (<=750px) */
    @media (max-width: 750px) {
      .app-layout {
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }
      
      /* Hide toggle button on mobile */
      .mobile-toggle {
        display: none !important;
      }
      
      /* Hide mobile top toolbar - use floating toolbar instead */
      .mobile-toolbar {
        display: none !important;
      }
      
      /* Left sidebar moves to bottom */
      .sidebar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        top: auto;
        width: 100%;
        height: 45vh;
        z-index: 70;
        transform: translateY(calc(100% - 60px));
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s ease;
        border-right: none;
        border-top: 1px solid #3a3a50;
        border-radius: 16px 16px 0 0;
      }
      
      .sidebar.open {
        transform: translateY(0);
        box-shadow: 0 -12px 40px rgba(0, 0, 0, 0.5);
      }
      
      .sidebar-header {
        padding: 12px 16px;
      }
      
      .sidebar-header h1 {
        font-size: 14px;
      }
      
      .sidebar-content {
        max-height: calc(45vh - 100px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: 24px;
      }
      
      .main-area {
        position: fixed;
        top: var(--mobile-main-top);
        left: 0;
        right: 0;
        bottom: 60px;
        height: auto;
        z-index: 10;
        transition: bottom 0.3s ease;
      }
      
      .main-area.sidebar-open {
        bottom: 45vh;
      }

      .main-area.sidebar-collapsed {
        bottom: 60px;
      }
      
      .toolbar {
        display: none;
      }
      
      .canvas-wrapper {
        padding: 16px;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: auto;
      }
      
      .canvas {
        max-width: none;
        max-height: none;
        flex-shrink: 0;
      }
      
      /* Hide right panel completely on mobile */
      .right-panel {
        display: none !important;
      }
      
      /* Floating toolbar on mobile - position below mobile header, center full screen */
      .floating-toolbar {
        top: calc(var(--mobile-header-height) + var(--floating-toolbar-gap));
        left: 50%;
        transform: translateX(-50%);
        padding: 6px 10px;
        gap: 2px;
        max-width: calc(100vw - 20px);
        overflow-x: auto;
      }
      
      .floating-toolbar-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
        flex-shrink: 0;
      }
      
      /* Mobile header */
      .mobile-header {
        display: flex !important;
      }

      .mobile-bottom-controls {
        display: flex;
      }
      
      .types-grid {
        grid-template-columns: repeat(4, 1fr);
      }
      
      .type-btn {
        padding: 8px 4px;
      }
      
      .type-btn .label {
        display: none;
      }
      
      .modal {
        max-height: 80vh;
        width: 95vw;
      }
      
      .export-preview {
        min-height: 100px;
        max-height: 120px;
        padding: 10px;
      }
      
      .export-preview canvas {
        max-height: 100px;
      }
      
      .modal-body {
        padding: 12px;
      }
      
      .modal-footer {
        padding: 12px;
        flex-wrap: wrap;
        gap: 8px;
      }
      
      .modal-footer button {
        flex: 1;
        min-width: 120px;
      }

      .sidebar-header .mobile-close i {
        transition: transform 0.25s ease;
      }

      .sidebar:not(.open) .mobile-close i {
        transform: rotate(180deg);
      }
      
      .section {
        padding: 10px;
        margin-bottom: 12px;
      }
      
      .form-row {
        grid-template-columns: 1fr;
        gap: 10px;
      }
      
      .pill-row {
        gap: 6px;
      }
      
      .pill {
        padding: 6px 10px;
        font-size: 11px;
      }
    }

    @media (max-width: 480px) {
      :root {
        --mobile-header-height: 48px;
      }
      
      .mobile-header {
        height: 48px;
        padding: 0 10px;
      }
      
      .mobile-header .home-btn {
        padding: 6px 10px;
        font-size: 12px;
      }
      
      .mobile-header .download-btn {
        padding: 6px 12px;
        font-size: 11px;
      }
      
      .sidebar {
        height: 50vh;
        transform: translateY(calc(100% - 54px));
      }
      
      .sidebar.open {
        transform: translateY(0);
      }
      
      .sidebar-content {
        max-height: calc(50vh - 90px);
      }
      
      .main-area {
        bottom: 54px;
      }
      
      .main-area.sidebar-open {
        bottom: 50vh;
      }
      
      .sidebar-tabs {
        font-size: 10px;
      }
      
      .sidebar-tab {
        padding: 8px 4px;
        font-size: 10px;
      }
      
      .sidebar-tab i {
        display: block;
        margin-bottom: 2px;
      }
      
      .types-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      
      .type-btn {
        padding: 6px 4px;
      }
      
      .type-btn .icon {
        font-size: 14px;
      }
      
      .type-btn .label {
        display: block;
        font-size: 7px;
      }
      
      .section {
        padding: 8px;
        margin-bottom: 10px;
      }
      
      .section-title {
        font-size: 10px;
        margin-bottom: 8px;
      }
      
      .form-group label {
        font-size: 9px;
      }
      
      .form-group input,
      .form-group select,
      .form-group textarea {
        font-size: 12px;
        padding: 8px;
      }
      
      .pill {
        padding: 5px 8px;
        font-size: 9px;
      }
      
      .zoom-controls {
        display: none;
      }
      
      .canvas-wrapper {
        padding: 12px;
      }
      
      .floating-toolbar {
        padding: 4px 8px;
        border-radius: 10px;
      }
      
      .floating-toolbar-btn {
        width: 28px;
        height: 28px;
        font-size: 12px;
      }
      
      .floating-toolbar-divider {
        height: 20px;
        margin: 0 2px;
      }
      
      /* Hide some toolbar buttons on very small screens */
      .floating-toolbar .more-btn {
        display: flex;
      }
    }
    
    /* Landscape phone */
    @media (max-height: 500px) and (orientation: landscape) {
      .sidebar {
        height: 60vh;
        transform: translateY(calc(100% - 44px));
      }
      
      .sidebar.open {
        transform: translateY(0);
      }
      
      .sidebar-content {
        max-height: calc(60vh - 80px);
      }
      
      .main-area {
        bottom: 44px;
      }
      
      .main-area.sidebar-open {
        bottom: 60vh;
      }
      
      .canvas-wrapper {
        padding: 10px;
      }
      
      .modal {
        max-height: 95vh;
      }
    }
    
    /* Ensure nothing is cut off */
    @media (max-width: 768px) {
      .shapes-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .style-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .color-presets {
        flex-wrap: wrap;
      }
      
      .finder-row {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>

<body>

  <!-- MOBILE HEADER -->
  <header class="mobile-header" id="mobile-header">
    <div class="mobile-header-left">
      <a href="home.html" class="home-btn" title="Về trang chủ" data-i18n-title="nav.home">
        <i class="fa-solid fa-house"></i>
      </a>
    </div>

    <div class="mobile-header-bar" aria-label="Project name" data-i18n-aria="aria.projectName">
      <div class="mobile-file-pill">
        <input type="text" id="project-name-mobile" value="" placeholder="Tên file" data-i18n-placeholder="project.namePlaceholder" />
      </div>
    </div>

    <button class="download-btn" onclick="openExportModal()" title="Tải xuống" data-i18n-title="action.download">
      <i class="fa-solid fa-download"></i>
    </button>
  </header>

  <div class="app-layout">
    <!-- MOBILE TOP TOOLBAR (like Canva) -->
    <div class="mobile-toolbar" id="mobile-toolbar">
      <button class="mobile-toolbar-btn" onclick="copySelected()">
        <i class="fa-solid fa-copy"></i>
        <span data-i18n="action.copy">Copy</span>
      </button>
      <button class="mobile-toolbar-btn" onclick="pasteClipboard()">
        <i class="fa-solid fa-paste"></i>
        <span data-i18n="action.paste">Dán</span>
      </button>
      <button class="mobile-toolbar-btn" onclick="duplicateSelected()">
        <i class="fa-solid fa-clone"></i>
        <span data-i18n="action.duplicate">Nhân đôi</span>
      </button>
      <div class="mobile-toolbar-divider"></div>
      <button class="mobile-toolbar-btn" onclick="deleteSelected()">
        <i class="fa-solid fa-trash"></i>
        <span data-i18n="action.delete">Xóa</span>
      </button>
      <div class="mobile-toolbar-divider"></div>
      <button class="mobile-toolbar-btn" onclick="moveLayerUp()">
        <i class="fa-solid fa-layer-group"></i>
        <span data-i18n="layer.up">Lên trên</span>
      </button>
      <button class="mobile-toolbar-btn" onclick="moveLayerDown()">
        <i class="fa-solid fa-layer-group fa-flip-vertical"></i>
        <span data-i18n="layer.down">Xuống dưới</span>
      </button>
      <div class="mobile-toolbar-divider"></div>
      <button class="mobile-toolbar-btn" onclick="undo()">
        <i class="fa-solid fa-rotate-left"></i>
        <span data-i18n="action.undo">Hoàn tác</span>
      </button>
      <button class="mobile-toolbar-btn" onclick="redo()">
        <i class="fa-solid fa-rotate-right"></i>
        <span data-i18n="action.redo">Làm lại</span>
      </button>
      <div class="mobile-toolbar-divider"></div>
      <button class="mobile-toolbar-btn" onclick="openExportModal()">
        <i class="fa-solid fa-download"></i>
        <span data-i18n="action.download">Tải xuống</span>
      </button>
    </div>

    <!-- MOBILE TOGGLE -->
    <button class="mobile-toggle" id="mobile-menu-toggle">
      <i class="fa-solid fa-bars"></i>
    </button>
    
    <!-- SIDEBAR -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <a href="home.html" class="mobile-bottom-logo-link" title="Về trang chủ" data-i18n-title="nav.home" aria-label="Home">
          <img src="/static/logo/logo.png" alt="Qrio" />
        </a>
        <a href="home.html" class="sidebar-home-btn" title="Về trang chủ" data-i18n-title="nav.home">
          <i class="fa-solid fa-house"></i>
        </a>

        <!-- Mobile-only: project name + zoom slider (placed on bottom panel header) -->
        <div class="mobile-bottom-controls" aria-label="Mobile viewport zoom" data-i18n-aria="aria.mobileZoom">
          <div class="mobile-zoom-slider">
            <input type="range" id="zoom-slider-mobile" min="10" max="400" step="1" value="100" />
            <span id="zoom-slider-value-mobile">100%</span>
          </div>
        </div>

        <button class="mobile-close" id="mobile-close" style="display:none;margin-left:auto;background:transparent;border:none;color:#fff;font-size:18px;cursor:pointer;">
          <i class="fa-solid fa-chevron-down"></i>
        </button>
      </div>

      <div class="sidebar-tabs">
        <button class="sidebar-tab active" data-panel="qr"><i class="fa-solid fa-qrcode"></i> <span data-i18n="tabs.qr">QR Code</span></button>
        <button class="sidebar-tab" data-panel="text"><i class="fa-solid fa-pencil"></i> <span data-i18n="tabs.text">Text</span></button>
        <button class="sidebar-tab" data-panel="elements"><i class="fa-solid fa-shapes"></i> <span data-i18n="tabs.elements">Thêm</span></button>
      </div>

      <div class="sidebar-content">
        <!-- QR Panel -->
        <div class="sidebar-panel active" id="panel-qr">
          <!-- Create QR Section (shown when no QR exists) -->
          <div id="qr-create-section" class="section" style="text-align:center;">
            <div style="padding:40px 20px;">
              <i class="fa-solid fa-qrcode" style="font-size:48px;color:#4f46e5;margin-bottom:16px;"></i>
              <h3 style="margin:0 0 8px;color:#e2e8f0;" data-i18n="empty.noQr">Chưa có mã QR</h3>
              <p style="margin:0 0 16px;color:#94a3b8;font-size:13px;" data-i18n="empty.noQrHint">Tạo mã QR để bắt đầu thiết kế</p>
              <button class="toolbar-btn" style="width:100%;justify-content:center;background:linear-gradient(135deg,#4f46e5,#7c3aed);color:#fff;padding:12px 20px;" onclick="addQRElement()">
                <i class="fa-solid fa-plus"></i> <span data-i18n="empty.createQr">Tạo mã QR</span>
              </button>
            </div>
          </div>
          
          <!-- QR Customization Section (shown when QR exists) -->
          <div id="qr-customize-section">
          <div class="section">
            <div class="section-title" data-i18n="qr.type">Loại QR</div>
            <div class="types-grid" style="grid-template-columns: repeat(4, 1fr);">
              <button class="type-btn active" data-type="url"><i class="fa-solid fa-link icon"></i><span
                class="label" data-i18n="type.url">URL</span></button>
              <button class="type-btn" data-type="text"><i class="fa-solid fa-font icon"></i><span
                class="label" data-i18n="type.text">Text</span></button>
              <button class="type-btn" data-type="wifi"><i class="fa-solid fa-wifi icon"></i><span
                class="label" data-i18n="type.wifi">WiFi</span></button>
              <button class="type-btn" data-type="email"><i class="fa-solid fa-envelope icon"></i><span
                class="label" data-i18n="type.email">Email</span></button>
              <button class="type-btn" data-type="phone"><i class="fa-solid fa-phone icon"></i><span
                class="label" data-i18n="type.phone">Phone</span></button>
              <button class="type-btn" data-type="sms"><i class="fa-solid fa-message icon"></i><span
                class="label" data-i18n="type.sms">SMS</span></button>
              <button class="type-btn" data-type="location"><i class="fa-solid fa-location-dot icon"></i><span
                class="label" data-i18n="type.location">Vị trí</span></button>
              <button class="type-btn" data-type="vcard"><i class="fa-solid fa-address-card icon"></i><span
                class="label" data-i18n="type.vcard">vCard</span></button>
              <button class="type-btn" data-type="event"><i class="fa-solid fa-calendar-days icon"></i><span
                class="label" data-i18n="type.event">Sự kiện</span></button>
              <button class="type-btn" data-type="vietqr"><i class="fa-solid fa-building-columns icon"></i><span
                class="label" data-i18n="type.vietqr">VietQR</span></button>
              <button class="type-btn" data-type="crypto"><i class="fa-brands fa-bitcoin icon"></i><span
                class="label" data-i18n="type.crypto">Crypto</span></button>
              <button class="type-btn" data-type="file"><i class="fa-solid fa-file-arrow-up icon"></i><span
                class="label" data-i18n="type.file">File</span></button>
            </div>
          </div>

          <div class="section">
            <div class="section-title" data-i18n="qr.complexity">Độ phức tạp</div>
            <div class="form-group">
              <label><span data-i18n="qr.version">Phiên bản</span> <span id="version-label">1</span></label>
              <input type="range" id="qr-version" min="1" max="12" value="1" />
            </div>
            <p id="version-hint" class="version-hint">21 × 21 ô vuông</p>
          </div>

          <div class="section">
            <div class="section-title" data-i18n="qr.content">Nội dung</div>

            <div class="special-form active" id="form-url">
              <div class="form-group">
                <label><span data-i18n="field.urlLabel">URL</span></label>
                <input type="url" id="input-url" placeholder="https://www.agrichat.site/" data-i18n-placeholder="ph.url" />
              </div>
            </div>

            <div class="special-form" id="form-text">
              <div class="form-group">
                <label><span data-i18n="field.textLabel">Văn bản</span></label>
                <textarea id="input-text" placeholder="Nhập văn bản..." data-i18n-placeholder="ph.text"></textarea>
              </div>
            </div>

            <div class="special-form" id="form-phone">
              <div class="form-group">
                <label><span data-i18n="field.phone">Số điện thoại</span></label>
                <input type="tel" id="input-phone" placeholder="+84..." data-i18n-placeholder="ph.phone" />
              </div>
            </div>

            <div class="special-form" id="form-wifi">
              <div class="form-group"><label><span data-i18n="field.ssid">SSID</span></label><input type="text" id="wifi-ssid" placeholder="Tên WiFi" data-i18n-placeholder="ph.ssid" />
              </div>
              <div class="form-group"><label><span data-i18n="field.password">Mật khẩu</span></label><input type="text" id="wifi-password"
                  placeholder="Password" data-i18n-placeholder="ph.password" /></div>
              <div class="form-group">
                <label><span data-i18n="field.security">Bảo mật</span></label>
                <select id="wifi-security">
                  <option value="WPA" data-i18n="wifi.security.wpa">WPA/WPA2</option>
                  <option value="WEP" data-i18n="wifi.security.wep">WEP</option>
                  <option value="nopass" data-i18n="wifi.security.none">Không</option>
                </select>
              </div>
            </div>

            <div class="special-form" id="form-email">
              <div class="form-group"><label><span data-i18n="field.email">Email</span></label><input type="email" id="email-address"
                placeholder="email@..." data-i18n-placeholder="ph.email" /></div>
              <div class="form-group"><label><span data-i18n="field.subject">Tiêu đề</span></label><input type="text" id="email-subject"
                placeholder="Subject" data-i18n-placeholder="ph.subject" /></div>
              <div class="form-group"><label><span data-i18n="field.body">Nội dung</span></label><textarea id="email-body" placeholder="Body..." data-i18n-placeholder="ph.body"></textarea>
              </div>
            </div>

            <div class="special-form" id="form-sms">
              <div class="form-group"><label><span data-i18n="field.smsPhone">SĐT</span></label><input type="tel" id="sms-phone" placeholder="+84..." data-i18n-placeholder="ph.phone" /></div>
              <div class="form-group"><label><span data-i18n="field.smsMessage">Tin nhắn</span></label><textarea id="sms-message"
                  placeholder="Message..." data-i18n-placeholder="ph.smsMessage"></textarea></div>
            </div>
            
            <!-- Location QR -->
            <div class="special-form" id="form-location">
              <div class="form-group"><label><span data-i18n="field.lat">Vĩ độ (Latitude)</span></label><input type="number" step="any" id="loc-lat" placeholder="21.0285" /></div>
              <div class="form-group"><label><span data-i18n="field.lng">Kinh độ (Longitude)</span></label><input type="number" step="any" id="loc-lng" placeholder="105.8542" /></div>
              <div class="form-group"><label><span data-i18n="field.placeName">Tên địa điểm (tùy chọn)</span></label><input type="text" id="loc-name" placeholder="Hà Nội, Việt Nam" data-i18n-placeholder="ph.placeName" /></div>
              <div style="display:flex;gap:8px;margin-top:8px;">
                <button class="toolbar-btn" style="flex:1;justify-content:center;" onclick="getCurrentLocation()">
                  <i class="fa-solid fa-crosshairs"></i> <span data-i18n="action.currentLocation">Vị trí hiện tại</span>
                </button>
              </div>
            </div>
            
            <!-- vCard QR -->
            <div class="special-form" id="form-vcard">
              <div class="form-row">
                <div class="form-group"><label><span data-i18n="vcard.lastName">Họ</span></label><input type="text" id="vcard-lastname" placeholder="Nguyễn" data-i18n-placeholder="ph.vcard.lastName" /></div>
                <div class="form-group"><label><span data-i18n="vcard.firstName">Tên</span></label><input type="text" id="vcard-firstname" placeholder="Văn A" data-i18n-placeholder="ph.vcard.firstName" /></div>
              </div>
              <div class="form-group"><label><span data-i18n="vcard.company">Công ty</span></label><input type="text" id="vcard-org" placeholder="Công ty ABC" data-i18n-placeholder="ph.vcard.company" /></div>
              <div class="form-group"><label><span data-i18n="vcard.title">Chức vụ</span></label><input type="text" id="vcard-title" placeholder="Giám đốc" data-i18n-placeholder="ph.vcard.title" /></div>
              <div class="form-group"><label><span data-i18n="vcard.phone">Điện thoại</span></label><input type="tel" id="vcard-phone" placeholder="+84..." data-i18n-placeholder="ph.phone" /></div>
              <div class="form-group"><label><span data-i18n="vcard.email">Email</span></label><input type="email" id="vcard-email" placeholder="email@company.com" data-i18n-placeholder="ph.vcard.email" /></div>
              <div class="form-group"><label><span data-i18n="vcard.website">Website</span></label><input type="url" id="vcard-url" placeholder="https://..." data-i18n-placeholder="ph.vcard.website" /></div>
              <div class="form-group"><label><span data-i18n="vcard.address">Địa chỉ</span></label><textarea id="vcard-address" placeholder="123 Đường ABC, Quận 1, TP.HCM" data-i18n-placeholder="ph.vcard.address"></textarea></div>
            </div>
            
            <!-- Event/Calendar QR -->
            <div class="special-form" id="form-event">
              <div class="form-group"><label><span data-i18n="event.title">Tên sự kiện</span></label><input type="text" id="event-title" placeholder="Họp team" data-i18n-placeholder="ph.event.title" /></div>
              <div class="form-group"><label><span data-i18n="event.location">Địa điểm</span></label><input type="text" id="event-location" placeholder="Phòng họp A" data-i18n-placeholder="ph.event.location" /></div>
              <div class="form-row">
                <div class="form-group"><label><span data-i18n="event.start">Bắt đầu</span></label><input type="datetime-local" id="event-start" /></div>
                <div class="form-group"><label><span data-i18n="event.end">Kết thúc</span></label><input type="datetime-local" id="event-end" /></div>
              </div>
              <div class="form-group"><label><span data-i18n="event.description">Mô tả</span></label><textarea id="event-desc" placeholder="Chi tiết sự kiện..." data-i18n-placeholder="ph.event.description"></textarea></div>
            </div>
            
            <!-- VietQR (Banking) -->
            <div class="special-form" id="form-vietqr">
              <div class="form-group">
                <label><span data-i18n="bank.scheme">Phương thức</span></label>
                <select id="bank-scheme">
                  <option value="vietqr" data-i18n="bank.scheme.vietqr">VietQR (VN)</option>
                  <option value="sepa" data-i18n="bank.scheme.sepa">SEPA (EPC)</option>
                </select>
              </div>

              <div id="bank-vietqr-fields">
                <div class="form-group">
                  <label><span data-i18n="vietqr.bank">Ngân hàng</span></label>
                  <select id="vietqr-bank">
                    <option value="970436">Vietcombank (VCB)</option>
                    <option value="970418">BIDV</option>
                    <option value="970415">Vietinbank</option>
                    <option value="970405">Agribank</option>
                    <option value="970422">MB Bank</option>
                    <option value="970407">Techcombank</option>
                    <option value="970416">ACB</option>
                    <option value="970432">VPBank</option>
                    <option value="970423">TPBank</option>
                    <option value="970437">HDBank</option>
                    <option value="970448">OCB</option>
                    <option value="970403">Sacombank</option>
                    <option value="970426">MSB</option>
                    <option value="970441">VIB</option>
                    <option value="970443">SHB</option>
                    <option value="970454">Cake</option>
                    <option value="970429">SCB</option>
                    <option value="970431">Eximbank</option>
                    <option value="970400">Saigonbank</option>
                    <option value="970452">KienLongBank</option>
                    <option value="970433">VietABank</option>
                    <option value="970446">COOP Bank</option>
                    <option value="970449">LPBank</option>
                    <option value="970457">Ubank</option>
                    <option value="970406">DongA Bank</option>
                    <option value="970434">IVB</option>
                    <option value="970424">Shinhan Vietnam</option>
                    <option value="970427">VRB</option>
                    <option value="970425">AnBinhBank</option>
                    <option value="970438">BacABank</option>
                    <option value="970421">VietBank</option>
                    <option value="970428">NamABank</option>
                    <option value="970419">NCB</option>
                    <option value="970439">PVcomBank</option>
                    <option value="970412">PGBank</option>
                    <option value="970440">SeABank</option>
                    <option value="970458">TNEX</option>
                    <option value="970462">VBSP</option>
                    <option value="422589">CIMB</option>
                    <option value="801011">Nonghyup</option>
                    <option value="970414">OCBC</option>
                    <option value="970463">Viettel Money</option>
                    <option value="970456">VNPT Money</option>
                  </select>
                </div>
                <div class="form-group"><label><span data-i18n="vietqr.account">Số tài khoản</span></label><input type="text" id="vietqr-account" placeholder="0123456789" data-i18n-placeholder="ph.vietqr.account" /></div>
                <div class="form-group"><label><span data-i18n="vietqr.name">Tên chủ TK (tùy chọn)</span></label><input type="text" id="vietqr-name" placeholder="NGUYEN VAN A" data-i18n-placeholder="ph.vietqr.name" /></div>
                <div class="form-group"><label><span data-i18n="vietqr.amount">Số tiền (VND, tùy chọn)</span></label><input type="number" id="vietqr-amount" placeholder="100000" data-i18n-placeholder="ph.vietqr.amount" /></div>
                <div class="form-group"><label><span data-i18n="vietqr.memo">Nội dung CK (tùy chọn)</span></label><input type="text" id="vietqr-memo" placeholder="Chuyen khoan" data-i18n-placeholder="ph.vietqr.memo" /></div>
              </div>

              <div id="bank-sepa-fields" style="display:none;">
                  <div class="form-group"><label><span data-i18n="sepa.name">Tên người nhận</span></label><input type="text" id="sepa-name" placeholder="John Doe" data-i18n-placeholder="sepa.ph.name" /></div>
                  <div class="form-group"><label><span data-i18n="sepa.iban">IBAN</span></label><input type="text" id="sepa-iban" placeholder="DE89370400440532013000" data-i18n-placeholder="sepa.ph.iban" /></div>
                  <div class="form-group"><label><span data-i18n="sepa.bic">BIC/SWIFT (tùy chọn)</span></label><input type="text" id="sepa-bic" placeholder="DEUTDEFF" data-i18n-placeholder="sepa.ph.bic" /></div>
                  <div class="form-group"><label><span data-i18n="sepa.amount">Số tiền (EUR, tùy chọn)</span></label><input type="number" step="0.01" id="sepa-amount" placeholder="12.34" data-i18n-placeholder="sepa.ph.amount" /></div>
                  <div class="form-group"><label><span data-i18n="sepa.purpose">Mục đích (tùy chọn, 4 ký tự)</span></label><input type="text" id="sepa-purpose" placeholder="GDDS" maxlength="4" data-i18n-placeholder="sepa.ph.purpose" /></div>
                  <div class="form-group"><label><span data-i18n="sepa.remittance">Nội dung chuyển khoản (tùy chọn)</span></label><input type="text" id="sepa-remittance" placeholder="Invoice 123" data-i18n-placeholder="sepa.ph.remittance" /></div>
                  <div class="form-group"><label><span data-i18n="sepa.info">Thông tin thêm (tùy chọn)</span></label><input type="text" id="sepa-info" placeholder="" data-i18n-placeholder="sepa.ph.info" /></div>
              </div>
            </div>
            
            <!-- Crypto QR -->
            <div class="special-form" id="form-crypto">
              <div class="form-group">
                <label><span data-i18n="crypto.currencyType">Loại tiền</span></label>
                <select id="crypto-type">
                  <option value="bitcoin">Bitcoin (BTC)</option>
                  <option value="ethereum">Ethereum (ETH)</option>
                  <option value="litecoin">Litecoin (LTC)</option>
                  <option value="bitcoincash">Bitcoin Cash (BCH)</option>
                  <option value="dogecoin">Dogecoin (DOGE)</option>
                  <option value="monero">Monero (XMR)</option>
                  <option value="solana">Solana (SOL)</option>
                  <option value="tron">TRON (TRX)</option>
                </select>
              </div>
              <div class="form-group"><label><span data-i18n="crypto.address">Địa chỉ ví</span></label><input type="text" id="crypto-address" placeholder="bc1q..." data-i18n-placeholder="ph.crypto.address" /></div>
              <div class="form-group"><label><span data-i18n="crypto.amount">Số lượng (tùy chọn)</span></label><input type="number" step="any" id="crypto-amount" placeholder="0.001" data-i18n-placeholder="ph.crypto.amount" /></div>
              <div class="form-group"><label><span data-i18n="crypto.note">Ghi chú (tùy chọn)</span></label><input type="text" id="crypto-label" placeholder="Donation" data-i18n-placeholder="ph.crypto.note" /></div>
            </div>
            
            <!-- File Upload QR (generates URL to file) -->
            <div class="special-form" id="form-file">
              <div class="form-group">
                <label><span data-i18n="file.uploadLabel">Tải file lên (sẽ tạo link download)</span></label>
                <input type="file" id="file-upload-input" style="display:none" onchange="handleFileUpload(event)" />
                <button class="toolbar-btn" style="width:100%;justify-content:center" onclick="document.getElementById('file-upload-input').click()">
                  <i class="fa-solid fa-cloud-arrow-up"></i> <span data-i18n="file.choose">Chọn file</span>
                </button>
                <p style="font-size:10px;color:#888;margin-top:6px;" data-i18n="file.supportHint">Hỗ trợ: PDF, DOC, XLS, ZIP, hình ảnh... (tối đa 5MB)</p>
              </div>
              <div id="file-upload-preview" style="display:none;margin-top:10px;padding:10px;background:#1e1e2e;border-radius:6px;">
                <div style="display:flex;align-items:center;gap:10px;">
                  <i class="fa-solid fa-file" style="font-size:24px;color:#7c3aed;"></i>
                  <div style="flex:1;overflow:hidden;">
                    <div id="uploaded-file-name" style="font-size:12px;color:#e2e8f0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;"></div>
                    <div id="file-size" style="font-size:10px;color:#888;"></div>
                  </div>
                  <button class="pill" onclick="removeUploadedFile()" data-i18n-aria="action.remove"><i class="fa-solid fa-times"></i></button>
                </div>
              </div>
              <div class="form-group" style="margin-top:10px;">
                <label><span data-i18n="file.orDirectUrl">Hoặc nhập URL file trực tiếp</span></label>
                <input type="url" id="file-direct-url" placeholder="https://example.com/file.pdf" data-i18n-placeholder="ph.fileDirectUrl" />
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-title" data-i18n="section.qrColor">Màu QR</div>
            <div class="form-group">
              <label><span data-i18n="label.qrCodeColor">Màu code</span></label>
              <div class="color-picker-row">
                <div class="color-input-wrap">
                  <input type="color" id="qr-color" value="#1e293b" />
                </div>
                <div class="color-presets" id="qr-color-presets">
                  <div class="color-dot active" style="background:#1e293b" data-color="#1e293b"></div>
                  <div class="color-dot" style="background:#2563eb" data-color="#2563eb"></div>
                  <div class="color-dot" style="background:#059669" data-color="#059669"></div>
                  <div class="color-dot" style="background:#dc2626" data-color="#dc2626"></div>
                  <div class="color-dot" style="background:#7c3aed" data-color="#7c3aed"></div>
                </div>
              </div>
            </div>
            <div class="form-group">
              <label><span data-i18n="label.qrBgColor">Màu nền QR</span></label>
              <div class="color-picker-row">
                <div class="color-input-wrap">
                  <input type="color" id="qr-bg-color" value="#ffffff" />
                </div>
                <div class="color-presets" id="qr-bg-presets">
                  <div class="color-dot active" style="background:#ffffff;border:1px solid #555" data-color="#ffffff">
                  </div>
                  <div class="color-dot" style="background:#f1f5f9" data-color="#f1f5f9"></div>
                  <div class="color-dot" style="background:#fef3c7" data-color="#fef3c7"></div>
                  <div class="color-dot" style="background:#dbeafe" data-color="#dbeafe"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-title" data-i18n="section.qrLogo">Logo QR</div>
            <div class="form-group">
              <label><span data-i18n="label.logoUploadHint">Tải logo lên (sẽ hiển thị ở giữa QR)</span></label>
              <input type="file" id="qr-logo-upload" accept="image/*" style="display:none" />
              <button class="toolbar-btn" style="width:100%;justify-content:center" onclick="document.getElementById('qr-logo-upload').click()">
                <i class="fa-solid fa-upload"></i> <span data-i18n="action.uploadLogo">Tải logo lên</span>
              </button>
              <div id="logo-preview" style="margin-top:8px;display:none;">
                <div style="display:flex;align-items:center;gap:8px;">
                  <img id="logo-preview-img" style="width:40px;height:40px;object-fit:contain;border-radius:4px;border:1px solid #3a3a50;" />
                  <button class="pill" onclick="removeLogo()"><i class="fa-solid fa-times"></i> <span data-i18n="action.remove">Xóa</span></button>
                </div>
              </div>
            </div>
            <div class="form-group">
              <label><span data-i18n="label.logoSize">Kích thước logo (%)</span></label>
              <div class="opacity-row">
                <input type="range" id="logo-size" min="10" max="25" value="25" />
                <span id="logo-size-label">25%</span>
              </div>
            </div>
            <div class="form-group">
              <label><span data-i18n="label.logoRadius">Bo tròn logo (%)</span></label>
              <div class="opacity-row">
                <input type="range" id="logo-radius" min="0" max="50" value="25" />
                <span id="logo-radius-label">25%</span>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-title" data-i18n="section.dotEcc">Dot & ECC</div>
            <div class="form-group">
              <label><span data-i18n="label.dotStyle">Kiểu chấm</span></label>
              <div class="pill-row" id="dot-pills">
                <button class="pill active" data-module="rounded-square" data-i18n="dotStyle.roundedSquare">Vuông bo</button>
                <button class="pill" data-module="square" data-i18n="dotStyle.square">Vuông truyền thống</button>
                <button class="pill" data-module="circle" data-i18n="dotStyle.circle">Chấm tròn</button>
                <button class="pill" data-module="rounded-bar" data-i18n="dotStyle.roundedBar">Gạch bo góc</button>
                <button class="pill" data-module="horizontal-bar" data-i18n="dotStyle.horizontalBar">Gạch ngang</button>
                <button class="pill" data-module="vertical-bar" data-i18n="dotStyle.verticalBar">Gạch dọc</button>
                <button class="pill" data-module="capsule" data-i18n="dotStyle.capsule">Viên thuốc</button>
              </div>
            </div>
            <div class="form-group">
              <label><span data-i18n="label.eyeStyle">Kiểu mắt</span></label>
              <div class="pill-row" id="eye-pills">
                <button class="pill active" data-eye="square" data-i18n="eyeStyle.square">Vuông classic</button>
                <button class="pill" data-eye="rounded" data-i18n="eyeStyle.rounded">Bo tròn</button>
                <button class="pill" data-eye="circle" data-i18n="eyeStyle.circle">Bubble / Dot</button>
                <button class="pill" data-eye="rounded-bar" data-i18n="eyeStyle.roundedBar">Gạch bo tròn</button>
                <button class="pill" data-eye="diamond" data-i18n="eyeStyle.diamond">Kim cương</button>
              </div>
            </div>
            <div class="form-group">
              <label><span data-i18n="label.ecc">Sửa lỗi</span></label>
              <div class="pill-row" id="ecc-pills">
                <button class="pill" data-ecc="L" data-i18n="ecc.low">Thấp</button>
                <button class="pill" data-ecc="M" data-i18n="ecc.medium">Vừa</button>
                <button class="pill active" data-ecc="H" data-i18n="ecc.high">Cao</button>
              </div>
            </div>
          </div>
          
          <div class="section">
            <div class="section-title" data-i18n="section.tune">Tinh chỉnh QR</div>
            <div class="form-group">
              <label><span data-i18n="label.dotGap">Khoảng cách chấm</span></label>
              <div class="opacity-row">
                <input type="range" id="qr-dot-gap" min="0" max="30" value="0" />
                <span id="dot-gap-label">0%</span>
              </div>
            </div>
            <div class="form-group">
              <label><span data-i18n="label.eyeThickness">Độ dày viền mắt QR</span></label>
              <div class="opacity-row">
                <input type="range" id="qr-eye-thickness" min="70" max="175" value="100" />
                <span id="eye-thickness-label">100%</span>
              </div>
            </div>
          </div>
          </div><!-- End qr-customize-section -->
        </div>

        <!-- Text Panel -->
        <div class="sidebar-panel" id="panel-text">
          <div class="section">
            <div class="section-title" data-i18n="section.addText">Thêm văn bản</div>
            <button class="toolbar-btn" style="width:100%;justify-content:center;margin-bottom:8px"
              onclick="addTextElement(getI18nText('text.heading'), 24, true)"><i class="fa-solid fa-plus"></i> <span data-i18n="action.addHeading">Thêm Tiêu đề</span></button>
            <button class="toolbar-btn" style="width:100%;justify-content:center;margin-bottom:8px"
              onclick="addTextElement(getI18nText('text.subheading'), 16, false)"><i class="fa-solid fa-plus"></i> <span data-i18n="action.addSubheading">Thêm Phụ đề</span></button>
            <button class="toolbar-btn" style="width:100%;justify-content:center"
              onclick="addTextElement(getI18nText('text.body'), 14, false)"><i class="fa-solid fa-plus"></i> <span data-i18n="action.addBodyText">Thêm Text</span></button>
          </div>
        </div>

        <!-- Elements Panel -->
        <div class="sidebar-panel" id="panel-elements">
          <div class="section">
            <div class="section-title" data-i18n="section.canvasBg">Màu nền Canvas</div>
            <div class="form-group">
              <div class="color-picker-row">
                <div class="color-input-wrap">
                  <input type="color" id="canvas-bg" value="#ffffff" />
                </div>
                <div class="color-presets" id="canvas-bg-presets">
                  <div class="color-dot active" style="background:#ffffff;border:1px solid #555" data-color="#ffffff">
                  </div>
                  <div class="color-dot" style="background:#f8fafc" data-color="#f8fafc"></div>
                  <div class="color-dot" style="background:#fef3c7" data-color="#fef3c7"></div>
                  <div class="color-dot" style="background:#dbeafe" data-color="#dbeafe"></div>
                  <div class="color-dot" style="background:#1e293b" data-color="#1e293b"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="section">
            <div class="section-title" data-i18n="section.canvasSize">Kích thước Canvas</div>
            <div class="form-row">
              <div class="form-group">
                <label><span data-i18n="label.width">Rộng</span></label>
                <input type="number" id="canvas-width" value="400" min="200" max="650" />
              </div>
              <div class="form-group">
                <label><span data-i18n="label.height">Cao</span></label>
                <input type="number" id="canvas-height" value="400" min="200" max="650" />
              </div>
            </div>
            <button class="toolbar-btn" style="width:100%;justify-content:center;margin-top:8px"
              onclick="updateCanvasSize()"><span data-i18n="action.apply">Áp dụng</span></button>
          </div>

          <div class="section">
            <div class="section-title" data-i18n="section.shapes">Hình dạng</div>
            <div class="shapes-grid" id="shapes-grid-main">
              <!-- Hiển thị 9 hình đầu tiên -->
            </div>
            <div class="shapes-grid shapes-grid-hidden" id="shapes-grid-extra" style="display:none;margin-top:8px;">
              <!-- Các hình còn lại -->
            </div>
            <button class="toolbar-btn" id="toggle-shapes-btn" style="width:100%;justify-content:center;margin-top:10px;" onclick="toggleMoreShapes()">
              <i class="fa-solid fa-chevron-down"></i> <span data-i18n="action.showMoreShapes">Xem thêm hình dạng</span>
            </button>
          </div>
        </div>

        <!-- Properties Panel (mobile auto-switch when selecting) -->
        <div class="sidebar-panel" id="panel-props">
          <div class="section">
            <div class="section-title" data-i18n="section.properties">Thuộc tính</div>
            <div id="element-props-host-mobile"></div>
          </div>
        </div>

        <!-- More actions (mobile only: opened via 3-dots button in toolbar) -->
        <div class="sidebar-panel" id="panel-more">
          <div class="section">
            <div class="section-title" data-i18n="section.actions">Thao tác</div>
            <div id="more-menu-host-mobile"></div>
          </div>
        </div>
      </div>
    </aside>

    <!-- MAIN AREA -->
    <main class="main-area">
      <div class="toolbar">
        <div class="toolbar-left">
          <div class="toolbar-group">
            <span class="toolbar-label" data-i18n="project.nameLabel">Tên File:</span>
            <input type="text" id="project-name-desktop" class="toolbar-input" value="" placeholder="Tên file" data-i18n-placeholder="project.namePlaceholder" />
          </div>
          <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomCanvas(-10)">−</button>
            <span class="zoom-value" id="zoom-value">100%</span>
            <button class="zoom-btn" onclick="zoomCanvas(10)">+</button>
            <button class="zoom-btn" onclick="zoomCanvas(0)" title="Reset 100%" data-i18n-title="zoom.reset">↺</button>
            <button class="zoom-btn" onclick="fitViewport()" title="Fit to view" data-i18n-title="zoom.fit"><i class="fa-solid fa-expand"></i></button>
          </div>
        </div>
        <div class="toolbar-left">
          <button class="toolbar-btn" onclick="alignSelected('left')" title="Căn trái" data-i18n-title="align.left"><i
              class="fa-solid fa-align-left"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('center-h')" title="Căn giữa ngang" data-i18n-title="align.centerH"><i
              class="fa-solid fa-align-center"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('right')" title="Căn phải" data-i18n-title="align.right"><i
              class="fa-solid fa-align-right"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('top')" title="Căn trên" data-i18n-title="align.top"><i
              class="fa-solid fa-arrow-up"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('center-v')" title="Căn giữa dọc" data-i18n-title="align.centerV"><i
              class="fa-solid fa-arrows-up-down"></i></button>
          <button class="toolbar-btn" onclick="alignSelected('bottom')" title="Căn dưới" data-i18n-title="align.bottom"><i
              class="fa-solid fa-arrow-down"></i></button>
        </div>
        <div class="toolbar-left">
          <button class="toolbar-btn" onclick="copyToClipboard()"><i class="fa-regular fa-copy"></i> <span data-i18n="action.copy">Copy</span></button>
          <button class="toolbar-btn primary" onclick="downloadImage()"><i class="fa-solid fa-download"></i> <span data-i18n="action.download">Tải xuống</span></button>
        </div>
      </div>

      <div class="canvas-wrapper" id="canvas-wrapper">
        <div class="canvas-stage" id="canvas-stage" style="width:400px;height:400px;">
          <div class="canvas" id="canvas" style="width:400px;height:400px;">
            <!-- Elements will be added here -->
          </div>
        </div>
      </div>
    </main>

    <!-- RIGHT PANEL - Element Properties -->
    <aside class="right-panel" id="right-panel">
      <div class="section">
        <div class="section-title" data-i18n="section.properties">Thuộc tính</div>
        <div id="element-props-host-desktop">
          <div id="element-props"></div>
        </div>
      </div>
    </aside>
  </div>

  <!-- FLOATING TOOLBAR (like Canva) -->
  <div class="floating-toolbar" id="floating-toolbar">
    <button class="floating-toolbar-btn" onclick="undo()" title="Hoàn tác (Ctrl+Z)" data-i18n-title="tooltip.undo">
      <i class="fa-solid fa-rotate-left"></i>
    </button>
    <button class="floating-toolbar-btn" onclick="redo()" title="Làm lại (Ctrl+Shift+Z)" data-i18n-title="tooltip.redo">
      <i class="fa-solid fa-rotate-right"></i>
    </button>
    <div class="floating-toolbar-divider"></div>
    <button class="floating-toolbar-btn" onclick="copySelected()" title="Copy (Ctrl+C)" data-i18n-title="tooltip.copy">
      <i class="fa-solid fa-copy"></i>
    </button>
    <button class="floating-toolbar-btn" onclick="duplicateSelected()" title="Nhân đôi (Ctrl+D)" data-i18n-title="tooltip.duplicate">
      <i class="fa-solid fa-clone"></i>
    </button>
    <button class="floating-toolbar-btn" onclick="deleteSelected()" title="Xóa (Delete)" data-i18n-title="tooltip.delete">
      <i class="fa-solid fa-trash"></i>
    </button>
    <div class="floating-toolbar-divider"></div>
    <div class="floating-toolbar-dropdown">
      <button class="floating-toolbar-btn" onclick="toggleLayerMenu()" title="Vị trí" data-i18n-title="tooltip.layer">
        <i class="fa-solid fa-layer-group"></i>
      </button>
      <div class="floating-toolbar-menu" id="layer-menu">
        <div class="floating-toolbar-menu-item" onclick="moveLayerUp(); hideLayerMenu();">
          <i class="fa-solid fa-arrow-up"></i> <span data-i18n="layer.up">Lên trên</span>
        </div>
        <div class="floating-toolbar-menu-item" onclick="moveLayerDown(); hideLayerMenu();">
          <i class="fa-solid fa-arrow-down"></i> <span data-i18n="layer.down">Xuống dưới</span>
        </div>
        <div class="floating-toolbar-menu-item" onclick="moveLayerToTop(); hideLayerMenu();">
          <i class="fa-solid fa-angles-up"></i> <span data-i18n="layer.top">Lên trên cùng</span>
        </div>
        <div class="floating-toolbar-menu-item" onclick="moveLayerToBottom(); hideLayerMenu();">
          <i class="fa-solid fa-angles-down"></i> <span data-i18n="layer.bottom">Xuống dưới cùng</span>
        </div>
      </div>
    </div>
    <div class="floating-toolbar-divider"></div>
    <button class="floating-toolbar-btn" onclick="pasteClipboard()" title="Dán (Ctrl+V)" data-i18n-title="tooltip.paste">
      <i class="fa-solid fa-paste"></i>
    </button>
    <div class="floating-toolbar-dropdown">
      <button class="floating-toolbar-btn more-btn" onclick="toggleMoreMenu()" title="Thêm" data-i18n-title="tooltip.more">
        <i class="fa-solid fa-ellipsis"></i>
      </button>
      <div id="more-menu-host-desktop">
        <div class="floating-toolbar-menu" id="more-menu" style="min-width:200px;right:0;left:auto;transform:none;">
          <div class="floating-toolbar-menu-item" onclick="selectAllElements(); hideMoreMenu();">
            <i class="fa-solid fa-check-double"></i> <span data-i18n="action.selectAll">Chọn tất cả</span>
            <span style="margin-left:auto;font-size:10px;color:#666;">Ctrl+A</span>
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('left'); hideMoreMenu();">
            <i class="fa-solid fa-align-left"></i> <span data-i18n="align.left">Canh trái</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('center-h'); hideMoreMenu();">
            <i class="fa-solid fa-align-center"></i> <span data-i18n="align.centerH">Canh giữa ngang</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('right'); hideMoreMenu();">
            <i class="fa-solid fa-align-right"></i> <span data-i18n="align.right">Canh phải</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('top'); hideMoreMenu();">
            <i class="fa-solid fa-arrow-up"></i> <span data-i18n="align.top">Canh trên</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('center-v'); hideMoreMenu();">
            <i class="fa-solid fa-arrows-up-down"></i> <span data-i18n="align.centerV">Canh giữa dọc</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="alignSelected('bottom'); hideMoreMenu();">
            <i class="fa-solid fa-arrow-down"></i> <span data-i18n="align.bottom">Canh dưới</span>
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="distributeSelected('horizontal'); hideMoreMenu();">
            <i class="fa-solid fa-grip-lines-vertical"></i> <span data-i18n="distribute.horizontal">Phân bố ngang</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="distributeSelected('vertical'); hideMoreMenu();">
            <i class="fa-solid fa-grip-lines"></i> <span data-i18n="distribute.vertical">Phân bố dọc</span>
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="flipSelected('horizontal'); hideMoreMenu();">
            <i class="fa-solid fa-arrows-left-right"></i> <span data-i18n="flip.horizontal">Lật ngang</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="flipSelected('vertical'); hideMoreMenu();">
            <i class="fa-solid fa-arrows-up-down-left-right"></i> <span data-i18n="flip.vertical">Lật dọc</span>
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="resetRotation(); hideMoreMenu();">
            <i class="fa-solid fa-rotate"></i> <span data-i18n="rotate.reset">Reset xoay (0°)</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="rotateSelected(90); hideMoreMenu();">
            <i class="fa-solid fa-rotate-right"></i> <span data-i18n="rotate.90">Xoay 90°</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="rotateSelected(-90); hideMoreMenu();">
            <i class="fa-solid fa-rotate-left"></i> <span data-i18n="rotate.-90">Xoay -90°</span>
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="toggleLockSelected(); hideMoreMenu();">
            <i class="fa-solid fa-lock"></i> <span data-i18n="lock.toggle">Khóa / Mở khóa</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="fitToCanvas(); hideMoreMenu();">
            <i class="fa-solid fa-expand"></i> <span data-i18n="canvas.fit">Vừa canvas</span>
          </div>
          <div class="floating-toolbar-menu-item" onclick="centerInCanvas(); hideMoreMenu();">
            <i class="fa-solid fa-crosshairs"></i> <span data-i18n="canvas.center">Đặt vào giữa</span>
          </div>
          <div style="height:1px;background:rgba(255,255,255,0.1);margin:4px 0;"></div>
          <div class="floating-toolbar-menu-item" onclick="openExportModal(); hideMoreMenu();">
            <i class="fa-solid fa-download"></i> <span data-i18n="action.download">Tải xuống</span>
            <span style="margin-left:auto;font-size:10px;color:#666;">Ctrl+S</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- EXPORT MODAL -->
  <div class="modal-overlay" id="export-modal" style="display:none;">
    <div class="modal" style="max-width:520px;">
      <div class="modal-header">
        <h3 data-i18n="export.title">Tải xuống thiết kế</h3>
        <button class="modal-close" onclick="closeExportModal()">×</button>
      </div>
      <div class="modal-body">
        <div class="export-preview">
          <canvas id="export-preview-canvas"></canvas>
        </div>
        <div class="export-options">
          <div class="form-group">
            <label data-i18n="export.format">Định dạng</label>
            <div class="pill-row" id="format-pills">
              <button class="pill active" data-format="png">PNG</button>
              <button class="pill" data-format="jpg">JPG</button>
              <button class="pill" data-format="svg">SVG</button>
              <button class="pill" data-format="pdf">PDF</button>
            </div>
          </div>
          <div class="form-group">
            <label data-i18n="export.filename">Tên file</label>
            <input type="text" id="export-filename" value="" autocomplete="off" spellcheck="false" />
            <div class="export-filename-hint" data-i18n="export.filenameHint">Tên file sẽ tự thêm đuôi theo định dạng (png/jpg/svg)</div>
          </div>
          <div class="form-group">
            <label data-i18n="export.size">Kích thước xuất</label>
            <div class="export-size-mode">
              <div class="pill-row" style="margin-bottom:12px;">
                <button class="pill active" id="size-mode-scale" onclick="setSizeMode('scale')" data-i18n="export.sizeMode.scale">Tỷ lệ</button>
                <button class="pill" id="size-mode-custom" onclick="setSizeMode('custom')" data-i18n="export.sizeMode.custom">Tùy chỉnh</button>
              </div>
              <div id="scale-options">
                <div class="pill-row" id="size-pills">
                  <button class="pill" data-scale="1">1x</button>
                  <button class="pill active" data-scale="2">2x</button>
                  <button class="pill" data-scale="3">3x</button>
                  <button class="pill" data-scale="4">4x</button>
                </div>
              </div>
              <div id="custom-size-options" style="display:none;">
                <div class="form-row">
                  <div class="form-group">
                    <label style="font-size:11px;color:#888;" data-i18n="export.widthPx">Rộng (px)</label>
                    <input type="number" id="export-width" value="800" min="100" max="4096" onchange="updateExportSize()" />
                  </div>
                  <div class="form-group">
                    <label style="font-size:11px;color:#888;" data-i18n="export.heightPx">Cao (px)</label>
                    <input type="number" id="export-height" value="800" min="100" max="4096" onchange="updateExportSize()" />
                  </div>
                  <div class="form-group" style="align-items:center;padding-top:20px;">
                    <button class="pill" id="lock-ratio-btn" onclick="toggleLockRatio()" title="Giữ tỷ lệ" data-i18n-title="export.lockRatio" style="padding:8px 10px;">
                      <i class="fa-solid fa-lock"></i>
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="form-group" id="quality-group">
            <label data-i18n="export.quality">Chất lượng</label>
            <div class="opacity-row">
              <input type="range" id="export-quality" min="50" max="100" value="92" />
              <span id="quality-label">92%</span>
            </div>
          </div>
          <div class="form-group">
            <label data-i18n="export.canvasRadius">Bo góc canvas</label>
            <div class="opacity-row">
              <input type="range" id="export-radius" min="0" max="100" value="8" />
              <span id="radius-label">8px</span>
            </div>
          </div>
          <div class="export-info">
            <i class="fa-solid fa-image" style="margin-right:6px;color:#7c3aed;"></i>
            <span id="export-size-info">800 × 800 px</span>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="toolbar-btn" onclick="closeExportModal()" data-i18n="action.cancel">Hủy</button>
        <button class="toolbar-btn primary" onclick="doExport()"><i class="fa-solid fa-download"></i> <span data-i18n="action.download">Tải xuống</span></button>
      </div>
    </div>
  </div>

  <script>
    // State
    let elements = [];
    let selectedIds = new Set();
    let dragging = null;
    let resizing = null;
    let rotating = null; // For rotation handle
    let canvasZoom = 100;
    let currentQRType = 'url';
    let currentQRVersion = 1;
    let currentModuleStyle = 'rounded-square';
    let currentEyeStyle = 'square';
    let activeGuides = [];
    let selectionBox = null;
    let selectionStart = null;
    let isSelecting = false;
    let qrImageCache = null; // Cache QR image to avoid re-fetching
    let qrLogoData = null; // Logo for QR center
    let qrLogoSize = 25; // Logo size percentage
    let qrLogoRadius = 25; // Logo corner rounding percentage
    let qrDotGap = 0; // Gap between dots
    let qrEyeThickness = 100; // Eye thickness
    let canvasSelected = false; // Track if canvas itself is selected
    let wrapperSelectionBox = null; // Selection box for wrapper area
    let canvasRotation = 0; // Rotation of canvas in degrees
    let canvasOverlay = null; // Overlay with handles for canvas
    let canvasResizing = null; // State for canvas resize drag
    let canvasRotating = null; // State for canvas rotate drag
    let selectionStartedOnWrapper = false;
    let selectionStartedOnCanvas = false;
    let lastSelectionPoint = null;
    let clipboard = []; // Clipboard for copy/paste
    let history = []; // Undo history
    let historyIndex = -1; // Current position in history
    let multiSelectBox = null; // Bounding box for multi-selection
    let multiSelectDragging = null; // Multi-select drag state
    let multiSelectResizing = null; // Multi-select resize state
    let emptyQRNotice = null; // CTA when QR is missing
    // Rich font catalog (lazy-loaded via Google Fonts when selected)
    // Vietnamese-optimized fonts are marked - prioritizing fonts with full Vietnamese diacritics support
    const fontCatalog = [
      // ===== TOP VIETNAMESE FONTS (Best diacritics support) =====
      'Be Vietnam Pro','Quicksand','Nunito','Open Sans','Roboto','Montserrat','Poppins','Inter','Mulish','Raleway',
      'Josefin Sans','Rubik','Work Sans','Lato','Mukta','Source Sans Pro','Barlow','DM Sans','Public Sans','Jost',
      'Lexend','Manrope','IBM Plex Sans','Cabin','Heebo','Assistant','Hind','Outfit','Figtree','Albert Sans',
      
      // ===== DISPLAY & DECORATIVE FONTS (Vietnamese support) =====
      'Playfair Display','Dancing Script','Pacifico','Lobster','Caveat','Satisfy','Great Vibes','Courgette',
      'Parisienne','Amatic SC','Shadows Into Light','Handlee','Architects Daughter','Indie Flower','Kalam',
      'Patrick Hand','Permanent Marker','Rock Salt','Yellowtail','Allura','Alex Brush','Tangerine','Sacramento',
      
      // ===== SERIF FONTS (Vietnamese support) =====
      'Noto Serif','Merriweather','PT Serif','Libre Baskerville','Crimson Pro','Cormorant Garamond','Spectral',
      'Vollkorn','Bitter','Lora','EB Garamond','Arvo','Source Serif Pro','Alegreya','Cardo','Literata',
      'Bree Serif','Rokkitt','Noticia Text','Domine','Crete Round','Young Serif','Fraunces','Newsreader',
      
      // ===== SANS-SERIF MODERN =====
      'Catamaran','Fira Sans','Space Grotesk','Karla','Exo 2','Titillium Web','Teko','Archivo','Urbanist',
      'Sora','Syne','Maven Pro','Chivo','Overpass','Oxygen','Comfortaa','Josefin Slab','Lexend Deca',
      'Atkinson Hyperlegible','Geologica','Onest','Bricolage Grotesque','Instrument Sans','Epilogue','Gabarito',
      
      // ===== CONDENSED & DISPLAY =====
      'Barlow Condensed','Barlow Semi Condensed','Archivo Narrow','Bebas Neue','Oswald','Anton','Archivo Black',
      'Alfa Slab One','Abril Fatface','Righteous','Bungee','Fredoka','Grandstander','Rowdies','Unbounded',
      
      // ===== MONOSPACE (Coding fonts) =====
      'Space Mono','Inconsolata','JetBrains Mono','Fira Code','Source Code Pro','Ubuntu Mono','Roboto Mono',
      'IBM Plex Mono','DM Mono','Overpass Mono','Azeret Mono','Anonymous Pro','Cousine','Cutive Mono',
      
      // ===== ASIAN LANGUAGE SUPPORT =====
      'Noto Sans','Noto Sans Display','Noto Sans Mono','Noto Sans JP','Noto Serif JP',
      'M PLUS 1p','M PLUS Rounded 1c','Sawarabi Gothic','Nanum Gothic','Nanum Myeongjo',
      
      // ===== ELEGANT & PREMIUM =====
      'Cormorant','Bodoni Moda','Piazzolla','Brygada 1918','Alegreya Sans','Petrona','Signika',
      'Baloo 2','Kanit','Sarabun','Prompt','Plus Jakarta Sans','Red Hat Display','Red Hat Text','Zilla Slab',
      
      // ===== VIETNAMESE SPECIALTY =====
      'Tinos','Arimo','Libre Franklin','Asap','Signika Negative','Martel','Karma',
      'Hind Siliguri','Hind Madurai','Hind Vadodara','Schibsted Grotesk','Ubuntu',
      'Slabo 27px','Sanchez','Antic Slab','Exo','Tourney'
    ];

    function loadGoogleFont(font) {
      if (!font) return;
      const id = `font-${font.replace(/\s+/g, '-')}`;
      if (document.getElementById(id)) return;
      const link = document.createElement('link');
      link.id = id;
      link.rel = 'stylesheet';
      const family = font.replace(/\s+/g, '+');
      link.href = `https://fonts.googleapis.com/css2?family=${family}:wght@400;600;700&display=swap`;
      document.head.appendChild(link);
    }

    // Convert RGB/RGBA to hex
    function rgbToHex(color) {
      if (!color) return '#ffffff';
      if (color.startsWith('#')) return color;
      const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!match) return '#ffffff';
      const r = parseInt(match[1]).toString(16).padStart(2, '0');
      const g = parseInt(match[2]).toString(16).padStart(2, '0');
      const b = parseInt(match[3]).toString(16).padStart(2, '0');
      return `#${r}${g}${b}`;
    }

    const canvas = document.getElementById('canvas');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    const canvasStage = document.getElementById('canvas-stage');
    const MIN_CANVAS_SIZE = 200;
    const MAX_CANVAS_SIZE = 650;

    function clampCanvasDimension(value) {
      const parsed = parseInt(value, 10);
      if (Number.isNaN(parsed)) return MIN_CANVAS_SIZE;
      return Math.min(MAX_CANVAS_SIZE, Math.max(MIN_CANVAS_SIZE, parsed));
    }

    function syncCanvasSizeInputs(width, height) {
      const widthInput = document.getElementById('canvas-width');
      const heightInput = document.getElementById('canvas-height');
      if (widthInput) widthInput.value = width;
      if (heightInput) heightInput.value = height;
    }
    
    function normalizeRotation(value) {
      const num = Number(value);
      return Number.isFinite(num) ? num : 0;
    }

    // Update floating toolbar position to align with canvas center
    function updateToolbarPosition() {
      const toolbar = document.getElementById('floating-toolbar');
      if (!toolbar) return;

      const targetRect = (canvasStage || canvas).getBoundingClientRect();
      const canvasCenter = targetRect.left + targetRect.width / 2;
      const toolbarWidth = toolbar.offsetWidth || 0;
      const half = toolbarWidth / 2;
      const vw = document.documentElement.clientWidth;
      const minX = 12 + half;
      const maxX = vw - 12 - half;
      const clampedCenter = Math.max(minX, Math.min(maxX, canvasCenter));

      if (window.innerWidth <= 768) {
        toolbar.style.left = clampedCenter + 'px';
        toolbar.style.transform = 'translateX(-50%)';
      } else {
        toolbar.style.transform = 'none';
        toolbar.style.left = (clampedCenter - half) + 'px';
      }
    }

    // Keep the canvas visually stable in the viewport when its size changes
    function keepCanvasViewStable(oldRect, newRect) {
      const dx = (newRect.width - oldRect.width) / 2;
      const dy = (newRect.height - oldRect.height) / 2;
      if (dx === 0 && dy === 0) return;
      canvasWrapper.scrollLeft += dx;
      canvasWrapper.scrollTop += dy;
    }

    function updateCanvasStageSize() {
      const stage = canvasStage;
      if (!stage) return;
      const baseW = parseInt(canvas.style.width) || 400;
      const baseH = parseInt(canvas.style.height) || 400;
      const scale = canvasZoom / 100;
      stage.style.width = (baseW * scale) + 'px';
      stage.style.height = (baseH * scale) + 'px';
    }

    // Center stage in view using scroll (works with transform-zoom + real scaled bounds)
    function getBottomOverlayInset() {
      const panel = document.getElementById('right-panel');
      if (!panel) return 0;
      const cs = window.getComputedStyle(panel);
      if (cs.display === 'none' || cs.visibility === 'hidden' || cs.position !== 'fixed') return 0;
      const wrapperRect = canvasWrapper.getBoundingClientRect();
      const panelRect = panel.getBoundingClientRect();
      // Amount of wrapper's bottom area covered by the fixed panel
      return Math.max(0, wrapperRect.bottom - panelRect.top);
    }

    function centerCanvasInView() {
      const wrapperRect = canvasWrapper.getBoundingClientRect();
      const stage = canvasStage || canvas;
      const stageRect = stage.getBoundingClientRect();
      const bottomInset = getBottomOverlayInset();
      const visibleH = Math.max(0, canvasWrapper.clientHeight - bottomInset);

      const targetLeft = (stageRect.left - wrapperRect.left) + canvasWrapper.scrollLeft - (canvasWrapper.clientWidth - stageRect.width) / 2;
      const targetTop = (stageRect.top - wrapperRect.top) + canvasWrapper.scrollTop - (visibleH - stageRect.height) / 2;

      canvasWrapper.scrollLeft = Math.max(0, targetLeft);
      canvasWrapper.scrollTop = Math.max(0, targetTop);
    }

    // Create guides container
    let guidesContainer = null;

    function initGuidesContainer() {
      if (!guidesContainer) {
        guidesContainer = document.createElement('div');
        guidesContainer.className = 'guides-container';
        canvas.appendChild(guidesContainer);
      }
    }

    function updateCanvasTransform() {
      canvas.style.transform = `scale(${canvasZoom / 100})`;
      updateCanvasStageSize();
      renderCanvasSelectionOverlay();
      updateHandleScales(); // Update handle sizes to compensate for zoom
    }
    
    // Update handles to maintain consistent visual size regardless of zoom
    function updateHandleScales() {
      const inverseScale = 100 / canvasZoom;
      
      // Update resize handles
      document.querySelectorAll('.resize-handle').forEach(handle => {
        const pos = handle.dataset.handle;
        let transform = `scale(${inverseScale})`;
        // Add translateX/Y for edge handles
        if (pos === 'n' || pos === 's') {
          transform += ' translateX(-50%)';
        } else if (pos === 'w' || pos === 'e') {
          transform += ' translateY(-50%)';
        }
        handle.style.transform = transform;
      });
      
      // Update rotation handles
      document.querySelectorAll('.rotation-handle').forEach(handle => {
        handle.style.transform = `translateX(-50%) scale(${inverseScale})`;
      });
      
      document.querySelectorAll('.rotation-line').forEach(line => {
        line.style.transform = `translateX(-50%) scaleY(${inverseScale})`;
      });
      
      // Update multi-select box handles
      document.querySelectorAll('.multi-select-box .ms-handle').forEach(handle => {
        const classList = handle.classList;
        let transform = `scale(${inverseScale})`;
        if (classList.contains('n') || classList.contains('s')) {
          transform += ' translateX(-50%)';
        } else if (classList.contains('w') || classList.contains('e')) {
          transform += ' translateY(-50%)';
        }
        handle.style.transform = transform;
      });
      
      // Update multi-select box border width
      if (multiSelectBox) {
        multiSelectBox.style.borderWidth = `${Math.max(1, 2 / (canvasZoom / 100))}px`;
      }
      
      // Update element selection outline to maintain consistent width
      document.querySelectorAll('.canvas-element.selected').forEach(el => {
        const outlineWidth = Math.max(1, 2 / (canvasZoom / 100));
        el.style.outlineWidth = `${outlineWidth}px`;
      });
    }

    function initSelectionBox() {
      if (!selectionBox) {
        selectionBox = document.createElement('div');
        selectionBox.className = 'selection-box';
        selectionBox.style.display = 'none';
        canvas.appendChild(selectionBox);
      }
      if (!wrapperSelectionBox) {
        wrapperSelectionBox = document.createElement('div');
        wrapperSelectionBox.className = 'wrapper-selection-box';
        wrapperSelectionBox.style.display = 'none';
        canvasWrapper.appendChild(wrapperSelectionBox);
      }
    }

    function removeCanvasSelectionOverlay() {
      if (canvasOverlay && canvasOverlay.parentElement) {
        canvasOverlay.remove();
      }
      canvasOverlay = null;
    }

    function renderCanvasSelectionOverlay() {
      removeCanvasSelectionOverlay();
      if (!canvasSelected) return;
      const wrapperRect = canvasWrapper.getBoundingClientRect();
      const stage = canvasStage || canvas;
      const rect = stage.getBoundingClientRect();
      const overlay = document.createElement('div');
      overlay.className = 'canvas-selection-overlay';
      overlay.style.left = (rect.left - wrapperRect.left + canvasWrapper.scrollLeft) + 'px';
      overlay.style.top = (rect.top - wrapperRect.top + canvasWrapper.scrollTop) + 'px';
      overlay.style.width = rect.width + 'px';
      overlay.style.height = rect.height + 'px';

      const handles = ['nw', 'ne', 'sw', 'se'];
      handles.forEach(pos => {
        const h = document.createElement('div');
        h.className = `canvas-handle ${pos}`;
        h.dataset.canvasHandle = pos;
        overlay.appendChild(h);
      });

      // Rotation handle removed - canvas rotation is disabled

      canvasWrapper.appendChild(overlay);
      canvasOverlay = overlay;
    }

    function highlightCanvasSelection() {
      canvasSelected = true;
      canvas.style.outline = '2px solid #10b981';
      canvas.style.outlineOffset = '4px';
      renderCanvasSelectionOverlay();
      updateFloatingToolbar();
    }

    // Show snap guides
    function showGuide(type, position) {
      if (!guidesContainer) {
        console.warn('Guides container not initialized');
        return;
      }

      const guide = document.createElement('div');
      guide.className = `guide ${type}`;
      guide.style.pointerEvents = 'none';

      if (type === 'horizontal') {
        guide.style.top = position + 'px';
        guide.style.height = '2px';
        guide.style.left = '0';
        guide.style.right = '0';
        guide.style.width = '100%';
      } else {
        guide.style.left = position + 'px';
        guide.style.width = '2px';
        guide.style.top = '0';
        guide.style.bottom = '0';
        guide.style.height = '100%';
      }

      guidesContainer.appendChild(guide);
      activeGuides.push(guide);
    }

    // Clear guides
    function clearGuides() {
      if (activeGuides.length === 0) return;

      activeGuides.forEach(g => {
        if (g && g.parentElement) {
          g.remove();
        }
      });
      activeGuides = [];
    }

    // Project management
    const PROJECTS_KEY = 'qr_studio_projects';
    let currentProjectId = null;
    let autoSaveInterval = null;
    
    function getProjectIdFromURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('project');
    }

    function normalizeInitialQRType(value) {
      const v = String(value || '').trim().toLowerCase();
      if (!v) return null;

      const map = {
        url: 'url',
        text: 'text',
        wifi: 'wifi',
        email: 'email',
        phone: 'phone',
        sms: 'sms',
        location: 'location',
        vcard: 'vcard',
        vcf: 'vcard',
        event: 'event',
        calendar: 'event',
        schedule: 'event',
        appointment: 'event',
        vietqr: 'vietqr',
        crypto: 'crypto',
        file: 'file',
      };

      return map[v] || null;
    }

    function getInitialQRTypeFromURL() {
      const injected = normalizeInitialQRType(window.__QRIO_INITIAL_QR_TYPE);
      if (injected) return injected;

      try {
        const params = new URLSearchParams(window.location.search);
        const qp = params.get('type') || params.get('qr_type') || params.get('qrType');
        const t = normalizeInitialQRType(qp);
        if (t) return t;
      } catch {
        // ignore
      }

      const parts = String(window.location.pathname || '')
        .split('/')
        .filter(Boolean);

      if (parts.length >= 2 && parts[0] === 'generate') {
        return normalizeInitialQRType(parts[1]);
      }

      return null;
    }

    function applyInitialQRType(initialType) {
      const t = normalizeInitialQRType(initialType);
      if (!t) return false;
      const btn = document.querySelector(`.type-btn[data-type="${t}"]`);
      if (!btn) return false;
      btn.click();
      return true;
    }
    
    function loadProjectsFromStorage() {
      try {
        return JSON.parse(localStorage.getItem(PROJECTS_KEY) || '[]');
      } catch {
        return [];
      }
    }
    
    function saveProjectsToStorage(projects) {
      localStorage.setItem(PROJECTS_KEY, JSON.stringify(projects));
    }
    
    function loadProject(projectId) {
      const projects = loadProjectsFromStorage();
      const project = projects.find(p => p.id === projectId);
      if (!project) return false;
      
      console.log('Loading project:', project.name);
      
      // Restore canvas settings
      if (project.canvasWidth && project.canvasHeight) {
        const canvas = document.getElementById('canvas');
        const clampedWidth = clampCanvasDimension(project.canvasWidth);
        const clampedHeight = clampCanvasDimension(project.canvasHeight);
        canvas.style.width = clampedWidth + 'px';
        canvas.style.height = clampedHeight + 'px';
        syncCanvasSizeInputs(clampedWidth, clampedHeight);
      }
      
      if (project.canvasBgColor) {
        const canvas = document.getElementById('canvas');
        canvas.style.backgroundColor = project.canvasBgColor;
      }
      
      // Restore file name
      if (project.name) {
        setProjectNameValue(project.name);
      }
      
      // Clear existing elements
      elements.length = 0;
      const canvas = document.getElementById('canvas');
      canvas.querySelectorAll('.element').forEach(el => el.remove());
      
      // Restore elements
      if (project.elements && project.elements.length > 0) {
        project.elements.forEach(elData => {
          if (elData.type === 'qr') {
            // Restore QR element
            qrText = elData.qrText || 'https://example.com';
            addQRElement();
            const el = elements[elements.length - 1];
            Object.assign(el, elData);
            generateQR();
          } else if (elData.type === 'text') {
            addTextElement(elData.text || 'Text');
            const el = elements[elements.length - 1];
            Object.assign(el, elData);
          } else if (elData.type === 'shape') {
            addShapeElement(elData.shapeType || 'rect');
            const el = elements[elements.length - 1];
            Object.assign(el, elData);
          }
        });
        renderElements();
      }
      
      // Update QR panel visibility based on whether QR exists
      updateQRPanelVisibility();
      
      currentProjectId = projectId;
      
      // Clear and reinitialize history
      history = [snapshotState()];
      historyIndex = 0;
      
      return true;
    }

    function getProjectNameValue() {
      const desktop = document.getElementById('project-name-desktop');
      const mobile = document.getElementById('project-name-mobile');
      const fallbackName = (typeof t === 'function') ? t('project.defaultName') : 'qr_design';
      return (desktop?.value || mobile?.value || fallbackName).trim() || fallbackName;
    }

    function setProjectNameValue(name) {
      const val = (name || '').toString();
      const desktop = document.getElementById('project-name-desktop');
      const mobile = document.getElementById('project-name-mobile');
      if (desktop) desktop.value = val;
      if (mobile) mobile.value = val;
    }

    function syncProjectNameInputs() {
      const desktop = document.getElementById('project-name-desktop');
      const mobile = document.getElementById('project-name-mobile');
      if (!desktop || !mobile) return;
      const syncToOther = (src, dst) => {
        dst.value = src.value;
      };
      desktop.addEventListener('input', () => syncToOther(desktop, mobile));
      mobile.addEventListener('input', () => syncToOther(mobile, desktop));
    }
    
    function saveCurrentProject() {
      if (!currentProjectId) {
        // Create new project if none exists
        currentProjectId = 'project-' + Date.now();
      }
      
      const canvas = document.getElementById('canvas');
      const clampedWidth = clampCanvasDimension(canvas.style.width);
      const clampedHeight = clampCanvasDimension(canvas.style.height);
      canvas.style.width = clampedWidth + 'px';
      canvas.style.height = clampedHeight + 'px';
      syncCanvasSizeInputs(clampedWidth, clampedHeight);
      
      // Generate thumbnail from QR image cache
      let thumbnail = null;
      if (qrImageCache) {
        thumbnail = qrImageCache; // Use the QR image as thumbnail
      }
      
      const projectData = {
        id: currentProjectId,
        name: getProjectNameValue(),
        canvasWidth: clampedWidth,
        canvasHeight: clampedHeight,
        canvasBgColor: canvas.style.backgroundColor,
        elements: elements.map(el => ({...el})),
        thumbnail: thumbnail,
        updatedAt: new Date().toISOString()
      };
      
      const projects = loadProjectsFromStorage();
      const existingIndex = projects.findIndex(p => p.id === currentProjectId);
      
      if (existingIndex >= 0) {
        projectData.createdAt = projects[existingIndex].createdAt;
        projects[existingIndex] = projectData;
      } else {
        projectData.createdAt = new Date().toISOString();
        projects.unshift(projectData);
      }
      
      saveProjectsToStorage(projects);
      showAutoSaveIndicator();
      console.log('Project saved:', projectData.name);
    }
    
    function showAutoSaveIndicator() {
      // Create or update auto-save indicator - subtle text only
      let indicator = document.getElementById('autosave-indicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'autosave-indicator';
        indicator.style.cssText = `
          position: fixed;
          bottom: 16px;
          right: 16px;
          color: #666;
          font-size: 11px;
          z-index: 10000;
          opacity: 0;
          transition: opacity 0.3s;
        `;
        document.body.appendChild(indicator);
      }
      
      indicator.textContent = (typeof t === 'function') ? t('autosave.saved') : 'Saved';
      indicator.style.opacity = '1';
      
      setTimeout(() => {
        indicator.style.opacity = '0';
      }, 1500);
    }
    
    function startAutoSave() {
      // Stop any existing interval
      if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
      }
      
      // Auto-save every 10 seconds
      autoSaveInterval = setInterval(() => {
        saveCurrentProject();
      }, 10000);
      
      console.log('Auto-save started (every 10 seconds)');
    }
    
    function stopAutoSave() {
      if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
      }
    }
    
    // Save before leaving
    window.addEventListener('beforeunload', () => {
      saveCurrentProject();
    });

    // Initialize
    function init() {
      console.log('===== INIT STARTED =====');

      // Apply language from home page selection
      const LANG_KEY = 'qr_lang';
      const detectDefaultLang = () => {
        const raw = (navigator.language || '').toLowerCase();
        if (raw.startsWith('vi')) return 'vi';
        if (raw.startsWith('zh')) return 'zh';
        if (raw.startsWith('hi')) return 'hi';
        if (raw.startsWith('es')) return 'es';
        if (raw.startsWith('fr')) return 'fr';
        if (raw.startsWith('ar')) return 'ar';
        if (raw.startsWith('pt')) return 'pt';
        if (raw.startsWith('ru')) return 'ru';
        if (raw.startsWith('id') || raw.startsWith('in')) return 'id';
        return 'en';
      };

      const I18N = {
          vi: {
            'meta.title': 'Qrio - Trình chỉnh sửa mã QR miễn phí',
            'meta.description': 'Thiết kế mã QR chuyên nghiệp với trình chỉnh sửa mạnh mẽ. Tùy chỉnh màu sắc, kiểu dáng, thêm logo và xuất ảnh HD.',
            'nav.home': 'Về trang chủ',
            'tabs.qr': 'QR Code',
            'tabs.text': 'Text',
            'tabs.elements': 'Thêm',
            'empty.noQr': 'Chưa có mã QR',
            'empty.noQrHint': 'Tạo mã QR để bắt đầu thiết kế',
            'empty.createQr': 'Tạo mã QR',
            'qr.type': 'Loại QR',
            'qr.complexity': 'Độ phức tạp',
            'qr.version': 'Phiên bản',
            'qr.content': 'Nội dung',
            'qr.gridUnit': 'ô vuông',
            'wifi.security.wpa': 'WPA/WPA2',
            'wifi.security.wep': 'WEP',
            'bank.scheme': 'Phương thức',
            'bank.scheme.vietqr': 'VietQR (VN)',
            'bank.scheme.sepa': 'SEPA (EPC)',
            'action.copy': 'Sao chép',
            'action.paste': 'Dán',
            'action.duplicate': 'Nhân đôi',
            'action.delete': 'Xóa',
            'action.undo': 'Hoàn tác',
            'action.redo': 'Làm lại',
            'action.download': 'Tải xuống',
            'action.cancel': 'Hủy',
            'action.selectAll': 'Chọn tất cả',
            'action.uploadLogo': 'Tải logo lên',
            'action.remove': 'Xóa',
            'action.currentLocation': 'Vị trí hiện tại',
            'action.addHeading': 'Thêm Tiêu đề',
            'action.addSubheading': 'Thêm Phụ đề',
            'action.addBodyText': 'Thêm Text',
            'action.apply': 'Áp dụng',
            'action.showMoreShapes': 'Xem thêm hình dạng',
            'action.showLessShapes': 'Thu gọn',
            'layer.up': 'Lên trên',
            'layer.down': 'Xuống dưới',
            'layer.top': 'Lên trên cùng',
            'layer.bottom': 'Xuống dưới cùng',

            'tooltip.undo': 'Hoàn tác (Ctrl+Z)',
            'tooltip.redo': 'Làm lại (Ctrl+Shift+Z)',
            'tooltip.copy': 'Sao chép (Ctrl+C)',
            'tooltip.duplicate': 'Nhân đôi (Ctrl+D)',
            'tooltip.delete': 'Xóa (Delete)',
            'tooltip.layer': 'Vị trí',
            'tooltip.paste': 'Dán (Ctrl+V)',
            'tooltip.more': 'Thêm',

            'distribute.horizontal': 'Phân bố ngang',
            'distribute.vertical': 'Phân bố dọc',
            'flip.horizontal': 'Lật ngang',
            'flip.vertical': 'Lật dọc',
            'rotate.reset': 'Reset xoay (0°)',
            'rotate.90': 'Xoay 90°',
            'rotate.-90': 'Xoay -90°',
            'lock.toggle': 'Khóa / Mở khóa',
            'canvas.fit': 'Vừa canvas',
            'canvas.center': 'Đặt vào giữa',

            'export.title': 'Tải xuống thiết kế',
            'export.filename': 'Tên file',
            'export.filenameHint': 'Tên file sẽ tự thêm đuôi theo định dạng (png/jpg/svg)',
            'export.format': 'Định dạng',
            'export.size': 'Kích thước xuất',
            'export.sizeMode.scale': 'Tỷ lệ',
            'export.sizeMode.custom': 'Tùy chỉnh',
            'export.widthPx': 'Rộng (px)',
            'export.heightPx': 'Cao (px)',
            'export.lockRatio': 'Giữ tỷ lệ',
            'export.quality': 'Chất lượng',
            'export.canvasRadius': 'Bo góc canvas',

            'props.canvasTitle': 'Canvas',
            'props.selectHint': 'Chọn một phần tử trên canvas để xem và chỉnh sửa thuộc tính.',
            'props.width': 'Chiều rộng',
            'props.height': 'Chiều cao',
            'props.size': 'Kích thước',
            'props.background': 'Màu nền',
            'props.stroke': 'Viền',
            'props.cornerRadius': 'Bo góc',
            'props.rotation': 'Góc xoay (°)',
            'props.opacity': 'Độ trong suốt',
            'props.text.content': 'Nội dung',
            'props.text.inlineEditHint': 'nhấp đúp để sửa trực tiếp',
            'props.text.font': 'Font chữ',
            'props.text.clickToChooseHint': 'nhấp để chọn',
            'props.text.searchFont': 'Tìm font...',
            'props.text.fontSize': 'Cỡ chữ',
            'props.text.style': 'Kiểu chữ',
            'props.text.bold': 'In đậm',
            'props.text.italic': 'In nghiêng',
            'props.text.underline': 'Gạch chân',
            'props.text.shadow': 'Đổ bóng',
            'props.text.color': 'Màu chữ',
            'props.text.background': 'Nền chữ',

            // Shapes (basic + Phosphor)
            'shape.rect': 'Vuông',
            'shape.rounded': 'Bo góc',
            'shape.circle': 'Tròn',
            'shape.pill': 'Pill',
            'shape.triangle': 'Tam giác',
            'shape.triangle-down': 'Tam giác ngược',
            'shape.diamond': 'Kim cương',
            'shape.pentagon': 'Ngũ giác',
            'shape.hexagon': 'Lục giác',
            'shape.star': 'Sao',
            'shape.star-4': 'Sao 4',
            'shape.heart': 'Trái tim',

            'shape.ph-star-four': 'Sao 4 cánh',
            'shape.ph-star-half': 'Sao nửa',
            'shape.ph-diamond': 'Kim cương',
            'shape.ph-heart': 'Tim tròn',
            'shape.ph-heart-straight': 'Tim thẳng',
            'shape.ph-drop': 'Giọt nước',
            'shape.ph-flame': 'Lửa',
            'shape.ph-leaf': 'Lá',
            'shape.ph-snowflake': 'Bông tuyết',
            'shape.ph-sun': 'Mặt trời',
            'shape.ph-moon-stars': 'Trăng sao',
            'shape.ph-cloud': 'Mây',
            'shape.ph-cloud-sun': 'Mây nắng',
            'shape.ph-cloud-moon': 'Mây trăng',
            'shape.ph-sparkle': 'Lấp lánh',
            'shape.ph-crown': 'Vương miện',
            'shape.ph-trophy': 'Cúp',
            'shape.ph-medal': 'Huy chương',
            'shape.ph-certificate': 'Chứng nhận',
            'shape.ph-infinity': 'Vô cực',
            'shape.ph-flower': 'Hoa',
            'shape.ph-flower-lotus': 'Hoa sen',
            'shape.ph-butterfly': 'Bướm',
            'shape.ph-paw-print': 'Dấu chân',
            'shape.ph-bird': 'Chim',
            'shape.ph-fish-simple': 'Cá',
            'shape.ph-tree-evergreen': 'Cây thông',
            'shape.ph-tree-palm': 'Cây cọ',
            'shape.ph-mountains': 'Núi',
            'shape.ph-waves': 'Sóng',
            'shape.ph-rainbow': 'Cầu vồng',
            'shape.ph-lightning': 'Sét',
            'shape.ph-umbrella': 'Ô',
            'shape.ph-atom': 'Nguyên tử',
            'shape.ph-planet': 'Hành tinh',
            'shape.ph-globe': 'Địa cầu',
            'shape.ph-compass': 'La bàn',
            'shape.ph-map-pin': 'Pin',
            'shape.ph-navigation-arrow': 'Mũi tên định vị',
            'shape.ph-airplane-tilt': 'Máy bay nghiêng',
            'shape.ph-rocket': 'Tên lửa',
            'shape.ph-rocket-launch': 'Tên lửa phóng',
            'shape.ph-anchor': 'Mỏ neo',
            'shape.ph-sailboat': 'Thuyền buồm',
            'shape.ph-bicycle': 'Xe đạp',
            'shape.ph-car-simple': 'Xe hơi',
            'shape.ph-bus': 'Xe bus',
            'shape.ph-train': 'Tàu lửa',
            'shape.ph-subway': 'Tàu điện',
            'shape.ph-balloon': 'Bóng bay',
            'shape.ph-gift': 'Quà',
            'shape.ph-cake': 'Bánh kem',
            'shape.ph-camera': 'Máy ảnh',
            'shape.ph-video-camera': 'Máy quay',
            'shape.ph-music-notes': 'Nốt nhạc',
            'shape.ph-headphones': 'Tai nghe',
            'shape.ph-microphone': 'Mic',
            'shape.ph-game-controller': 'Tay cầm game',
            'shape.ph-dice-six': 'Xúc xắc',
            'shape.ph-puzzle-piece': 'Mảnh ghép',
            'shape.ph-cube': 'Khối lập phương',
            'shape.ph-stack-simple': 'Chồng khối',

            'alert.imageProcessFail': 'Không thể xử lý ảnh. Vui lòng thử ảnh khác.',
            'toast.logoMax': 'Logo tối đa {max}% với ECC {ecc}',
            'toast.geoNotSupported': 'Trình duyệt không hỗ trợ định vị',
            'toast.geoGetting': 'Đang lấy vị trí...',
            'toast.geoSuccess': 'Đã lấy vị trí thành công!',
            'toast.geoFail': 'Không thể lấy vị trí: {msg}',
            'toast.fileTooLarge': 'File quá lớn! Tối đa 5MB',
            'toast.fileUploading': 'Đang tải file lên...',
            'toast.fileUploaded': 'Đã tạo link tải file!',
            'toast.uploadError': 'Upload lỗi: {msg}',
            'toast.vietqrMissing': 'Vui lòng nhập Số tài khoản và chọn Ngân hàng',
            'toast.sepaMissing': 'Vui lòng nhập Tên người nhận và IBAN',
            'toast.sepaIbanInvalid': 'IBAN không hợp lệ',
            'toast.sepaBicInvalid': 'BIC/SWIFT không hợp lệ',
            'toast.sepaAmountInvalid': 'Số tiền EUR không hợp lệ',
            'toast.logoClampedMax': 'Logo đã giới hạn {used}% (tối đa {max}%)',
            'toast.logoClampedReadable': 'Logo đã giới hạn {used}% để dễ quét',
            'toast.canvasFlipNotAllowedV': 'Canvas không thể lật dọc',
            'toast.canvasFlipNotAllowedH': 'Canvas không thể lật ngang',
            'toast.distributeNeed3': 'Cần ít nhất 3 phần tử để phân bố',
            'toast.elementsLocked': 'Đã khóa phần tử',
            'toast.elementsUnlocked': 'Đã mở khóa phần tử',
            'toast.canvasCannotCopy': 'Canvas không thể copy',
            'toast.qrCannotCopy': 'Mã QR không thể copy',
            'toast.copiedElements': 'Đã copy {count} phần tử',
            'toast.canvasCannotPaste': 'Canvas không thể paste',
            'toast.qrCannotPaste': 'Mã QR không thể paste',
            'toast.canvasCannotDuplicate': 'Canvas không thể nhân đôi',
            'toast.qrCannotDuplicate': 'Mã QR không thể nhân đôi',
            'toast.canvasCannotDelete': 'Canvas không thể xóa',
            'alert.pdfNoJsPdfPngInstead': 'Xuất PDF cần thư viện jsPDF. Sẽ tải PNG thay thế.',
            'alert.copySuccess': '✅ Đã copy!',
            'alert.copyFail': '❌ {msg}',
            'project.nameLabel': 'Tên File:',
            'project.namePlaceholder': 'Tên file',
            'project.defaultName': 'Thiết kế mới',
            'autosave.saved': 'Đã lưu',
            'zoom.reset': 'Reset 100%',
            'zoom.fit': 'Vừa khung',
            'align.left': 'Căn trái',
            'align.centerH': 'Căn giữa ngang',
            'align.right': 'Căn phải',
            'align.top': 'Căn trên',
            'align.centerV': 'Căn giữa dọc',
            'align.bottom': 'Căn dưới',
            'aria.mobileZoom': 'Thu phóng khung nhìn (mobile)',
            'aria.projectName': 'Tên dự án',

            'field.urlLabel': 'URL',
            'field.textLabel': 'Văn bản',
            'field.phone': 'Số điện thoại',
            'field.ssid': 'SSID',
            'field.password': 'Mật khẩu',
            'field.security': 'Bảo mật',
            'field.email': 'Email',
            'field.subject': 'Tiêu đề',
            'field.body': 'Nội dung',
            'field.smsPhone': 'SĐT',
            'field.smsMessage': 'Tin nhắn',
            'field.lat': 'Vĩ độ (Latitude)',
            'field.lng': 'Kinh độ (Longitude)',
            'field.placeName': 'Tên địa điểm (tùy chọn)',

            'ph.url': 'https://example.vn',
            'ph.text': 'Nhập văn bản...',
            'ph.phone': '+84...',
            'ph.ssid': 'Tên WiFi',
            'ph.password': 'Mật khẩu',
            'ph.email': 'email@...',
            'ph.subject': 'Tiêu đề',
            'ph.body': 'Nội dung...',
            'ph.smsMessage': 'Tin nhắn...',
            'ph.placeName': 'Ví dụ: Hà Nội, Việt Nam',

            'wifi.security.none': 'Không',

            'vcard.lastName': 'Họ',
            'vcard.firstName': 'Tên',
            'vcard.company': 'Công ty',
            'vcard.title': 'Chức vụ',
            'vcard.phone': 'Điện thoại',
            'vcard.email': 'Email',
            'vcard.website': 'Website',
            'vcard.address': 'Địa chỉ',
            'ph.vcard.lastName': 'Nguyễn',
            'ph.vcard.firstName': 'Văn A',
            'ph.vcard.company': 'Công ty ABC',
            'ph.vcard.title': 'Giám đốc',
            'ph.vcard.email': 'email@company.com',
            'ph.vcard.website': 'https://...',
            'ph.vcard.address': '123 Đường ABC, Quận 1, TP.HCM',

            'event.title': 'Tên sự kiện',
            'event.location': 'Địa điểm',
            'event.start': 'Bắt đầu',
            'event.end': 'Kết thúc',
            'event.description': 'Mô tả',
            'ph.event.title': 'Họp team',
            'ph.event.location': 'Phòng họp A',
            'ph.event.description': 'Chi tiết sự kiện...',

            'vietqr.bank': 'Ngân hàng',
            'vietqr.account': 'Số tài khoản',
            'vietqr.name': 'Tên chủ TK (tùy chọn)',
            'vietqr.amount': 'Số tiền (VND, tùy chọn)',
            'vietqr.memo': 'Nội dung CK (tùy chọn)',
            'ph.vietqr.account': '0123456789',
            'ph.vietqr.name': 'NGUYEN VAN A',
            'ph.vietqr.amount': '100000',
            'ph.vietqr.memo': 'Chuyen khoan',

            'crypto.currencyType': 'Loại tiền',
            'crypto.address': 'Địa chỉ ví',
            'crypto.amount': 'Số lượng (tùy chọn)',
            'crypto.note': 'Ghi chú (tùy chọn)',
            'ph.crypto.address': 'bc1q...',
            'ph.crypto.amount': '0.001',
            'ph.crypto.note': 'Donation',

            'file.uploadLabel': 'Tải file lên (sẽ tạo link download)',
            'file.choose': 'Chọn file',
            'file.supportHint': 'Hỗ trợ: PDF, DOC, XLS, ZIP, hình ảnh... (tối đa 5MB)',
            'file.orDirectUrl': 'Hoặc nhập URL file trực tiếp',
            'ph.fileDirectUrl': 'https://example.com/file.pdf',

            'section.qrColor': 'Màu QR',
            'label.qrCodeColor': 'Màu code',
            'label.qrBgColor': 'Màu nền QR',
            'section.qrLogo': 'Logo QR',
            'label.logoUploadHint': 'Tải logo lên (sẽ hiển thị ở giữa QR)',
            'label.logoSize': 'Kích thước logo (%)',
            'label.logoRadius': 'Bo tròn logo (%)',
            'section.dotEcc': 'Dot & ECC',
            'label.dotStyle': 'Kiểu chấm',
            'dotStyle.roundedSquare': 'Vuông bo',
            'dotStyle.square': 'Vuông truyền thống',
            'dotStyle.circle': 'Chấm tròn',
            'dotStyle.roundedBar': 'Gạch bo góc',
            'dotStyle.horizontalBar': 'Gạch ngang',
            'dotStyle.verticalBar': 'Gạch dọc',
            'dotStyle.capsule': 'Viên thuốc',
            'label.eyeStyle': 'Kiểu mắt',
            'eyeStyle.square': 'Vuông classic',
            'eyeStyle.rounded': 'Bo tròn',
            'eyeStyle.circle': 'Bubble / Dot',
            'eyeStyle.roundedBar': 'Gạch bo tròn',
            'eyeStyle.diamond': 'Kim cương',
            'label.ecc': 'Sửa lỗi',
            'ecc.low': 'Thấp',
            'ecc.medium': 'Vừa',
            'ecc.high': 'Cao',
            'section.tune': 'Tinh chỉnh QR',
            'label.dotGap': 'Khoảng cách chấm',
            'label.eyeThickness': 'Độ dày viền mắt QR',

            'section.addText': 'Thêm văn bản',
            'text.heading': 'Tiêu đề',
            'text.subheading': 'Phụ đề',
            'text.body': 'Văn bản',

            'section.canvasBg': 'Màu nền Canvas',
            'section.canvasSize': 'Kích thước Canvas',
            'label.width': 'Rộng',
            'label.height': 'Cao',
            'section.shapes': 'Hình dạng',
            'section.properties': 'Thuộc tính',
            'section.actions': 'Thao tác',

            'sepa.name': 'Tên người nhận',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT (tùy chọn)',
            'sepa.amount': 'Số tiền (EUR, tùy chọn)',
            'sepa.purpose': 'Mục đích (tùy chọn, 4 ký tự)',
            'sepa.remittance': 'Nội dung chuyển khoản (tùy chọn)',
            'sepa.info': 'Thông tin thêm (tùy chọn)',
            'sepa.ph.name': 'Ví dụ: John Doe',
            'sepa.ph.iban': 'Ví dụ: DE89370400440532013000',
            'sepa.ph.bic': 'Ví dụ: DEUTDEFF',
            'sepa.ph.amount': 'Ví dụ: 12.34',
            'sepa.ph.purpose': 'Ví dụ: GDDS',
            'sepa.ph.remittance': 'Ví dụ: Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': 'Text',
            'type.wifi': 'WiFi',
            'type.email': 'Email',
            'type.phone': 'Phone',
            'type.sms': 'SMS',
            'type.location': 'Vị trí',
            'type.vcard': 'vCard',
            'type.event': 'Sự kiện',
            'type.vietqr': 'VietQR',
            'type.crypto': 'Crypto',
            'type.file': 'File',
          },
          en: {
            'meta.title': 'Qrio - Free QR editor',
            'meta.description': 'Design professional QR codes with a powerful editor. Customize colors and styles, add a logo, and export in HD.',
            'nav.home': 'Back to home',
            'tabs.qr': 'QR Code',
            'tabs.text': 'Text',
            'tabs.elements': 'Add',
            'empty.noQr': 'No QR yet',
            'empty.noQrHint': 'Create a QR code to start designing',
            'empty.createQr': 'Create QR code',
            'qr.type': 'QR type',
            'qr.complexity': 'Complexity',
            'qr.version': 'Version',
            'qr.content': 'Content',
            'qr.gridUnit': 'cells',
            'wifi.security.wpa': 'WPA/WPA2',
            'wifi.security.wep': 'WEP',
            'bank.scheme': 'Scheme',
            'bank.scheme.vietqr': 'VietQR (VN)',
            'bank.scheme.sepa': 'SEPA (EPC)',
            'action.copy': 'Copy',
            'action.paste': 'Paste',
            'action.duplicate': 'Duplicate',
            'action.delete': 'Delete',
            'action.undo': 'Undo',
            'action.redo': 'Redo',
            'action.download': 'Download',
            'action.cancel': 'Cancel',
            'action.selectAll': 'Select all',
            'action.uploadLogo': 'Upload logo',
            'action.remove': 'Remove',
            'action.currentLocation': 'Current location',
            'action.addHeading': 'Add Heading',
            'action.addSubheading': 'Add Subheading',
            'action.addBodyText': 'Add Text',
            'action.apply': 'Apply',
            'action.showMoreShapes': 'Show more shapes',
            'action.showLessShapes': 'Show less',
            'layer.up': 'Bring forward',
            'layer.down': 'Send backward',
            'layer.top': 'Bring to front',
            'layer.bottom': 'Send to back',

            'tooltip.undo': 'Undo (Ctrl+Z)',
            'tooltip.redo': 'Redo (Ctrl+Shift+Z)',
            'tooltip.copy': 'Copy (Ctrl+C)',
            'tooltip.duplicate': 'Duplicate (Ctrl+D)',
            'tooltip.delete': 'Delete (Delete)',
            'tooltip.layer': 'Layer',
            'tooltip.paste': 'Paste (Ctrl+V)',
            'tooltip.more': 'More',

            'distribute.horizontal': 'Distribute horizontally',
            'distribute.vertical': 'Distribute vertically',
            'flip.horizontal': 'Flip horizontal',
            'flip.vertical': 'Flip vertical',
            'rotate.reset': 'Reset rotation (0°)',
            'rotate.90': 'Rotate 90°',
            'rotate.-90': 'Rotate -90°',
            'lock.toggle': 'Lock / Unlock',
            'canvas.fit': 'Fit to canvas',
            'canvas.center': 'Center in canvas',

            'export.title': 'Download design',
            'export.filename': 'File name',
            'export.filenameHint': 'File name will automatically match the selected format (png/jpg/svg)',
            'export.format': 'Format',
            'export.size': 'Export size',
            'export.sizeMode.scale': 'Scale',
            'export.sizeMode.custom': 'Custom',
            'export.widthPx': 'Width (px)',
            'export.heightPx': 'Height (px)',
            'export.lockRatio': 'Keep aspect ratio',
            'export.quality': 'Quality',
            'export.canvasRadius': 'Canvas corner radius',

            'props.canvasTitle': 'Canvas',
            'props.selectHint': 'Select an element on the canvas to view and edit its properties.',
            'props.width': 'Width',
            'props.height': 'Height',
            'props.size': 'Size',
            'props.background': 'Background',
            'props.stroke': 'Stroke',
            'props.cornerRadius': 'Corner radius',
            'props.rotation': 'Rotation (°)',
            'props.opacity': 'Opacity',
            'props.text.content': 'Content',
            'props.text.inlineEditHint': 'double-click to edit inline',
            'props.text.font': 'Font',
            'props.text.clickToChooseHint': 'click to choose',
            'props.text.searchFont': 'Search fonts...',
            'props.text.fontSize': 'Font size',
            'props.text.style': 'Text style',
            'props.text.bold': 'Bold',
            'props.text.italic': 'Italic',
            'props.text.underline': 'Underline',
            'props.text.shadow': 'Shadow',
            'props.text.color': 'Text color',
            'props.text.background': 'Text background',

            // Shapes (basic + Phosphor)
            'shape.rect': 'Square',
            'shape.rounded': 'Rounded square',
            'shape.circle': 'Circle',
            'shape.pill': 'Pill',
            'shape.triangle': 'Triangle',
            'shape.triangle-down': 'Inverted triangle',
            'shape.diamond': 'Diamond',
            'shape.pentagon': 'Pentagon',
            'shape.hexagon': 'Hexagon',
            'shape.star': 'Star',
            'shape.star-4': '4-point star',
            'shape.heart': 'Heart',

            'shape.ph-star-four': '4-point star',
            'shape.ph-star-half': 'Half star',
            'shape.ph-diamond': 'Diamond',
            'shape.ph-heart': 'Heart',
            'shape.ph-heart-straight': 'Straight heart',
            'shape.ph-drop': 'Drop',
            'shape.ph-flame': 'Flame',
            'shape.ph-leaf': 'Leaf',
            'shape.ph-snowflake': 'Snowflake',
            'shape.ph-sun': 'Sun',
            'shape.ph-moon-stars': 'Moon & stars',
            'shape.ph-cloud': 'Cloud',
            'shape.ph-cloud-sun': 'Cloud & sun',
            'shape.ph-cloud-moon': 'Cloud & moon',
            'shape.ph-sparkle': 'Sparkle',
            'shape.ph-crown': 'Crown',
            'shape.ph-trophy': 'Trophy',
            'shape.ph-medal': 'Medal',
            'shape.ph-certificate': 'Certificate',
            'shape.ph-infinity': 'Infinity',
            'shape.ph-flower': 'Flower',
            'shape.ph-flower-lotus': 'Lotus',
            'shape.ph-butterfly': 'Butterfly',
            'shape.ph-paw-print': 'Paw print',
            'shape.ph-bird': 'Bird',
            'shape.ph-fish-simple': 'Fish',
            'shape.ph-tree-evergreen': 'Pine tree',
            'shape.ph-tree-palm': 'Palm tree',
            'shape.ph-mountains': 'Mountains',
            'shape.ph-waves': 'Waves',
            'shape.ph-rainbow': 'Rainbow',
            'shape.ph-lightning': 'Lightning',
            'shape.ph-umbrella': 'Umbrella',
            'shape.ph-atom': 'Atom',
            'shape.ph-planet': 'Planet',
            'shape.ph-globe': 'Globe',
            'shape.ph-compass': 'Compass',
            'shape.ph-map-pin': 'Pin',
            'shape.ph-navigation-arrow': 'Navigation arrow',
            'shape.ph-airplane-tilt': 'Airplane',
            'shape.ph-rocket': 'Rocket',
            'shape.ph-rocket-launch': 'Rocket launch',
            'shape.ph-anchor': 'Anchor',
            'shape.ph-sailboat': 'Sailboat',
            'shape.ph-bicycle': 'Bicycle',
            'shape.ph-car-simple': 'Car',
            'shape.ph-bus': 'Bus',
            'shape.ph-train': 'Train',
            'shape.ph-subway': 'Subway',
            'shape.ph-balloon': 'Balloon',
            'shape.ph-gift': 'Gift',
            'shape.ph-cake': 'Cake',
            'shape.ph-camera': 'Camera',
            'shape.ph-video-camera': 'Video camera',
            'shape.ph-music-notes': 'Music notes',
            'shape.ph-headphones': 'Headphones',
            'shape.ph-microphone': 'Microphone',
            'shape.ph-game-controller': 'Game controller',
            'shape.ph-dice-six': 'Dice',
            'shape.ph-puzzle-piece': 'Puzzle piece',
            'shape.ph-cube': 'Cube',
            'shape.ph-stack-simple': 'Stack',

            'alert.imageProcessFail': 'Cannot process the image. Please try another one.',
            'toast.logoMax': 'Max logo {max}% with ECC {ecc}',
            'toast.geoNotSupported': 'Geolocation is not supported by this browser',
            'toast.geoGetting': 'Getting location...',
            'toast.geoSuccess': 'Location captured successfully!',
            'toast.geoFail': 'Cannot get location: {msg}',
            'toast.fileTooLarge': 'File is too large! Max 5MB',
            'toast.fileUploading': 'Uploading file...',
            'toast.fileUploaded': 'Download link created!',
            'toast.uploadError': 'Upload error: {msg}',
            'toast.vietqrMissing': 'Please enter an account number and choose a bank',
            'toast.sepaMissing': 'Please enter beneficiary name and IBAN',
            'toast.sepaIbanInvalid': 'Invalid IBAN',
            'toast.sepaBicInvalid': 'Invalid BIC/SWIFT',
            'toast.sepaAmountInvalid': 'Invalid EUR amount',
            'toast.logoClampedMax': 'Logo clamped to {used}% (max {max}%)',
            'toast.logoClampedReadable': 'Logo clamped to {used}% for scanability',
            'toast.canvasFlipNotAllowedV': 'Canvas cannot be flipped vertically',
            'toast.canvasFlipNotAllowedH': 'Canvas cannot be flipped horizontally',
            'toast.distributeNeed3': 'Need at least 3 elements to distribute',
            'toast.elementsLocked': 'Elements locked',
            'toast.elementsUnlocked': 'Elements unlocked',
            'toast.canvasCannotCopy': 'Canvas cannot be copied',
            'toast.qrCannotCopy': 'QR cannot be copied',
            'toast.copiedElements': 'Copied {count} elements',
            'toast.canvasCannotPaste': 'Canvas cannot be pasted',
            'toast.qrCannotPaste': 'QR cannot be pasted',
            'toast.canvasCannotDuplicate': 'Canvas cannot be duplicated',
            'toast.qrCannotDuplicate': 'QR cannot be duplicated',
            'toast.canvasCannotDelete': 'Canvas cannot be deleted',
            'alert.pdfNoJsPdfPngInstead': 'PDF export requires jsPDF library. Downloading as PNG instead.',
            'alert.copySuccess': '✅ Copied!',
            'alert.copyFail': '❌ {msg}',
            'project.nameLabel': 'File name:',
            'project.namePlaceholder': 'File name',
            'project.defaultName': 'New design',
            'autosave.saved': 'Saved',
            'zoom.reset': 'Reset 100%',
            'zoom.fit': 'Fit to view',
            'align.left': 'Align left',
            'align.centerH': 'Align horizontal center',
            'align.right': 'Align right',
            'align.top': 'Align top',
            'align.centerV': 'Align vertical center',
            'align.bottom': 'Align bottom',
            'aria.mobileZoom': 'Mobile viewport zoom',
            'aria.projectName': 'Project name',

            'field.urlLabel': 'URL',
            'field.textLabel': 'Text',
            'field.phone': 'Phone number',
            'field.ssid': 'SSID',
            'field.password': 'Password',
            'field.security': 'Security',
            'field.email': 'Email',
            'field.subject': 'Subject',
            'field.body': 'Body',
            'field.smsPhone': 'Phone',
            'field.smsMessage': 'Message',
            'field.lat': 'Latitude',
            'field.lng': 'Longitude',
            'field.placeName': 'Place name (optional)',

            'ph.url': 'https://example.com',
            'ph.text': 'Enter text...',
            'ph.phone': '+1...',
            'ph.ssid': 'WiFi name',
            'ph.password': 'Password',
            'ph.email': 'email@...',
            'ph.subject': 'Subject',
            'ph.body': 'Body...',
            'ph.smsMessage': 'Message...',
            'ph.placeName': 'e.g. Hanoi, Vietnam',

            'wifi.security.none': 'None',

            'vcard.lastName': 'Last name',
            'vcard.firstName': 'First name',
            'vcard.company': 'Company',
            'vcard.title': 'Title',
            'vcard.phone': 'Phone',
            'vcard.email': 'Email',
            'vcard.website': 'Website',
            'vcard.address': 'Address',
            'ph.vcard.lastName': 'Nguyen',
            'ph.vcard.firstName': 'Van A',
            'ph.vcard.company': 'ABC Company',
            'ph.vcard.title': 'Director',
            'ph.vcard.email': 'email@company.com',
            'ph.vcard.website': 'https://...',
            'ph.vcard.address': '123 Example Street',

            'event.title': 'Event title',
            'event.location': 'Location',
            'event.start': 'Start',
            'event.end': 'End',
            'event.description': 'Description',
            'ph.event.title': 'Team meeting',
            'ph.event.location': 'Meeting room A',
            'ph.event.description': 'Event details...',

            'vietqr.bank': 'Bank',
            'vietqr.account': 'Account number',
            'vietqr.name': 'Account name (optional)',
            'vietqr.amount': 'Amount (VND, optional)',
            'vietqr.memo': 'Memo (optional)',
            'ph.vietqr.account': '0123456789',
            'ph.vietqr.name': 'NGUYEN VAN A',
            'ph.vietqr.amount': '100000',
            'ph.vietqr.memo': 'Transfer',

            'crypto.currencyType': 'Currency',
            'crypto.address': 'Wallet address',
            'crypto.amount': 'Amount (optional)',
            'crypto.note': 'Note (optional)',
            'ph.crypto.address': 'bc1q...',
            'ph.crypto.amount': '0.001',
            'ph.crypto.note': 'Donation',

            'file.uploadLabel': 'Upload a file (will create a download link)',
            'file.choose': 'Choose file',
            'file.supportHint': 'Supported: PDF, DOC, XLS, ZIP, images... (max 5MB)',
            'file.orDirectUrl': 'Or enter a direct file URL',
            'ph.fileDirectUrl': 'https://example.com/file.pdf',

            'section.qrColor': 'QR colors',
            'label.qrCodeColor': 'Code color',
            'label.qrBgColor': 'Background color',
            'section.qrLogo': 'QR logo',
            'label.logoUploadHint': 'Upload a logo (shown in the center)',
            'label.logoSize': 'Logo size (%)',
            'label.logoRadius': 'Logo rounding (%)',
            'section.dotEcc': 'Dots & ECC',
            'label.dotStyle': 'Dot style',
            'dotStyle.roundedSquare': 'Rounded square',
            'dotStyle.square': 'Square',
            'dotStyle.circle': 'Circle',
            'dotStyle.roundedBar': 'Rounded bar',
            'dotStyle.horizontalBar': 'Horizontal bar',
            'dotStyle.verticalBar': 'Vertical bar',
            'dotStyle.capsule': 'Capsule',
            'label.eyeStyle': 'Eye style',
            'eyeStyle.square': 'Classic square',
            'eyeStyle.rounded': 'Rounded',
            'eyeStyle.circle': 'Bubble / Dot',
            'eyeStyle.roundedBar': 'Rounded bar',
            'eyeStyle.diamond': 'Diamond',
            'label.ecc': 'Error correction',
            'ecc.low': 'Low',
            'ecc.medium': 'Medium',
            'ecc.high': 'High',
            'section.tune': 'Fine-tune',
            'label.dotGap': 'Dot gap',
            'label.eyeThickness': 'Eye border thickness',

            'section.addText': 'Add text',
            'text.heading': 'Heading',
            'text.subheading': 'Subheading',
            'text.body': 'Text',

            'section.canvasBg': 'Canvas background',
            'section.canvasSize': 'Canvas size',
            'label.width': 'Width',
            'label.height': 'Height',
            'section.shapes': 'Shapes',
            'section.properties': 'Properties',
            'section.actions': 'Actions',

            'sepa.name': 'Beneficiary name',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT (optional)',
            'sepa.amount': 'Amount (EUR, optional)',
            'sepa.purpose': 'Purpose (optional, 4 chars)',
            'sepa.remittance': 'Remittance (optional)',
            'sepa.info': 'Information (optional)',
            'sepa.ph.name': 'e.g. John Doe',
            'sepa.ph.iban': 'e.g. DE89370400440532013000',
            'sepa.ph.bic': 'e.g. DEUTDEFF',
            'sepa.ph.amount': 'e.g. 12.34',
            'sepa.ph.purpose': 'e.g. GDDS',
            'sepa.ph.remittance': 'e.g. Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': 'Text',
            'type.wifi': 'WiFi',
            'type.email': 'Email',
            'type.phone': 'Phone',
            'type.sms': 'SMS',
            'type.location': 'Location',
            'type.vcard': 'vCard',
            'type.event': 'Event',
            'type.vietqr': 'VietQR',
            'type.crypto': 'Crypto',
            'type.file': 'File',
          },
          zh: {
            'nav.home': '返回首页',
            'tabs.qr': '二维码',
            'tabs.text': '文本',
            'tabs.elements': '添加',
            'empty.noQr': '暂无二维码',
            'empty.noQrHint': '先创建二维码再开始设计',
            'empty.createQr': '创建二维码',
            'qr.type': '二维码类型',
            'qr.complexity': '复杂度',
            'qr.version': '版本',
            'qr.content': '内容',
            'section.properties': '属性',
            'action.download': '下载',
            'action.addHeading': '添加标题',
            'action.addSubheading': '添加副标题',
            'action.addBodyText': '添加文本',
            'action.apply': '应用',
            'project.nameLabel': '文件名：',
            'project.namePlaceholder': '文件名',
            'project.defaultName': '新设计',
            'autosave.saved': '已保存',
            'aria.projectName': '项目名称',
            'action.cancel': '取消',
            'action.selectAll': '全选',
            'layer.up': '上移一层',
            'layer.down': '下移一层',
            'layer.top': '置于顶层',
            'layer.bottom': '置于底层',

            'tooltip.undo': '撤销 (Ctrl+Z)',
            'tooltip.redo': '重做 (Ctrl+Shift+Z)',
            'tooltip.copy': '复制 (Ctrl+C)',
            'tooltip.duplicate': '复制一份 (Ctrl+D)',
            'tooltip.delete': '删除 (Delete)',
            'tooltip.layer': '图层',
            'tooltip.paste': '粘贴 (Ctrl+V)',
            'tooltip.more': '更多',

            'align.left': '左对齐',
            'align.centerH': '水平居中',
            'align.right': '右对齐',
            'align.top': '顶部对齐',
            'align.centerV': '垂直居中',
            'align.bottom': '底部对齐',
            'distribute.horizontal': '水平分布',
            'distribute.vertical': '垂直分布',
            'flip.horizontal': '水平翻转',
            'flip.vertical': '垂直翻转',
            'rotate.reset': '重置旋转 (0°)',
            'rotate.90': '旋转 90°',
            'rotate.-90': '旋转 -90°',
            'lock.toggle': '锁定 / 解锁',
            'canvas.fit': '适配画布',
            'canvas.center': '居中到画布',

            'export.title': '下载设计',
            'export.filename': '文件名',
            'export.filenameHint': '文件名会自动匹配所选格式（png/jpg/svg）',
            'export.format': '格式',
            'export.size': '导出尺寸',
            'export.sizeMode.scale': '比例',
            'export.sizeMode.custom': '自定义',
            'export.widthPx': '宽度 (px)',
            'export.heightPx': '高度 (px)',
            'export.lockRatio': '保持比例',
            'export.quality': '质量',
            'export.canvasRadius': '画布圆角',

            'action.delete': '删除',
            'props.canvasTitle': '画布',
            'props.selectHint': '请选择画布上的元素以查看和编辑属性。',
            'props.width': '宽度',
            'props.height': '高度',
            'props.size': '大小',
            'props.background': '背景',
            'props.stroke': '描边',
            'props.cornerRadius': '圆角',
            'props.rotation': '旋转 (°)',
            'props.opacity': '不透明度',
            'props.text.content': '内容',
            'props.text.inlineEditHint': '双击直接编辑',
            'props.text.font': '字体',
            'props.text.clickToChooseHint': '点击选择',
            'props.text.searchFont': '搜索字体…',
            'props.text.fontSize': '字号',
            'props.text.style': '文字样式',
            'props.text.bold': '加粗',
            'props.text.italic': '斜体',
            'props.text.underline': '下划线',
            'props.text.shadow': '阴影',
            'props.text.color': '文字颜色',
            'props.text.background': '文字背景',

            'alert.imageProcessFail': '无法处理图片，请尝试其他图片。',
            'toast.logoMax': '在 ECC {ecc} 下，Logo 最大 {max}%',
            'toast.geoNotSupported': '浏览器不支持定位',
            'toast.geoGetting': '正在获取位置…',
            'toast.geoSuccess': '位置获取成功！',
            'toast.geoFail': '无法获取位置：{msg}',
            'toast.fileTooLarge': '文件过大！最大 5MB',
            'toast.fileUploading': '正在上传文件…',
            'toast.fileUploaded': '已生成下载链接！',
            'toast.uploadError': '上传错误：{msg}',
            'toast.vietqrMissing': '请输入账号并选择银行',
            'toast.sepaMissing': '请输入收款人姓名和 IBAN',
            'toast.sepaIbanInvalid': 'IBAN 无效',
            'toast.sepaBicInvalid': 'BIC/SWIFT 无效',
            'toast.sepaAmountInvalid': 'EUR 金额无效',
            'toast.logoClampedMax': 'Logo 已限制为 {used}%（最大 {max}%）',
            'toast.logoClampedReadable': '为便于扫描，Logo 已限制为 {used}%',
            'toast.canvasFlipNotAllowedV': '画布不能垂直翻转',
            'toast.canvasFlipNotAllowedH': '画布不能水平翻转',
            'toast.distributeNeed3': '分布需要至少 3 个元素',
            'toast.elementsLocked': '已锁定元素',
            'toast.elementsUnlocked': '已解锁元素',
            'toast.canvasCannotCopy': '画布不能复制',
            'toast.qrCannotCopy': '二维码不能复制',
            'toast.copiedElements': '已复制 {count} 个元素',
            'toast.canvasCannotPaste': '画布不能粘贴',
            'toast.qrCannotPaste': '二维码不能粘贴',
            'toast.canvasCannotDuplicate': '画布不能重复',
            'toast.qrCannotDuplicate': '二维码不能重复',
            'toast.canvasCannotDelete': '画布不能删除',
            'alert.pdfNoJsPdfPngInstead': '导出 PDF 需要 jsPDF 库，将改为下载 PNG。',
            'alert.copySuccess': '✅ 已复制！',
            'alert.copyFail': '❌ {msg}',
            'bank.scheme': '方式',
            'bank.scheme.vietqr': 'VietQR（越南）',
            'bank.scheme.sepa': 'SEPA（EPC）',
            'sepa.name': '收款人姓名',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT（可选）',
            'sepa.amount': '金额（EUR，可选）',
            'sepa.purpose': '用途（可选，4字符）',
            'sepa.remittance': '附言（可选）',
            'sepa.info': '附加信息（可选）',
            'sepa.ph.name': '例如：John Doe',
            'sepa.ph.iban': '例如：DE89370400440532013000',
            'sepa.ph.bic': '例如：DEUTDEFF',
            'sepa.ph.amount': '例如：12.34',
            'sepa.ph.purpose': '例如：GDDS',
            'sepa.ph.remittance': '例如：Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': '文本',
            'type.wifi': 'WiFi',
            'type.email': '邮箱',
            'type.phone': '电话',
            'type.sms': '短信',
            'type.location': '位置',
            'type.vcard': 'vCard',
            'type.event': '事件',
            'type.vietqr': 'VietQR',
            'type.crypto': '加密货币',
            'type.file': '文件',
          },
          hi: {
            'nav.home': 'होम पर वापस',
            'tabs.qr': 'QR',
            'tabs.text': 'टेक्स्ट',
            'tabs.elements': 'जोड़ें',
            'empty.noQr': 'अभी QR नहीं है',
            'empty.noQrHint': 'डिज़ाइन शुरू करने के लिए QR बनाएँ',
            'empty.createQr': 'QR बनाएँ',
            'qr.type': 'QR प्रकार',
            'qr.complexity': 'जटिलता',
            'qr.version': 'संस्करण',
            'qr.content': 'सामग्री',
            'qr.gridUnit': 'कोशिकाएँ',
            'section.properties': 'गुण',
            'action.download': 'डाउनलोड',
            'action.addHeading': 'शीर्षक जोड़ें',
            'action.addSubheading': 'उपशीर्षक जोड़ें',
            'action.addBodyText': 'टेक्स्ट जोड़ें',
            'action.apply': 'लागू करें',
            'action.copy': 'कॉपी',
            'action.paste': 'पेस्ट',
            'action.duplicate': 'डुप्लिकेट',
            'action.cancel': 'रद्द करें',
            'action.selectAll': 'सभी चुनें',
            'layer.up': 'ऊपर लाएँ',
            'layer.down': 'नीचे भेजें',
            'layer.top': 'सबसे ऊपर लाएँ',
            'layer.bottom': 'सबसे नीचे भेजें',

            'project.nameLabel': 'फ़ाइल नाम:',
            'project.namePlaceholder': 'फ़ाइल नाम',
            'project.defaultName': 'नया डिज़ाइन',
            'autosave.saved': 'सहेजा गया',
            'zoom.reset': 'रीसेट 100%',
            'zoom.fit': 'व्यू में फिट',
            'aria.mobileZoom': 'मोबाइल व्यूपोर्ट ज़ूम',
            'aria.projectName': 'प्रोजेक्ट नाम',

            'field.ssid': 'SSID',
            'field.urlLabel': 'URL',
            'field.textLabel': 'टेक्स्ट',
            'field.phone': 'फोन नंबर',
            'field.password': 'पासवर्ड',
            'field.security': 'सुरक्षा',
            'field.email': 'ईमेल',
            'field.subject': 'विषय',
            'field.body': 'संदेश',
            'field.smsPhone': 'फोन',
            'field.smsMessage': 'संदेश',
            'field.lat': 'अक्षांश',
            'field.lng': 'देशांतर',
            'field.placeName': 'स्थान नाम (वैकल्पिक)',

            'vcard.lastName': 'उपनाम',
            'vcard.firstName': 'पहला नाम',
            'vcard.company': 'कंपनी',
            'vcard.title': 'पद',
            'vcard.phone': 'फोन',
            'vcard.email': 'ईमेल',
            'vcard.website': 'वेबसाइट',
            'vcard.address': 'पता',

            'event.title': 'इवेंट शीर्षक',
            'event.location': 'स्थान',
            'event.start': 'शुरू',
            'event.end': 'समाप्त',
            'event.description': 'विवरण',

            'vietqr.bank': 'बैंक',
            'vietqr.account': 'खाता संख्या',
            'vietqr.name': 'खाता नाम (वैकल्पिक)',
            'vietqr.amount': 'राशि (VND, वैकल्पिक)',
            'vietqr.memo': 'टिप्पणी/विवरण (वैकल्पिक)',

            'crypto.currencyType': 'मुद्रा',
            'crypto.address': 'वॉलेट पता',
            'crypto.amount': 'राशि (वैकल्पिक)',
            'crypto.note': 'नोट (वैकल्पिक)',

            'ph.url': 'https://example.in',
            'ph.text': 'टेक्स्ट दर्ज करें...',
            'ph.phone': '+91...',
            'ph.ssid': 'WiFi नाम',
            'ph.password': 'पासवर्ड',
            'ph.email': 'email@...',
            'ph.subject': 'विषय',
            'ph.body': 'संदेश...',
            'ph.smsMessage': 'संदेश...',
            'ph.placeName': 'उदा. Hanoi, Vietnam',

            'ph.vcard.lastName': 'शर्मा',
            'ph.vcard.firstName': 'राहुल',
            'ph.vcard.company': 'ABC कंपनी',
            'ph.vcard.title': 'निर्देशक',
            'ph.vcard.email': 'email@company.com',
            'ph.vcard.website': 'https://...',
            'ph.vcard.address': '123 उदाहरण मार्ग, नई दिल्ली',

            'ph.event.title': 'टीम मीटिंग',
            'ph.event.location': 'मीटिंग रूम A',
            'ph.event.description': 'इवेंट विवरण...',

            'ph.vietqr.account': '0123456789',
            'ph.vietqr.name': 'NGUYEN VAN A',
            'ph.vietqr.amount': '100000',
            'ph.vietqr.memo': 'Transfer',

            'ph.crypto.address': 'bc1q...',
            'ph.crypto.amount': '0.001',
            'ph.crypto.note': 'Donation',

            'wifi.security.wpa': 'WPA/WPA2',
            'wifi.security.wep': 'WEP',

            'shape.rect': 'वर्ग',
            'shape.rounded': 'गोल कोने वाला वर्ग',
            'shape.circle': 'वृत्त',
            'shape.pill': 'कैप्सूल',
            'shape.triangle': 'त्रिभुज',
            'shape.triangle-down': 'उल्टा त्रिभुज',
            'shape.diamond': 'हीरा',
            'shape.pentagon': 'पंचभुज',
            'shape.hexagon': 'षट्भुज',
            'shape.star': 'तारा',
            'shape.star-4': '4-नुकीला तारा',
            'shape.heart': 'हृदय',

            'tooltip.undo': 'पूर्ववत करें (Ctrl+Z)',
            'tooltip.redo': 'फिर करें (Ctrl+Shift+Z)',
            'tooltip.copy': 'कॉपी (Ctrl+C)',
            'tooltip.duplicate': 'डुप्लिकेट (Ctrl+D)',
            'tooltip.delete': 'हटाएँ (Delete)',
            'tooltip.layer': 'लेयर',
            'tooltip.paste': 'पेस्ट (Ctrl+V)',
            'tooltip.more': 'और',

            'file.uploadLabel': 'फ़ाइल अपलोड करें (डाउनलोड लिंक बनेगा)',
            'file.choose': 'फ़ाइल चुनें',
            'file.supportHint': 'समर्थित: PDF, DOC, XLS, ZIP, चित्र... (अधिकतम 5MB)',
            'file.orDirectUrl': 'या सीधे फ़ाइल URL दर्ज करें',

            'section.qrColor': 'QR रंग',
            'label.qrCodeColor': 'कोड रंग',
            'label.qrBgColor': 'पृष्ठभूमि रंग',
            'section.qrLogo': 'QR लोगो',
            'label.logoUploadHint': 'लोगो अपलोड करें (बीच में दिखेगा)',
            'action.uploadLogo': 'लोगो अपलोड करें',
            'label.logoSize': 'लोगो आकार (%)',
            'label.logoRadius': 'लोगो गोलाई (%)',
            'section.dotEcc': 'डॉट्स और ECC',
            'label.dotStyle': 'डॉट शैली',
            'dotStyle.roundedSquare': 'गोल कोने वाला वर्ग',
            'dotStyle.square': 'वर्ग',
            'dotStyle.circle': 'वृत्त',
            'dotStyle.roundedBar': 'गोल बार',
            'dotStyle.horizontalBar': 'क्षैतिज बार',
            'dotStyle.verticalBar': 'ऊर्ध्व बार',
            'dotStyle.capsule': 'कैप्सूल',
            'label.eyeStyle': 'आँख शैली',
            'eyeStyle.square': 'क्लासिक वर्ग',
            'eyeStyle.rounded': 'गोल',
            'eyeStyle.circle': 'बबल / डॉट',
            'eyeStyle.roundedBar': 'गोल बार',
            'eyeStyle.diamond': 'हीरा',
            'label.ecc': 'त्रुटि सुधार',
            'ecc.low': 'कम',
            'ecc.medium': 'मध्यम',
            'ecc.high': 'उच्च',
            'section.tune': 'सूक्ष्म समायोजन',
            'label.dotGap': 'डॉट अंतर',
            'label.eyeThickness': 'आँख बॉर्डर मोटाई',

            'section.addText': 'टेक्स्ट जोड़ें',
            'text.heading': 'शीर्षक',
            'text.subheading': 'उपशीर्षक',
            'text.body': 'टेक्स्ट',

            'section.canvasBg': 'कैनवास पृष्ठभूमि',
            'section.canvasSize': 'कैनवास आकार',
            'label.width': 'चौड़ाई',
            'label.height': 'ऊँचाई',
            'section.shapes': 'आकृतियाँ',
            'section.actions': 'क्रियाएँ',

            'wifi.security.none': 'कोई नहीं',

            'align.left': 'बाएँ संरेखित',
            'align.centerH': 'क्षैतिज केंद्र',
            'align.right': 'दाएँ संरेखित',
            'align.top': 'ऊपर संरेखित',
            'align.centerV': 'ऊर्ध्व केंद्र',
            'align.bottom': 'नीचे संरेखित',
            'distribute.horizontal': 'क्षैतिज वितरण',
            'distribute.vertical': 'ऊर्ध्व वितरण',
            'flip.horizontal': 'क्षैतिज पलटें',
            'flip.vertical': 'ऊर्ध्व पलटें',
            'rotate.reset': 'घुमाव रीसेट (0°)',
            'rotate.90': '90° घुमाएँ',
            'rotate.-90': '-90° घुमाएँ',
            'lock.toggle': 'लॉक / अनलॉक',
            'canvas.fit': 'कैनवास में फिट',
            'canvas.center': 'कैनवास के बीच',

            'export.title': 'डिज़ाइन डाउनलोड करें',
            'export.filename': 'फ़ाइल नाम',
            'export.filenameHint': 'फ़ाइल नाम चुने गए फ़ॉर्मेट (png/jpg/svg) के अनुसार स्वतः सेट होगा',
            'export.format': 'फ़ॉर्मेट',
            'export.size': 'एक्सपोर्ट आकार',
            'export.sizeMode.scale': 'स्केल',
            'export.sizeMode.custom': 'कस्टम',
            'export.widthPx': 'चौड़ाई (px)',
            'export.heightPx': 'ऊँचाई (px)',
            'export.lockRatio': 'अनुपात रखें',
            'export.quality': 'गुणवत्ता',
            'export.canvasRadius': 'कैनवास कोना रेडियस',

            'action.delete': 'हटाएँ',
            'props.canvasTitle': 'कैनवास',
            'props.selectHint': 'गुण देखने/बदलने के लिए कैनवास पर कोई तत्व चुनें।',
            'props.width': 'चौड़ाई',
            'props.height': 'ऊँचाई',
            'props.size': 'आकार',
            'props.background': 'पृष्ठभूमि',
            'props.stroke': 'आउटलाइन',
            'props.cornerRadius': 'कोना रेडियस',
            'props.rotation': 'घुमाव (°)',
            'props.opacity': 'अपारदर्शिता',
            'props.text.content': 'सामग्री',
            'props.text.inlineEditHint': 'डबल-क्लिक करके सीधे संपादित करें',
            'props.text.font': 'फ़ॉन्ट',
            'props.text.clickToChooseHint': 'चुनने के लिए क्लिक करें',
            'props.text.searchFont': 'फ़ॉन्ट खोजें...',
            'props.text.fontSize': 'फ़ॉन्ट आकार',
            'props.text.style': 'टेक्स्ट शैली',
            'props.text.bold': 'बोल्ड',
            'props.text.italic': 'इटैलिक',
            'props.text.underline': 'अंडरलाइन',
            'props.text.shadow': 'छाया',
            'props.text.color': 'टेक्स्ट रंग',
            'props.text.background': 'टेक्स्ट पृष्ठभूमि',

            'alert.imageProcessFail': 'छवि को प्रोसेस नहीं किया जा सका। कृपया दूसरी छवि आज़माएँ।',
            'toast.logoMax': 'ECC {ecc} के साथ लोगो अधिकतम {max}%',
            'toast.geoNotSupported': 'यह ब्राउज़र लोकेशन सपोर्ट नहीं करता',
            'toast.geoGetting': 'स्थान प्राप्त किया जा रहा है...',
            'toast.geoSuccess': 'स्थान सफलतापूर्वक मिल गया!',
            'toast.geoFail': 'स्थान नहीं मिल सका: {msg}',
            'toast.fileTooLarge': 'फ़ाइल बहुत बड़ी है! अधिकतम 5MB',
            'toast.fileUploading': 'फ़ाइल अपलोड हो रही है...',
            'toast.fileUploaded': 'डाउनलोड लिंक बन गया!',
            'toast.uploadError': 'अपलोड त्रुटि: {msg}',
            'toast.vietqrMissing': 'कृपया खाता संख्या दर्ज करें और बैंक चुनें',
            'toast.sepaMissing': 'कृपया प्राप्तकर्ता नाम और IBAN दर्ज करें',
            'toast.sepaIbanInvalid': 'अमान्य IBAN',
            'toast.sepaBicInvalid': 'अमान्य BIC/SWIFT',
            'toast.sepaAmountInvalid': 'अमान्य EUR राशि',
            'toast.logoClampedMax': 'लोगो {used}% तक सीमित (अधिकतम {max}%)',
            'toast.logoClampedReadable': 'स्कैन के लिए लोगो {used}% तक सीमित',
            'toast.canvasFlipNotAllowedV': 'कैनवास को ऊर्ध्व दिशा में पलटा नहीं जा सकता',
            'toast.canvasFlipNotAllowedH': 'कैनवास को क्षैतिज दिशा में पलटा नहीं जा सकता',
            'toast.distributeNeed3': 'वितरण के लिए कम से कम 3 तत्व चाहिए',
            'toast.elementsLocked': 'तत्व लॉक किए गए',
            'toast.elementsUnlocked': 'तत्व अनलॉक किए गए',
            'toast.canvasCannotCopy': 'कैनवास कॉपी नहीं किया जा सकता',
            'toast.qrCannotCopy': 'QR कॉपी नहीं किया जा सकता',
            'toast.copiedElements': '{count} तत्व कॉपी हुए',
            'toast.canvasCannotPaste': 'कैनवास पेस्ट नहीं किया जा सकता',
            'toast.qrCannotPaste': 'QR पेस्ट नहीं किया जा सकता',
            'toast.canvasCannotDuplicate': 'कैनवास डुप्लिकेट नहीं किया जा सकता',
            'toast.qrCannotDuplicate': 'QR डुप्लिकेट नहीं किया जा सकता',
            'toast.canvasCannotDelete': 'कैनवास हटाया नहीं जा सकता',
            'alert.pdfNoJsPdfPngInstead': 'PDF एक्सपोर्ट के लिए jsPDF लाइब्रेरी चाहिए। PNG डाउनलोड होगा।',
            'alert.copySuccess': '✅ कॉपी हो गया!',
            'alert.copyFail': '❌ {msg}',
            'bank.scheme': 'स्कीम',
            'bank.scheme.vietqr': 'VietQR (VN)',
            'bank.scheme.sepa': 'SEPA (EPC)',
            'sepa.name': 'प्राप्तकर्ता नाम',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT (वैकल्पिक)',
            'sepa.amount': 'राशि (EUR, वैकल्पिक)',
            'sepa.purpose': 'उद्देश्य (वैकल्पिक, 4 अक्षर)',
            'sepa.remittance': 'रेमिटेंस (वैकल्पिक)',
            'sepa.info': 'जानकारी (वैकल्पिक)',
            'sepa.ph.name': 'उदा. John Doe',
            'sepa.ph.iban': 'उदा. DE89370400440532013000',
            'sepa.ph.bic': 'उदा. DEUTDEFF',
            'sepa.ph.amount': 'उदा. 12.34',
            'sepa.ph.purpose': 'उदा. GDDS',
            'sepa.ph.remittance': 'उदा. Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': 'टेक्स्ट',
            'type.wifi': 'WiFi',
            'type.email': 'ईमेल',
            'type.phone': 'फोन',
            'type.sms': 'SMS',
            'type.location': 'स्थान',
            'type.vcard': 'vCard',
            'type.event': 'इवेंट',
            'type.vietqr': 'VietQR',
            'type.crypto': 'क्रिप्टो',
            'type.file': 'फ़ाइल',
          },
          es: {
            'nav.home': 'Volver al inicio',
            'tabs.qr': 'QR',
            'tabs.text': 'Texto',
            'tabs.elements': 'Agregar',
            'empty.noQr': 'Aún no hay QR',
            'empty.noQrHint': 'Crea un QR para empezar a diseñar',
            'empty.createQr': 'Crear QR',
            'qr.type': 'Tipo de QR',
            'qr.complexity': 'Complejidad',
            'qr.version': 'Versión',
            'qr.content': 'Contenido',
            'section.properties': 'Propiedades',
            'action.download': 'Descargar',
            'action.addHeading': 'Añadir título',
            'action.addSubheading': 'Añadir subtítulo',
            'action.addBodyText': 'Añadir texto',
            'action.apply': 'Aplicar',
            'project.nameLabel': 'Nombre de archivo:',
            'project.namePlaceholder': 'Nombre de archivo',
            'project.defaultName': 'Nuevo diseño',
            'autosave.saved': 'Guardado',
            'aria.projectName': 'Nombre del proyecto',
            'action.cancel': 'Cancelar',
            'action.selectAll': 'Seleccionar todo',
            'layer.up': 'Traer adelante',
            'layer.down': 'Enviar atrás',
            'layer.top': 'Traer al frente',
            'layer.bottom': 'Enviar al fondo',

            'tooltip.undo': 'Deshacer (Ctrl+Z)',
            'tooltip.redo': 'Rehacer (Ctrl+Shift+Z)',
            'tooltip.copy': 'Copiar (Ctrl+C)',
            'tooltip.duplicate': 'Duplicar (Ctrl+D)',
            'tooltip.delete': 'Eliminar (Delete)',
            'tooltip.layer': 'Capas',
            'tooltip.paste': 'Pegar (Ctrl+V)',
            'tooltip.more': 'Más',

            'align.left': 'Alinear a la izquierda',
            'align.centerH': 'Centrar horizontalmente',
            'align.right': 'Alinear a la derecha',
            'align.top': 'Alinear arriba',
            'align.centerV': 'Centrar verticalmente',
            'align.bottom': 'Alinear abajo',
            'distribute.horizontal': 'Distribuir horizontalmente',
            'distribute.vertical': 'Distribuir verticalmente',
            'flip.horizontal': 'Voltear horizontal',
            'flip.vertical': 'Voltear vertical',
            'rotate.reset': 'Restablecer rotación (0°)',
            'rotate.90': 'Girar 90°',
            'rotate.-90': 'Girar -90°',
            'lock.toggle': 'Bloquear / Desbloquear',
            'canvas.fit': 'Ajustar al lienzo',
            'canvas.center': 'Centrar en el lienzo',

            'export.title': 'Descargar diseño',
            'export.filename': 'Nombre de archivo',
            'export.filenameHint': 'El nombre se ajustará automáticamente al formato seleccionado (png/jpg/svg)',
            'export.format': 'Formato',
            'export.size': 'Tamaño de exportación',
            'export.sizeMode.scale': 'Escala',
            'export.sizeMode.custom': 'Personalizado',
            'export.widthPx': 'Ancho (px)',
            'export.heightPx': 'Alto (px)',
            'export.lockRatio': 'Mantener proporción',
            'export.quality': 'Calidad',
            'export.canvasRadius': 'Radio de esquinas del lienzo',

            'action.delete': 'Eliminar',
            'props.canvasTitle': 'Lienzo',
            'props.selectHint': 'Selecciona un elemento en el lienzo para ver y editar sus propiedades.',
            'props.width': 'Ancho',
            'props.height': 'Alto',
            'props.size': 'Tamaño',
            'props.background': 'Fondo',
            'props.stroke': 'Borde',
            'props.cornerRadius': 'Radio de esquinas',
            'props.rotation': 'Rotación (°)',
            'props.opacity': 'Opacidad',
            'props.text.content': 'Contenido',
            'props.text.inlineEditHint': 'doble clic para editar directamente',
            'props.text.font': 'Fuente',
            'props.text.clickToChooseHint': 'haz clic para elegir',
            'props.text.searchFont': 'Buscar fuentes...',
            'props.text.fontSize': 'Tamaño de fuente',
            'props.text.style': 'Estilo de texto',
            'props.text.bold': 'Negrita',
            'props.text.italic': 'Cursiva',
            'props.text.underline': 'Subrayado',
            'props.text.shadow': 'Sombra',
            'props.text.color': 'Color del texto',
            'props.text.background': 'Fondo del texto',

            'alert.imageProcessFail': 'No se puede procesar la imagen. Prueba con otra.',
            'toast.logoMax': 'Logo máximo {max}% con ECC {ecc}',
            'toast.geoNotSupported': 'El navegador no admite geolocalización',
            'toast.geoGetting': 'Obteniendo ubicación...',
            'toast.geoSuccess': '¡Ubicación obtenida con éxito!',
            'toast.geoFail': 'No se puede obtener la ubicación: {msg}',
            'toast.fileTooLarge': '¡El archivo es demasiado grande! Máx. 5MB',
            'toast.fileUploading': 'Subiendo archivo...',
            'toast.fileUploaded': '¡Enlace de descarga creado!',
            'toast.uploadError': 'Error de subida: {msg}',
            'toast.vietqrMissing': 'Introduce el número de cuenta y elige un banco',
            'toast.sepaMissing': 'Introduce el nombre del beneficiario y el IBAN',
            'toast.sepaIbanInvalid': 'IBAN no válido',
            'toast.sepaBicInvalid': 'BIC/SWIFT no válido',
            'toast.sepaAmountInvalid': 'Importe EUR no válido',
            'toast.logoClampedMax': 'Logo limitado a {used}% (máx. {max}%)',
            'toast.logoClampedReadable': 'Logo limitado a {used}% para facilitar el escaneo',
            'toast.canvasFlipNotAllowedV': 'El lienzo no se puede voltear verticalmente',
            'toast.canvasFlipNotAllowedH': 'El lienzo no se puede voltear horizontalmente',
            'toast.distributeNeed3': 'Se necesitan al menos 3 elementos para distribuir',
            'toast.elementsLocked': 'Elementos bloqueados',
            'toast.elementsUnlocked': 'Elementos desbloqueados',
            'toast.canvasCannotCopy': 'No se puede copiar el lienzo',
            'toast.qrCannotCopy': 'No se puede copiar el QR',
            'toast.copiedElements': 'Se copiaron {count} elementos',
            'toast.canvasCannotPaste': 'No se puede pegar en el lienzo',
            'toast.qrCannotPaste': 'No se puede pegar el QR',
            'toast.canvasCannotDuplicate': 'No se puede duplicar el lienzo',
            'toast.qrCannotDuplicate': 'No se puede duplicar el QR',
            'toast.canvasCannotDelete': 'No se puede eliminar el lienzo',
            'alert.pdfNoJsPdfPngInstead': 'Para exportar PDF se requiere jsPDF. Se descargará PNG en su lugar.',
            'alert.copySuccess': '✅ ¡Copiado!',
            'alert.copyFail': '❌ {msg}',
            'bank.scheme': 'Esquema',
            'bank.scheme.vietqr': 'VietQR (VN)',
            'bank.scheme.sepa': 'SEPA (EPC)',
            'sepa.name': 'Nombre del beneficiario',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT (opcional)',
            'sepa.amount': 'Importe (EUR, opcional)',
            'sepa.purpose': 'Propósito (opcional, 4 caracteres)',
            'sepa.remittance': 'Concepto (opcional)',
            'sepa.info': 'Información (opcional)',
            'sepa.ph.name': 'p. ej. John Doe',
            'sepa.ph.iban': 'p. ej. DE89370400440532013000',
            'sepa.ph.bic': 'p. ej. DEUTDEFF',
            'sepa.ph.amount': 'p. ej. 12.34',
            'sepa.ph.purpose': 'p. ej. GDDS',
            'sepa.ph.remittance': 'p. ej. Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': 'Texto',
            'type.wifi': 'WiFi',
            'type.email': 'Email',
            'type.phone': 'Teléfono',
            'type.sms': 'SMS',
            'type.location': 'Ubicación',
            'type.vcard': 'vCard',
            'type.event': 'Evento',
            'type.vietqr': 'VietQR',
            'type.crypto': 'Cripto',
            'type.file': 'Archivo',
          },
          fr: {
            'nav.home': 'Retour à l’accueil',
            'tabs.qr': 'QR',
            'tabs.text': 'Texte',
            'tabs.elements': 'Ajouter',
            'empty.noQr': 'Pas encore de QR',
            'empty.noQrHint': 'Créez un QR pour commencer à concevoir',
            'empty.createQr': 'Créer un QR',
            'qr.type': 'Type de QR',
            'qr.complexity': 'Complexité',
            'qr.version': 'Version',
            'qr.content': 'Contenu',
            'section.properties': 'Propriétés',
            'action.download': 'Télécharger',
            'action.addHeading': 'Ajouter un titre',
            'action.addSubheading': 'Ajouter un sous-titre',
            'action.addBodyText': 'Ajouter du texte',
            'action.apply': 'Appliquer',
            'project.nameLabel': 'Nom du fichier :',
            'project.namePlaceholder': 'Nom du fichier',
            'project.defaultName': 'Nouveau design',
            'autosave.saved': 'Enregistré',
            'aria.projectName': 'Nom du projet',
            'action.cancel': 'Annuler',
            'action.selectAll': 'Tout sélectionner',
            'layer.up': 'Avancer',
            'layer.down': 'Reculer',
            'layer.top': 'Mettre au premier plan',
            'layer.bottom': 'Mettre à l’arrière-plan',

            'tooltip.undo': 'Annuler (Ctrl+Z)',
            'tooltip.redo': 'Rétablir (Ctrl+Shift+Z)',
            'tooltip.copy': 'Copier (Ctrl+C)',
            'tooltip.duplicate': 'Dupliquer (Ctrl+D)',
            'tooltip.delete': 'Supprimer (Delete)',
            'tooltip.layer': 'Calques',
            'tooltip.paste': 'Coller (Ctrl+V)',
            'tooltip.more': 'Plus',

            'align.left': 'Aligner à gauche',
            'align.centerH': 'Centrer horizontalement',
            'align.right': 'Aligner à droite',
            'align.top': 'Aligner en haut',
            'align.centerV': 'Centrer verticalement',
            'align.bottom': 'Aligner en bas',
            'distribute.horizontal': 'Répartir horizontalement',
            'distribute.vertical': 'Répartir verticalement',
            'flip.horizontal': 'Retourner horizontalement',
            'flip.vertical': 'Retourner verticalement',
            'rotate.reset': 'Réinitialiser la rotation (0°)',
            'rotate.90': 'Pivoter de 90°',
            'rotate.-90': 'Pivoter de -90°',
            'lock.toggle': 'Verrouiller / Déverrouiller',
            'canvas.fit': 'Ajuster au canevas',
            'canvas.center': 'Centrer sur le canevas',

            'export.title': 'Télécharger le design',
            'export.filename': 'Nom du fichier',
            'export.filenameHint': 'Le nom s’adapte automatiquement au format choisi (png/jpg/svg)',
            'export.format': 'Format',
            'export.size': 'Taille d’export',
            'export.sizeMode.scale': 'Échelle',
            'export.sizeMode.custom': 'Personnalisé',
            'export.widthPx': 'Largeur (px)',
            'export.heightPx': 'Hauteur (px)',
            'export.lockRatio': 'Conserver les proportions',
            'export.quality': 'Qualité',
            'export.canvasRadius': 'Rayon des coins du canevas',

            'action.delete': 'Supprimer',
            'props.canvasTitle': 'Canevas',
            'props.selectHint': 'Sélectionnez un élément sur le canevas pour voir et modifier ses propriétés.',
            'props.width': 'Largeur',
            'props.height': 'Hauteur',
            'props.size': 'Taille',
            'props.background': 'Arrière-plan',
            'props.stroke': 'Contour',
            'props.cornerRadius': 'Rayon des coins',
            'props.rotation': 'Rotation (°)',
            'props.opacity': 'Opacité',
            'props.text.content': 'Contenu',
            'props.text.inlineEditHint': 'double-cliquez pour modifier directement',
            'props.text.font': 'Police',
            'props.text.clickToChooseHint': 'cliquez pour choisir',
            'props.text.searchFont': 'Rechercher une police...',
            'props.text.fontSize': 'Taille de police',
            'props.text.style': 'Style du texte',
            'props.text.bold': 'Gras',
            'props.text.italic': 'Italique',
            'props.text.underline': 'Souligné',
            'props.text.shadow': 'Ombre',
            'props.text.color': 'Couleur du texte',
            'props.text.background': 'Fond du texte',

            'alert.imageProcessFail': 'Impossible de traiter l’image. Essayez une autre.',
            'toast.logoMax': 'Logo max {max}% avec ECC {ecc}',
            'toast.geoNotSupported': 'La géolocalisation n’est pas prise en charge par ce navigateur',
            'toast.geoGetting': 'Récupération de la position...',
            'toast.geoSuccess': 'Position récupérée avec succès !',
            'toast.geoFail': 'Impossible d’obtenir la position : {msg}',
            'toast.fileTooLarge': 'Fichier trop volumineux ! Max 5MB',
            'toast.fileUploading': 'Téléversement du fichier...',
            'toast.fileUploaded': 'Lien de téléchargement créé !',
            'toast.uploadError': 'Erreur de téléversement : {msg}',
            'toast.vietqrMissing': 'Saisissez le numéro de compte et choisissez une banque',
            'toast.sepaMissing': 'Saisissez le nom du bénéficiaire et l’IBAN',
            'toast.sepaIbanInvalid': 'IBAN invalide',
            'toast.sepaBicInvalid': 'BIC/SWIFT invalide',
            'toast.sepaAmountInvalid': 'Montant EUR invalide',
            'toast.logoClampedMax': 'Logo limité à {used}% (max {max}%)',
            'toast.logoClampedReadable': 'Logo limité à {used}% pour la lisibilité',
            'toast.canvasFlipNotAllowedV': 'Le canevas ne peut pas être retourné verticalement',
            'toast.canvasFlipNotAllowedH': 'Le canevas ne peut pas être retourné horizontalement',
            'toast.distributeNeed3': 'Au moins 3 éléments sont nécessaires pour répartir',
            'toast.elementsLocked': 'Éléments verrouillés',
            'toast.elementsUnlocked': 'Éléments déverrouillés',
            'toast.canvasCannotCopy': 'Le canevas ne peut pas être copié',
            'toast.qrCannotCopy': 'Le QR ne peut pas être copié',
            'toast.copiedElements': '{count} éléments copiés',
            'toast.canvasCannotPaste': 'Impossible de coller sur le canevas',
            'toast.qrCannotPaste': 'Impossible de coller le QR',
            'toast.canvasCannotDuplicate': 'Le canevas ne peut pas être dupliqué',
            'toast.qrCannotDuplicate': 'Le QR ne peut pas être dupliqué',
            'toast.canvasCannotDelete': 'Le canevas ne peut pas être supprimé',
            'alert.pdfNoJsPdfPngInstead': 'L’export PDF nécessite jsPDF. Téléchargement en PNG à la place.',
            'alert.copySuccess': '✅ Copié !',
            'alert.copyFail': '❌ {msg}',
            'bank.scheme': 'Schéma',
            'bank.scheme.vietqr': 'VietQR (VN)',
            'bank.scheme.sepa': 'SEPA (EPC)',
            'sepa.name': 'Nom du bénéficiaire',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT (optionnel)',
            'sepa.amount': 'Montant (EUR, optionnel)',
            'sepa.purpose': 'Objet (optionnel, 4 caractères)',
            'sepa.remittance': 'Référence (optionnel)',
            'sepa.info': 'Information (optionnel)',
            'sepa.ph.name': 'ex. John Doe',
            'sepa.ph.iban': 'ex. DE89370400440532013000',
            'sepa.ph.bic': 'ex. DEUTDEFF',
            'sepa.ph.amount': 'ex. 12.34',
            'sepa.ph.purpose': 'ex. GDDS',
            'sepa.ph.remittance': 'ex. Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': 'Texte',
            'type.wifi': 'WiFi',
            'type.email': 'Email',
            'type.phone': 'Téléphone',
            'type.sms': 'SMS',
            'type.location': 'Lieu',
            'type.vcard': 'vCard',
            'type.event': 'Événement',
            'type.vietqr': 'VietQR',
            'type.crypto': 'Crypto',
            'type.file': 'Fichier',
          },
          ar: {
            'nav.home': 'العودة للرئيسية',
            'tabs.qr': 'QR',
            'tabs.text': 'نص',
            'tabs.elements': 'إضافة',
            'empty.noQr': 'لا يوجد QR بعد',
            'empty.noQrHint': 'أنشئ QR لبدء التصميم',
            'empty.createQr': 'إنشاء QR',
            'qr.type': 'نوع QR',
            'qr.complexity': 'التعقيد',
            'qr.version': 'الإصدار',
            'qr.content': 'المحتوى',
            'section.properties': 'الخصائص',
            'action.download': 'تنزيل',
            'action.addHeading': 'إضافة عنوان',
            'action.addSubheading': 'إضافة عنوان فرعي',
            'action.addBodyText': 'إضافة نص',
            'action.apply': 'تطبيق',
            'project.nameLabel': 'اسم الملف:',
            'project.namePlaceholder': 'اسم الملف',
            'project.defaultName': 'تصميم جديد',
            'autosave.saved': 'تم الحفظ',
            'aria.projectName': 'اسم المشروع',
            'action.cancel': 'إلغاء',
            'action.selectAll': 'تحديد الكل',
            'layer.up': 'إحضار للأمام',
            'layer.down': 'إرسال للخلف',
            'layer.top': 'إحضار للمقدمة',
            'layer.bottom': 'إرسال للمؤخرة',

            'tooltip.undo': 'تراجع (Ctrl+Z)',
            'tooltip.redo': 'إعادة (Ctrl+Shift+Z)',
            'tooltip.copy': 'نسخ (Ctrl+C)',
            'tooltip.duplicate': 'تكرار (Ctrl+D)',
            'tooltip.delete': 'حذف (Delete)',
            'tooltip.layer': 'الطبقات',
            'tooltip.paste': 'لصق (Ctrl+V)',
            'tooltip.more': 'المزيد',

            'align.left': 'محاذاة لليسار',
            'align.centerH': 'توسيط أفقي',
            'align.right': 'محاذاة لليمين',
            'align.top': 'محاذاة للأعلى',
            'align.centerV': 'توسيط عمودي',
            'align.bottom': 'محاذاة للأسفل',
            'distribute.horizontal': 'توزيع أفقي',
            'distribute.vertical': 'توزيع عمودي',
            'flip.horizontal': 'قلب أفقي',
            'flip.vertical': 'قلب عمودي',
            'rotate.reset': 'إعادة ضبط الدوران (0°)',
            'rotate.90': 'تدوير 90°',
            'rotate.-90': 'تدوير -90°',
            'lock.toggle': 'قفل / إلغاء القفل',
            'canvas.fit': 'ملاءمة للوحة',
            'canvas.center': 'توسيط في اللوحة',

            'export.title': 'تنزيل التصميم',
            'export.filename': 'اسم الملف',
            'export.filenameHint': 'سيتم ضبط اسم الملف تلقائيًا حسب التنسيق المختار (png/jpg/svg)',
            'export.format': 'التنسيق',
            'export.size': 'حجم التصدير',
            'export.sizeMode.scale': 'المقياس',
            'export.sizeMode.custom': 'مخصص',
            'export.widthPx': 'العرض (px)',
            'export.heightPx': 'الارتفاع (px)',
            'export.lockRatio': 'الحفاظ على النسبة',
            'export.quality': 'الجودة',
            'export.canvasRadius': 'نصف قطر زوايا اللوحة',

            'action.delete': 'حذف',
            'props.canvasTitle': 'لوحة',
            'props.selectHint': 'حدد عنصرًا على اللوحة لعرض خصائصه وتعديلها.',
            'props.width': 'العرض',
            'props.height': 'الارتفاع',
            'props.size': 'الحجم',
            'props.background': 'الخلفية',
            'props.stroke': 'الحد',
            'props.cornerRadius': 'نصف قطر الزوايا',
            'props.rotation': 'الدوران (°)',
            'props.opacity': 'العتامة',
            'props.text.content': 'المحتوى',
            'props.text.inlineEditHint': 'انقر مرتين للتحرير مباشرة',
            'props.text.font': 'الخط',
            'props.text.clickToChooseHint': 'انقر للاختيار',
            'props.text.searchFont': 'ابحث عن الخطوط...',
            'props.text.fontSize': 'حجم الخط',
            'props.text.style': 'نمط النص',
            'props.text.bold': 'عريض',
            'props.text.italic': 'مائل',
            'props.text.underline': 'تحته خط',
            'props.text.shadow': 'ظل',
            'props.text.color': 'لون النص',
            'props.text.background': 'خلفية النص',

            'alert.imageProcessFail': 'تعذّر معالجة الصورة. جرّب صورة أخرى.',
            'toast.logoMax': 'الحد الأقصى للشعار {max}% مع ECC {ecc}',
            'toast.geoNotSupported': 'المتصفح لا يدعم تحديد الموقع',
            'toast.geoGetting': 'جارٍ الحصول على الموقع...',
            'toast.geoSuccess': 'تم الحصول على الموقع بنجاح!',
            'toast.geoFail': 'تعذّر الحصول على الموقع: {msg}',
            'toast.fileTooLarge': 'الملف كبير جداً! الحد الأقصى 5MB',
            'toast.fileUploading': 'جارٍ رفع الملف...',
            'toast.fileUploaded': 'تم إنشاء رابط التحميل!',
            'toast.uploadError': 'خطأ في الرفع: {msg}',
            'toast.vietqrMissing': 'أدخل رقم الحساب واختر البنك',
            'toast.sepaMissing': 'أدخل اسم المستفيد وIBAN',
            'toast.sepaIbanInvalid': 'IBAN غير صالح',
            'toast.sepaBicInvalid': 'BIC/SWIFT غير صالح',
            'toast.sepaAmountInvalid': 'مبلغ EUR غير صالح',
            'toast.logoClampedMax': 'تم تحديد الشعار إلى {used}% (الحد الأقصى {max}%)',
            'toast.logoClampedReadable': 'تم تحديد الشعار إلى {used}% لسهولة المسح',
            'toast.canvasFlipNotAllowedV': 'لا يمكن قلب اللوحة عموديًا',
            'toast.canvasFlipNotAllowedH': 'لا يمكن قلب اللوحة أفقيًا',
            'toast.distributeNeed3': 'تحتاج إلى 3 عناصر على الأقل للتوزيع',
            'toast.elementsLocked': 'تم قفل العناصر',
            'toast.elementsUnlocked': 'تم إلغاء قفل العناصر',
            'toast.canvasCannotCopy': 'لا يمكن نسخ اللوحة',
            'toast.qrCannotCopy': 'لا يمكن نسخ QR',
            'toast.copiedElements': 'تم نسخ {count} عنصر',
            'toast.canvasCannotPaste': 'لا يمكن لصق اللوحة',
            'toast.qrCannotPaste': 'لا يمكن لصق QR',
            'toast.canvasCannotDuplicate': 'لا يمكن تكرار اللوحة',
            'toast.qrCannotDuplicate': 'لا يمكن تكرار QR',
            'toast.canvasCannotDelete': 'لا يمكن حذف اللوحة',
            'alert.pdfNoJsPdfPngInstead': 'يتطلب تصدير PDF مكتبة jsPDF. سيتم تنزيل PNG بدلاً من ذلك.',
            'alert.copySuccess': '✅ تم النسخ!',
            'alert.copyFail': '❌ {msg}',
            'bank.scheme': 'الطريقة',
            'bank.scheme.vietqr': 'VietQR (VN)',
            'bank.scheme.sepa': 'SEPA (EPC)',
            'sepa.name': 'اسم المستفيد',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT (اختياري)',
            'sepa.amount': 'المبلغ (EUR، اختياري)',
            'sepa.purpose': 'الغرض (اختياري، 4 أحرف)',
            'sepa.remittance': 'البيان (اختياري)',
            'sepa.info': 'معلومات (اختياري)',
            'sepa.ph.name': 'مثال: John Doe',
            'sepa.ph.iban': 'مثال: DE89370400440532013000',
            'sepa.ph.bic': 'مثال: DEUTDEFF',
            'sepa.ph.amount': 'مثال: 12.34',
            'sepa.ph.purpose': 'مثال: GDDS',
            'sepa.ph.remittance': 'مثال: Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': 'نص',
            'type.wifi': 'WiFi',
            'type.email': 'بريد',
            'type.phone': 'هاتف',
            'type.sms': 'SMS',
            'type.location': 'موقع',
            'type.vcard': 'vCard',
            'type.event': 'حدث',
            'type.vietqr': 'VietQR',
            'type.crypto': 'Crypto',
            'type.file': 'ملف',
          },
          pt: {
            'nav.home': 'Voltar para início',
            'tabs.qr': 'QR',
            'tabs.text': 'Texto',
            'tabs.elements': 'Adicionar',
            'empty.noQr': 'Ainda não há QR',
            'empty.noQrHint': 'Crie um QR para começar a desenhar',
            'empty.createQr': 'Criar QR',
            'qr.type': 'Tipo de QR',
            'qr.complexity': 'Complexidade',
            'qr.version': 'Versão',
            'qr.content': 'Conteúdo',
            'section.properties': 'Propriedades',
            'action.download': 'Baixar',
            'action.addHeading': 'Adicionar título',
            'action.addSubheading': 'Adicionar subtítulo',
            'action.addBodyText': 'Adicionar texto',
            'action.apply': 'Aplicar',
            'project.nameLabel': 'Nome do arquivo:',
            'project.namePlaceholder': 'Nome do arquivo',
            'project.defaultName': 'Novo design',
            'autosave.saved': 'Salvo',
            'aria.projectName': 'Nome do projeto',
            'action.cancel': 'Cancelar',
            'action.selectAll': 'Selecionar tudo',
            'layer.up': 'Trazer para frente',
            'layer.down': 'Enviar para trás',
            'layer.top': 'Trazer para o topo',
            'layer.bottom': 'Enviar para o fundo',

            'tooltip.undo': 'Desfazer (Ctrl+Z)',
            'tooltip.redo': 'Refazer (Ctrl+Shift+Z)',
            'tooltip.copy': 'Copiar (Ctrl+C)',
            'tooltip.duplicate': 'Duplicar (Ctrl+D)',
            'tooltip.delete': 'Excluir (Delete)',
            'tooltip.layer': 'Camadas',
            'tooltip.paste': 'Colar (Ctrl+V)',
            'tooltip.more': 'Mais',

            'align.left': 'Alinhar à esquerda',
            'align.centerH': 'Centralizar horizontalmente',
            'align.right': 'Alinhar à direita',
            'align.top': 'Alinhar ao topo',
            'align.centerV': 'Centralizar verticalmente',
            'align.bottom': 'Alinhar à base',
            'distribute.horizontal': 'Distribuir horizontalmente',
            'distribute.vertical': 'Distribuir verticalmente',
            'flip.horizontal': 'Virar horizontal',
            'flip.vertical': 'Virar vertical',
            'rotate.reset': 'Redefinir rotação (0°)',
            'rotate.90': 'Girar 90°',
            'rotate.-90': 'Girar -90°',
            'lock.toggle': 'Bloquear / Desbloquear',
            'canvas.fit': 'Ajustar ao canvas',
            'canvas.center': 'Centralizar no canvas',

            'export.title': 'Baixar design',
            'export.filename': 'Nome do arquivo',
            'export.filenameHint': 'O nome do arquivo se ajusta automaticamente ao formato selecionado (png/jpg/svg)',
            'export.format': 'Formato',
            'export.size': 'Tamanho de exportação',
            'export.sizeMode.scale': 'Escala',
            'export.sizeMode.custom': 'Personalizado',
            'export.widthPx': 'Largura (px)',
            'export.heightPx': 'Altura (px)',
            'export.lockRatio': 'Manter proporção',
            'export.quality': 'Qualidade',
            'export.canvasRadius': 'Raio dos cantos do canvas',

            'action.delete': 'Excluir',
            'props.canvasTitle': 'Canvas',
            'props.selectHint': 'Selecione um elemento no canvas para ver e editar as propriedades.',
            'props.width': 'Largura',
            'props.height': 'Altura',
            'props.size': 'Tamanho',
            'props.background': 'Fundo',
            'props.stroke': 'Contorno',
            'props.cornerRadius': 'Raio dos cantos',
            'props.rotation': 'Rotação (°)',
            'props.opacity': 'Opacidade',
            'props.text.content': 'Conteúdo',
            'props.text.inlineEditHint': 'duplo clique para editar diretamente',
            'props.text.font': 'Fonte',
            'props.text.clickToChooseHint': 'clique para escolher',
            'props.text.searchFont': 'Pesquisar fontes...',
            'props.text.fontSize': 'Tamanho da fonte',
            'props.text.style': 'Estilo do texto',
            'props.text.bold': 'Negrito',
            'props.text.italic': 'Itálico',
            'props.text.underline': 'Sublinhado',
            'props.text.shadow': 'Sombra',
            'props.text.color': 'Cor do texto',
            'props.text.background': 'Fundo do texto',

            'alert.imageProcessFail': 'Não foi possível processar a imagem. Tente outra.',
            'toast.logoMax': 'Logo máximo {max}% com ECC {ecc}',
            'toast.geoNotSupported': 'O navegador não suporta geolocalização',
            'toast.geoGetting': 'Obtendo localização...',
            'toast.geoSuccess': 'Localização obtida com sucesso!',
            'toast.geoFail': 'Não foi possível obter a localização: {msg}',
            'toast.fileTooLarge': 'Arquivo muito grande! Máx. 5MB',
            'toast.fileUploading': 'Enviando arquivo...',
            'toast.fileUploaded': 'Link de download criado!',
            'toast.uploadError': 'Erro no upload: {msg}',
            'toast.vietqrMissing': 'Informe o número da conta e escolha o banco',
            'toast.sepaMissing': 'Informe o nome do beneficiário e o IBAN',
            'toast.sepaIbanInvalid': 'IBAN inválido',
            'toast.sepaBicInvalid': 'BIC/SWIFT inválido',
            'toast.sepaAmountInvalid': 'Valor em EUR inválido',
            'toast.logoClampedMax': 'Logo limitado a {used}% (máx. {max}%)',
            'toast.logoClampedReadable': 'Logo limitado a {used}% para facilitar a leitura',
            'toast.canvasFlipNotAllowedV': 'O canvas não pode ser virado verticalmente',
            'toast.canvasFlipNotAllowedH': 'O canvas não pode ser virado horizontalmente',
            'toast.distributeNeed3': 'É necessário pelo menos 3 elementos para distribuir',
            'toast.elementsLocked': 'Elementos bloqueados',
            'toast.elementsUnlocked': 'Elementos desbloqueados',
            'toast.canvasCannotCopy': 'O canvas não pode ser copiado',
            'toast.qrCannotCopy': 'O QR não pode ser copiado',
            'toast.copiedElements': '{count} elementos copiados',
            'toast.canvasCannotPaste': 'Não é possível colar no canvas',
            'toast.qrCannotPaste': 'Não é possível colar o QR',
            'toast.canvasCannotDuplicate': 'O canvas não pode ser duplicado',
            'toast.qrCannotDuplicate': 'O QR não pode ser duplicado',
            'toast.canvasCannotDelete': 'O canvas não pode ser excluído',
            'alert.pdfNoJsPdfPngInstead': 'A exportação em PDF requer a biblioteca jsPDF. Baixando PNG em vez disso.',
            'alert.copySuccess': '✅ Copiado!',
            'alert.copyFail': '❌ {msg}',
            'bank.scheme': 'Esquema',
            'bank.scheme.vietqr': 'VietQR (VN)',
            'bank.scheme.sepa': 'SEPA (EPC)',
            'sepa.name': 'Nome do beneficiário',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT (opcional)',
            'sepa.amount': 'Valor (EUR, opcional)',
            'sepa.purpose': 'Finalidade (opcional, 4 caracteres)',
            'sepa.remittance': 'Mensagem (opcional)',
            'sepa.info': 'Informação (opcional)',
            'sepa.ph.name': 'ex.: John Doe',
            'sepa.ph.iban': 'ex.: DE89370400440532013000',
            'sepa.ph.bic': 'ex.: DEUTDEFF',
            'sepa.ph.amount': 'ex.: 12.34',
            'sepa.ph.purpose': 'ex.: GDDS',
            'sepa.ph.remittance': 'ex.: Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': 'Texto',
            'type.wifi': 'WiFi',
            'type.email': 'Email',
            'type.phone': 'Telefone',
            'type.sms': 'SMS',
            'type.location': 'Local',
            'type.vcard': 'vCard',
            'type.event': 'Evento',
            'type.vietqr': 'VietQR',
            'type.crypto': 'Crypto',
            'type.file': 'Arquivo',
          },
          ru: {
            'nav.home': 'На главную',
            'tabs.qr': 'QR',
            'tabs.text': 'Текст',
            'tabs.elements': 'Добавить',
            'empty.noQr': 'QR ещё нет',
            'empty.noQrHint': 'Создайте QR, чтобы начать дизайн',
            'empty.createQr': 'Создать QR',
            'qr.type': 'Тип QR',
            'qr.complexity': 'Сложность',
            'qr.version': 'Версия',
            'qr.content': 'Содержимое',
            'section.properties': 'Свойства',
            'action.download': 'Скачать',
            'action.addHeading': 'Добавить заголовок',
            'action.addSubheading': 'Добавить подзаголовок',
            'action.addBodyText': 'Добавить текст',
            'action.apply': 'Применить',
            'project.nameLabel': 'Имя файла:',
            'project.namePlaceholder': 'Имя файла',
            'project.defaultName': 'Новый дизайн',
            'autosave.saved': 'Сохранено',
            'aria.projectName': 'Название проекта',
            'action.cancel': 'Отмена',
            'action.selectAll': 'Выбрать всё',
            'layer.up': 'На слой выше',
            'layer.down': 'На слой ниже',
            'layer.top': 'На передний план',
            'layer.bottom': 'На задний план',

            'tooltip.undo': 'Отменить (Ctrl+Z)',
            'tooltip.redo': 'Повторить (Ctrl+Shift+Z)',
            'tooltip.copy': 'Копировать (Ctrl+C)',
            'tooltip.duplicate': 'Дублировать (Ctrl+D)',
            'tooltip.delete': 'Удалить (Delete)',
            'tooltip.layer': 'Слои',
            'tooltip.paste': 'Вставить (Ctrl+V)',
            'tooltip.more': 'Ещё',

            'align.left': 'Выровнять по левому краю',
            'align.centerH': 'По центру по горизонтали',
            'align.right': 'Выровнять по правому краю',
            'align.top': 'Выровнять по верхнему краю',
            'align.centerV': 'По центру по вертикали',
            'align.bottom': 'Выровнять по нижнему краю',
            'distribute.horizontal': 'Распределить по горизонтали',
            'distribute.vertical': 'Распределить по вертикали',
            'flip.horizontal': 'Отразить по горизонтали',
            'flip.vertical': 'Отразить по вертикали',
            'rotate.reset': 'Сбросить поворот (0°)',
            'rotate.90': 'Повернуть на 90°',
            'rotate.-90': 'Повернуть на -90°',
            'lock.toggle': 'Заблокировать / Разблокировать',
            'canvas.fit': 'Подогнать под холст',
            'canvas.center': 'Центрировать на холсте',

            'export.title': 'Скачать дизайн',
            'export.filename': 'Имя файла',
            'export.filenameHint': 'Имя файла автоматически подстроится под выбранный формат (png/jpg/svg)',
            'export.format': 'Формат',
            'export.size': 'Размер экспорта',
            'export.sizeMode.scale': 'Масштаб',
            'export.sizeMode.custom': 'Пользовательский',
            'export.widthPx': 'Ширина (px)',
            'export.heightPx': 'Высота (px)',
            'export.lockRatio': 'Сохранять пропорции',
            'export.quality': 'Качество',
            'export.canvasRadius': 'Радиус углов холста',

            'action.delete': 'Удалить',
            'props.canvasTitle': 'Холст',
            'props.selectHint': 'Выберите элемент на холсте, чтобы посмотреть и изменить его свойства.',
            'props.width': 'Ширина',
            'props.height': 'Высота',
            'props.size': 'Размер',
            'props.background': 'Фон',
            'props.stroke': 'Контур',
            'props.cornerRadius': 'Радиус углов',
            'props.rotation': 'Поворот (°)',
            'props.opacity': 'Прозрачность',
            'props.text.content': 'Текст',
            'props.text.inlineEditHint': 'двойной щелчок для прямого редактирования',
            'props.text.font': 'Шрифт',
            'props.text.clickToChooseHint': 'нажмите, чтобы выбрать',
            'props.text.searchFont': 'Поиск шрифтов...',
            'props.text.fontSize': 'Размер шрифта',
            'props.text.style': 'Стиль текста',
            'props.text.bold': 'Жирный',
            'props.text.italic': 'Курсив',
            'props.text.underline': 'Подчёркивание',
            'props.text.shadow': 'Тень',
            'props.text.color': 'Цвет текста',
            'props.text.background': 'Фон текста',

            'alert.imageProcessFail': 'Не удалось обработать изображение. Попробуйте другое.',
            'toast.logoMax': 'Макс. логотип {max}% при ECC {ecc}',
            'toast.geoNotSupported': 'Геолокация не поддерживается браузером',
            'toast.geoGetting': 'Получение местоположения...',
            'toast.geoSuccess': 'Местоположение получено!',
            'toast.geoFail': 'Не удалось получить местоположение: {msg}',
            'toast.fileTooLarge': 'Файл слишком большой! Макс. 5MB',
            'toast.fileUploading': 'Загрузка файла...',
            'toast.fileUploaded': 'Ссылка для скачивания создана!',
            'toast.uploadError': 'Ошибка загрузки: {msg}',
            'toast.vietqrMissing': 'Введите номер счёта и выберите банк',
            'toast.sepaMissing': 'Введите имя получателя и IBAN',
            'toast.sepaIbanInvalid': 'Неверный IBAN',
            'toast.sepaBicInvalid': 'Неверный BIC/SWIFT',
            'toast.sepaAmountInvalid': 'Неверная сумма в EUR',
            'toast.logoClampedMax': 'Логотип ограничен до {used}% (макс. {max}%)',
            'toast.logoClampedReadable': 'Логотип ограничен до {used}% для читаемости',
            'toast.canvasFlipNotAllowedV': 'Холст нельзя отразить вертикально',
            'toast.canvasFlipNotAllowedH': 'Холст нельзя отразить горизонтально',
            'toast.distributeNeed3': 'Нужно минимум 3 элемента для распределения',
            'toast.elementsLocked': 'Элементы заблокированы',
            'toast.elementsUnlocked': 'Элементы разблокированы',
            'toast.canvasCannotCopy': 'Холст нельзя копировать',
            'toast.qrCannotCopy': 'QR нельзя копировать',
            'toast.copiedElements': 'Скопировано элементов: {count}',
            'toast.canvasCannotPaste': 'Нельзя вставить холст',
            'toast.qrCannotPaste': 'Нельзя вставить QR',
            'toast.canvasCannotDuplicate': 'Холст нельзя дублировать',
            'toast.qrCannotDuplicate': 'QR нельзя дублировать',
            'toast.canvasCannotDelete': 'Холст нельзя удалить',
            'alert.pdfNoJsPdfPngInstead': 'Для экспорта PDF требуется jsPDF. Вместо этого будет загружен PNG.',
            'alert.copySuccess': '✅ Скопировано!',
            'alert.copyFail': '❌ {msg}',
            'bank.scheme': 'Схема',
            'bank.scheme.vietqr': 'VietQR (VN)',
            'bank.scheme.sepa': 'SEPA (EPC)',
            'sepa.name': 'Получатель',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT (необязательно)',
            'sepa.amount': 'Сумма (EUR, необязательно)',
            'sepa.purpose': 'Назначение (необязательно, 4 символа)',
            'sepa.remittance': 'Сообщение (необязательно)',
            'sepa.info': 'Информация (необязательно)',
            'sepa.ph.name': 'напр. John Doe',
            'sepa.ph.iban': 'напр. DE89370400440532013000',
            'sepa.ph.bic': 'напр. DEUTDEFF',
            'sepa.ph.amount': 'напр. 12.34',
            'sepa.ph.purpose': 'напр. GDDS',
            'sepa.ph.remittance': 'напр. Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': 'Текст',
            'type.wifi': 'WiFi',
            'type.email': 'Email',
            'type.phone': 'Телефон',
            'type.sms': 'SMS',
            'type.location': 'Место',
            'type.vcard': 'vCard',
            'type.event': 'Событие',
            'type.vietqr': 'VietQR',
            'type.crypto': 'Crypto',
            'type.file': 'Файл',
          },
          id: {
            'nav.home': 'Kembali ke beranda',
            'tabs.qr': 'QR',
            'tabs.text': 'Teks',
            'tabs.elements': 'Tambah',
            'empty.noQr': 'Belum ada QR',
            'empty.noQrHint': 'Buat QR untuk mulai mendesain',
            'empty.createQr': 'Buat QR',
            'qr.type': 'Jenis QR',
            'qr.complexity': 'Kompleksitas',
            'qr.version': 'Versi',
            'qr.content': 'Konten',
            'section.properties': 'Properti',
            'action.download': 'Unduh',
            'action.addHeading': 'Tambah judul',
            'action.addSubheading': 'Tambah subjudul',
            'action.addBodyText': 'Tambah teks',
            'action.apply': 'Terapkan',
            'project.nameLabel': 'Nama file:',
            'project.namePlaceholder': 'Nama file',
            'project.defaultName': 'Desain baru',
            'autosave.saved': 'Tersimpan',
            'aria.projectName': 'Nama proyek',
            'action.cancel': 'Batal',
            'action.selectAll': 'Pilih semua',
            'layer.up': 'Naikkan',
            'layer.down': 'Turunkan',
            'layer.top': 'Ke paling depan',
            'layer.bottom': 'Ke paling belakang',

            'tooltip.undo': 'Urungkan (Ctrl+Z)',
            'tooltip.redo': 'Ulangi (Ctrl+Shift+Z)',
            'tooltip.copy': 'Salin (Ctrl+C)',
            'tooltip.duplicate': 'Duplikat (Ctrl+D)',
            'tooltip.delete': 'Hapus (Delete)',
            'tooltip.layer': 'Lapisan',
            'tooltip.paste': 'Tempel (Ctrl+V)',
            'tooltip.more': 'Lainnya',

            'align.left': 'Rata kiri',
            'align.centerH': 'Tengah horizontal',
            'align.right': 'Rata kanan',
            'align.top': 'Rata atas',
            'align.centerV': 'Tengah vertikal',
            'align.bottom': 'Rata bawah',
            'distribute.horizontal': 'Sebar horizontal',
            'distribute.vertical': 'Sebar vertikal',
            'flip.horizontal': 'Balik horizontal',
            'flip.vertical': 'Balik vertikal',
            'rotate.reset': 'Reset rotasi (0°)',
            'rotate.90': 'Putar 90°',
            'rotate.-90': 'Putar -90°',
            'lock.toggle': 'Kunci / Buka kunci',
            'canvas.fit': 'Sesuaikan ke kanvas',
            'canvas.center': 'Tengah di kanvas',

            'export.title': 'Unduh desain',
            'export.filename': 'Nama file',
            'export.filenameHint': 'Nama file akan otomatis sesuai format yang dipilih (png/jpg/svg)',
            'export.format': 'Format',
            'export.size': 'Ukuran ekspor',
            'export.sizeMode.scale': 'Skala',
            'export.sizeMode.custom': 'Kustom',
            'export.widthPx': 'Lebar (px)',
            'export.heightPx': 'Tinggi (px)',
            'export.lockRatio': 'Pertahankan rasio',
            'export.quality': 'Kualitas',
            'export.canvasRadius': 'Radius sudut kanvas',

            'action.delete': 'Hapus',
            'props.canvasTitle': 'Kanvas',
            'props.selectHint': 'Pilih elemen di kanvas untuk melihat dan mengedit propertinya.',
            'props.width': 'Lebar',
            'props.height': 'Tinggi',
            'props.size': 'Ukuran',
            'props.background': 'Latar',
            'props.stroke': 'Garis tepi',
            'props.cornerRadius': 'Radius sudut',
            'props.rotation': 'Rotasi (°)',
            'props.opacity': 'Opasitas',
            'props.text.content': 'Konten',
            'props.text.inlineEditHint': 'klik dua kali untuk mengedit langsung',
            'props.text.font': 'Font',
            'props.text.clickToChooseHint': 'klik untuk memilih',
            'props.text.searchFont': 'Cari font...',
            'props.text.fontSize': 'Ukuran font',
            'props.text.style': 'Gaya teks',
            'props.text.bold': 'Tebal',
            'props.text.italic': 'Miring',
            'props.text.underline': 'Garis bawah',
            'props.text.shadow': 'Bayangan',
            'props.text.color': 'Warna teks',
            'props.text.background': 'Latar teks',

            'alert.imageProcessFail': 'Tidak dapat memproses gambar. Coba gambar lain.',
            'toast.logoMax': 'Logo maksimum {max}% dengan ECC {ecc}',
            'toast.geoNotSupported': 'Browser tidak mendukung geolokasi',
            'toast.geoGetting': 'Mengambil lokasi...',
            'toast.geoSuccess': 'Lokasi berhasil diambil!',
            'toast.geoFail': 'Tidak dapat mengambil lokasi: {msg}',
            'toast.fileTooLarge': 'File terlalu besar! Maks 5MB',
            'toast.fileUploading': 'Mengunggah file...',
            'toast.fileUploaded': 'Tautan unduhan dibuat!',
            'toast.uploadError': 'Kesalahan upload: {msg}',
            'toast.vietqrMissing': 'Masukkan nomor rekening dan pilih bank',
            'toast.sepaMissing': 'Masukkan nama penerima dan IBAN',
            'toast.sepaIbanInvalid': 'IBAN tidak valid',
            'toast.sepaBicInvalid': 'BIC/SWIFT tidak valid',
            'toast.sepaAmountInvalid': 'Jumlah EUR tidak valid',
            'toast.logoClampedMax': 'Logo dibatasi ke {used}% (maks {max}%)',
            'toast.logoClampedReadable': 'Logo dibatasi ke {used}% agar mudah dipindai',
            'toast.canvasFlipNotAllowedV': 'Kanvas tidak bisa dibalik vertikal',
            'toast.canvasFlipNotAllowedH': 'Kanvas tidak bisa dibalik horizontal',
            'toast.distributeNeed3': 'Butuh minimal 3 elemen untuk sebar',
            'toast.elementsLocked': 'Elemen dikunci',
            'toast.elementsUnlocked': 'Elemen dibuka kuncinya',
            'toast.canvasCannotCopy': 'Kanvas tidak bisa disalin',
            'toast.qrCannotCopy': 'QR tidak bisa disalin',
            'toast.copiedElements': 'Menyalin {count} elemen',
            'toast.canvasCannotPaste': 'Kanvas tidak bisa ditempel',
            'toast.qrCannotPaste': 'QR tidak bisa ditempel',
            'toast.canvasCannotDuplicate': 'Kanvas tidak bisa diduplikasi',
            'toast.qrCannotDuplicate': 'QR tidak bisa diduplikasi',
            'toast.canvasCannotDelete': 'Kanvas tidak bisa dihapus',
            'alert.pdfNoJsPdfPngInstead': 'Ekspor PDF membutuhkan pustaka jsPDF. Akan mengunduh PNG sebagai gantinya.',
            'alert.copySuccess': '✅ Tersalin!',
            'alert.copyFail': '❌ {msg}',
            'bank.scheme': 'Skema',
            'bank.scheme.vietqr': 'VietQR (VN)',
            'bank.scheme.sepa': 'SEPA (EPC)',
            'sepa.name': 'Nama penerima',
            'sepa.iban': 'IBAN',
            'sepa.bic': 'BIC/SWIFT (opsional)',
            'sepa.amount': 'Jumlah (EUR, opsional)',
            'sepa.purpose': 'Tujuan (opsional, 4 karakter)',
            'sepa.remittance': 'Pesan (opsional)',
            'sepa.info': 'Informasi (opsional)',
            'sepa.ph.name': 'mis. John Doe',
            'sepa.ph.iban': 'mis. DE89370400440532013000',
            'sepa.ph.bic': 'mis. DEUTDEFF',
            'sepa.ph.amount': 'mis. 12.34',
            'sepa.ph.purpose': 'mis. GDDS',
            'sepa.ph.remittance': 'mis. Invoice 123',
            'sepa.ph.info': '',
            'type.url': 'URL',
            'type.text': 'Teks',
            'type.wifi': 'WiFi',
            'type.email': 'Email',
            'type.phone': 'Telepon',
            'type.sms': 'SMS',
            'type.location': 'Lokasi',
            'type.vcard': 'vCard',
            'type.event': 'Acara',
            'type.vietqr': 'VietQR',
            'type.crypto': 'Crypto',
            'type.file': 'File',
          },
        };

      const applyI18n = (langOverride) => {
        const lang = langOverride || localStorage.getItem(LANG_KEY) || detectDefaultLang();
        document.documentElement.lang = lang;
        document.documentElement.dir = (lang === 'ar') ? 'rtl' : 'ltr';

        const dict = I18N[lang] || I18N.en || I18N.vi;
        const fallback = I18N.en || I18N.vi;
        const tr = (key) => dict[key] ?? fallback[key] ?? key;

        window.qrI18n = { lang, tr };
        window.getI18nText = (key) => tr(key);
        window.t = (key, vars) => {
          let s = tr(key);
          if (vars && typeof vars === 'object') {
            for (const [k, v] of Object.entries(vars)) {
              s = s.split(`{${k}}`).join(String(v));
            }
          }
          return s;
        };

        // Page-level strings
        document.title = tr('meta.title');
        const metaDesc = document.querySelector('meta[name="description"]');
        if (metaDesc) metaDesc.setAttribute('content', tr('meta.description'));
        const ogTitle = document.querySelector('meta[property="og:title"]');
        if (ogTitle) ogTitle.setAttribute('content', tr('meta.title'));
        const ogDesc = document.querySelector('meta[property="og:description"]');
        if (ogDesc) ogDesc.setAttribute('content', tr('meta.description'));
        const twDesc = document.querySelector('meta[name="twitter:description"]');
        if (twDesc) twDesc.setAttribute('content', tr('meta.description'));

        document.querySelectorAll('[data-i18n]').forEach(el => {
          const key = el.getAttribute('data-i18n');
          el.textContent = tr(key);
        });
        document.querySelectorAll('[data-i18n-title]').forEach(el => {
          const key = el.getAttribute('data-i18n-title');
          el.setAttribute('title', tr(key));
        });

        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
          const key = el.getAttribute('data-i18n-placeholder');
          el.setAttribute('placeholder', tr(key));
        });

        document.querySelectorAll('[data-i18n-aria]').forEach(el => {
          const key = el.getAttribute('data-i18n-aria');
          el.setAttribute('aria-label', tr(key));
        });

        // Update any dynamic labels that embed text directly
        if (typeof updateVersionDisplay === 'function') updateVersionDisplay();
        if (typeof renderToggleShapesBtn === 'function') renderToggleShapesBtn();
        if (typeof refreshShapesGridLabels === 'function') refreshShapesGridLabels();
        if (typeof showElementProps === 'function') showElementProps();
      };

      window.__qrApplyI18n = applyI18n;
      applyI18n();

      window.addEventListener('storage', (e) => {
        if (e.key === LANG_KEY) {
          applyI18n(e.newValue || undefined);
        }
      });

      // Ensure banking scheme UI is correct on load
      updateBankSchemeUI();

      initGuidesContainer();
      initSelectionBox();
      
      // Check for project in URL
      const projectIdFromURL = getProjectIdFromURL();
      if (projectIdFromURL) {
        currentProjectId = projectIdFromURL;
        if (!loadProject(projectIdFromURL)) {
          // Project not found, add default QR
          addQRElement();
        }
      } else {
        // New project - add default QR element
        addQRElement();
      }
      
      // Initialize history with current state
      history = [snapshotState()];
      historyIndex = 0;

      // Setup event listeners
      console.log('Setting up sidebar tabs...');
      setupSidebarTabs();
      console.log('Setting up QR type tabs...');
      setupQRTypeTabs();

      // Deep links: allow /generate/<type> or ?type=<type> to preselect QR type.
      // Do NOT override an existing saved project loaded via ?project=...
      if (!projectIdFromURL) {
        const initialType = getInitialQRTypeFromURL();
        if (initialType) applyInitialQRType(initialType);
      }

      console.log('Setting up color pickers...');
      setupColorPickers();
      console.log('Setting up pills...');
      setupPills();
      console.log('Setting up input listeners...');
      setupInputListeners();
      console.log('Setting up version control...');
      setupVersionControl();
      console.log('Setting up canvas events...');
      setupCanvasEvents();
      console.log('Setting up scroll zoom...');
      setupScrollZoom();
      console.log('Setting up logo upload...');
      setupLogoUpload();
      console.log('Setting up mobile menu...');
      setupMobileMenu();

      // Keep desktop/mobile project name inputs in sync
      syncProjectNameInputs();

      // Set a localized default project name (only if still empty)
      const pnDesktop = document.getElementById('project-name-desktop');
      const pnMobile = document.getElementById('project-name-mobile');
      const hasName = Boolean((pnDesktop?.value || '').trim() || (pnMobile?.value || '').trim());
      if (!hasName) {
        const defaultName = (typeof t === 'function') ? t('project.defaultName') : 'qr_design';
        setProjectNameValue(defaultName);
      }

      // Mobile-only zoom slider (in bottom panel header)
      setupMobileZoomSlider();

      // Generate initial QR
      console.log('Generating initial QR...');
      generateQR();
      showElementProps();
      updateCanvasTransform();
      updateZoomLabels();
      
      // Initialize shapes grid
      initShapesGrid();
      
      // Initialize floating toolbar
      updateFloatingToolbar();
      updateToolbarPosition();
      
      // Keep canvas centered and toolbar aligned on resize
      const handleViewportResize = () => {
        updateMobilePropsMode();
        if (typeof syncMoreMenuHost === 'function') syncMoreMenuHost();
        scheduleViewportUpdate(false);
      };
      window.addEventListener('resize', handleViewportResize);
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', handleViewportResize);
      }
      canvasWrapper.addEventListener('scroll', () => {
        if (canvasSelected) renderCanvasSelectionOverlay();
        if (wrapperSelectionBox && wrapperSelectionBox.style.display === 'block') {
          wrapperSelectionBox.style.display = 'none';
        }
      }, { passive: true });
      new ResizeObserver(handleViewportResize).observe(canvas);
      new ResizeObserver(handleViewportResize).observe(canvasWrapper);
      handleViewportResize();
      
      // Auto-fit canvas to viewport on initial load
      setTimeout(() => {
        scheduleViewportUpdate(window.innerWidth <= 750);
      }, 100);
      
      // Start auto-save
      startAutoSave();
      
      console.log('===== INIT COMPLETED =====');
    }
    
    // Mobile menu toggle
    function setupMobileMenu() {
      const toggle = document.getElementById('mobile-menu-toggle');
      const sidebar = document.getElementById('sidebar');
      const closeBtn = document.getElementById('mobile-close');
      const mainArea = document.querySelector('.main-area');
      const sidebarHeader = document.querySelector('.sidebar-header');

      const isMobileOrTablet = () => window.innerWidth <= 750;
      const isMobile = () => window.innerWidth <= 750;

      const applyState = (open) => {
        if (!sidebar) return;
        const shouldOpen = open || !isMobileOrTablet();
        sidebar.classList.toggle('open', shouldOpen);
        if (mainArea) {
          mainArea.classList.toggle('sidebar-collapsed', isMobileOrTablet() && !shouldOpen);
          mainArea.classList.toggle('sidebar-open', isMobileOrTablet() && shouldOpen);
        }
      };

      const handleToggle = () => {
        if (!sidebar) return;
        const nextOpen = !sidebar.classList.contains('open');
        applyState(nextOpen);
      };
      
      if (toggle && sidebar) {
        toggle.onclick = handleToggle;
      }
      
      if (closeBtn && sidebar) {
        closeBtn.onclick = (e) => {
          e.preventDefault();
          if (!isMobileOrTablet()) return;
          handleToggle();
        };
      }

      // Mobile UX: only the arrow button toggles the panel.
      // (Header contains interactive controls like zoom slider.)
      if (sidebarHeader) {
        sidebarHeader.onclick = null;
      }
      
      const handleResize = () => {
        if (!sidebar) return;
        if (isMobileOrTablet()) {
          if (closeBtn) closeBtn.style.display = 'block';
          // Start collapsed on mobile/tablet
          if (!sidebar.classList.contains('open')) {
            applyState(false);
          }
        } else {
          if (closeBtn) closeBtn.style.display = 'none';
          sidebar.classList.add('open');
          sidebar.classList.remove('collapsed');
          if (mainArea) {
            mainArea.classList.remove('sidebar-collapsed');
            mainArea.classList.remove('sidebar-open');
          }
        }
      };

      window.addEventListener('resize', handleResize);
      handleResize();
    }
    
    // Logo upload setup
    function setupLogoUpload() {
      const logoUpload = document.getElementById('qr-logo-upload');
      const logoSizeSlider = document.getElementById('logo-size');
      const logoSizeLabel = document.getElementById('logo-size-label');
      const logoRadiusSlider = document.getElementById('logo-radius');
      const logoRadiusLabel = document.getElementById('logo-radius-label');

      // Initialize limits based on current ECC
      syncLogoSizeConstraints(false);
      
      if (logoUpload) {
        logoUpload.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            // Show loading state
            document.getElementById('logo-preview').style.display = 'block';
            document.getElementById('logo-preview-img').src = '';
            document.getElementById('logo-preview-img').alt = 'Đang tải...';
            
            try {
              // Process image - resize if too large but maintain quality
              const processedData = await processLogoImage(file);
              qrLogoData = processedData;
              document.getElementById('logo-preview-img').src = qrLogoData;
              document.getElementById('logo-preview-img').alt = 'Logo';
              // Regenerate QR so backend can carve a quiet area beneath the logo
              generateQR();
            } catch (err) {
              console.error('Logo processing error:', err);
              alert((typeof t === 'function') ? t('alert.imageProcessFail') : 'Không thể xử lý ảnh. Vui lòng thử ảnh khác.');
              document.getElementById('logo-preview').style.display = 'none';
            }
          }
        };
      }
      
      if (logoSizeSlider) {
        // Debounce the slider to prevent lag
        let logoTimeout = null;
        logoSizeSlider.oninput = () => {
          const didClamp = syncLogoSizeConstraints(true);
          if (!didClamp) {
            qrLogoSize = parseInt(logoSizeSlider.value);
            if (logoSizeLabel) logoSizeLabel.textContent = qrLogoSize + '%';
          }
          
          // Debounce QR regeneration (quiet area depends on logo size)
          if (logoTimeout) clearTimeout(logoTimeout);
          logoTimeout = setTimeout(() => {
            if (qrLogoData) generateQR();
          }, 150);
        };
      }

      if (logoRadiusSlider) {
        // Debounce regeneration as rounding affects hole + logo mask
        let radiusTimeout = null;
        logoRadiusSlider.oninput = () => {
          qrLogoRadius = Math.max(0, Math.min(50, parseInt(logoRadiusSlider.value) || 0));
          if (logoRadiusLabel) logoRadiusLabel.textContent = qrLogoRadius + '%';
          if (radiusTimeout) clearTimeout(radiusTimeout);
          radiusTimeout = setTimeout(() => {
            if (qrLogoData) generateQR();
          }, 150);
        };
      }
    }
    
    // Process logo image - resize if too large
    async function processLogoImage(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (evt) => {
          const img = new Image();
          img.onload = () => {
            // Max size for logo processing
            const maxSize = 500;
            let width = img.width;
            let height = img.height;
            
            // Only resize if image is larger than maxSize
            if (width > maxSize || height > maxSize) {
              if (width > height) {
                height = Math.round(height * maxSize / width);
                width = maxSize;
              } else {
                width = Math.round(width * maxSize / height);
                height = maxSize;
              }
            }
            
            // Create canvas with high quality
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // Use high quality image smoothing
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0, width, height);
            
            // Export as PNG to preserve transparency
            resolve(canvas.toDataURL('image/png', 1.0));
          };
          img.onerror = () => reject(new Error('Failed to load image'));
          img.src = evt.target.result;
        };
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file);
      });
    }
    
    // Remove logo
    function removeLogo() {
      qrLogoData = null;
      document.getElementById('logo-preview').style.display = 'none';
      document.getElementById('qr-logo-upload').value = '';
      generateQR();
    }

    // Sidebar tabs
    function setupSidebarTabs() {
      document.querySelectorAll('.sidebar-tab').forEach(tab => {
        tab.onclick = () => {
          document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.sidebar-panel').forEach(p => p.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById('panel-' + tab.dataset.panel).classList.add('active');

          // Remember last non-props panel for mobile so we can return after auto-opening Properties.
          lastSidebarPanelId = 'panel-' + tab.dataset.panel;
          if (typeof isMobileViewport === 'function' && isMobileViewport()) {
            const tabs = document.querySelector('.sidebar-tabs');
            if (tabs) tabs.classList.remove('hidden');
          }
        };
      });
    }

    // QR type tabs
    function setupQRTypeTabs() {
      document.querySelectorAll('.type-btn').forEach(btn => {
        btn.onclick = () => {
          document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentQRType = btn.dataset.type;

          document.querySelectorAll('.special-form').forEach(f => f.classList.remove('active'));
          document.getElementById('form-' + currentQRType)?.classList.add('active');

          generateQR();
        };
      });
    }

    // Color pickers
    function setupColorPickers() {
      // QR color picker
      const qrColorInput = document.getElementById('qr-color');
      const qrColorPresets = document.getElementById('qr-color-presets');
      const qrBgColorInput = document.getElementById('qr-bg-color');
      const qrBgColorPresets = document.getElementById('qr-bg-presets');
      const canvasBgInput = document.getElementById('canvas-bg');
      const canvasBgPresets = document.getElementById('canvas-bg-presets');

      console.log('Color pickers found:', {
        qrColorInput: !!qrColorInput,
        qrColorPresets: !!qrColorPresets,
        qrBgColorInput: !!qrBgColorInput,
        qrBgColorPresets: !!qrBgColorPresets
      });

      // QR Color change
      if (qrColorInput) {
        qrColorInput.addEventListener('change', () => {
          console.log('QR color changed to:', qrColorInput.value);
          generateQR();
        });
        qrColorInput.addEventListener('input', () => {
          console.log('QR color input to:', qrColorInput.value);
          generateQR();
        });
      }

      // QR BG Color change
      if (qrBgColorInput) {
        qrBgColorInput.addEventListener('change', () => {
          console.log('QR BG color changed to:', qrBgColorInput.value);
          generateQR();
        });
        qrBgColorInput.addEventListener('input', () => {
          console.log('QR BG color input to:', qrBgColorInput.value);
          generateQR();
        });
      }

      // Canvas BG Color change
      if (canvasBgInput) {
        canvasBgInput.addEventListener('change', () => {
          console.log('Canvas BG color changed to:', canvasBgInput.value);
          updateCanvasBg(canvasBgInput.value, true);
        });
        canvasBgInput.addEventListener('input', () => {
          console.log('Canvas BG color input to:', canvasBgInput.value);
          updateCanvasBg(canvasBgInput.value, false);
        });
      }

      // QR Color Presets
      if (qrColorPresets) {
        qrColorPresets.querySelectorAll('.color-dot').forEach(dot => {
          dot.onclick = (e) => {
            e.preventDefault();
            const color = dot.dataset.color;
            console.log('QR preset clicked:', color);
            qrColorInput.value = color;
            qrColorPresets.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
            dot.classList.add('active');
            generateQR();
          };
        });
      }

      // QR BG Color Presets
      if (qrBgColorPresets) {
        qrBgColorPresets.querySelectorAll('.color-dot').forEach(dot => {
          dot.onclick = (e) => {
            e.preventDefault();
            const color = dot.dataset.color;
            console.log('QR BG preset clicked:', color);
            qrBgColorInput.value = color;
            qrBgColorPresets.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
            dot.classList.add('active');
            generateQR();
          };
        });
      }

      // Canvas BG Color Presets
      if (canvasBgPresets) {
        canvasBgPresets.querySelectorAll('.color-dot').forEach(dot => {
          dot.onclick = (e) => {
            e.preventDefault();
            const color = dot.dataset.color;
            console.log('Canvas BG preset clicked:', color);
            if (canvasBgInput) canvasBgInput.value = color;
            canvasBgPresets.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
            dot.classList.add('active');
            updateCanvasBg(color, true);
          };
        });
      }
    }

    // Pills
    function setupPills() {
      ['dot-pills', 'ecc-pills', 'eye-pills'].forEach(id => {
        const row = document.getElementById(id);
        if (!row) return;
        row.addEventListener('click', (e) => {
          const pill = e.target.closest('.pill');
          if (!pill) return;
          row.querySelectorAll('.pill').forEach(p => p.classList.remove('active'));
          pill.classList.add('active');
          if (id === 'dot-pills') {
            currentModuleStyle = pill.dataset.module || currentModuleStyle;
          }
          if (id === 'eye-pills') {
            currentEyeStyle = pill.dataset.eye || currentEyeStyle;
          }
          if (id === 'ecc-pills') {
            // ECC affects how large a logo (and the carved hole) can be while still scanning.
            const didClamp = syncLogoSizeConstraints(true);
            if (qrLogoData && didClamp) {
              generateQR();
              return;
            }
          }
          generateQR();
        });
      });
    }

    function getCurrentECC() {
      return document.querySelector('#ecc-pills .pill.active')?.dataset.ecc || 'H';
    }

    function getMaxLogoPercentByECC(ecc) {
      switch ((ecc || 'H').toUpperCase()) {
        case 'L': return 14;
        case 'M': return 18;
        case 'Q': return 22;
        case 'H':
        default: return 25;
      }
    }

    let lastLogoClampToastAt = 0;
    function syncLogoSizeConstraints(showToastOnClamp = false) {
      const slider = document.getElementById('logo-size');
      const label = document.getElementById('logo-size-label');
      if (!slider) return false;

      const maxAllowed = getMaxLogoPercentByECC(getCurrentECC());
      slider.max = String(maxAllowed);

      const current = parseInt(slider.value) || qrLogoSize || 25;
      if (current <= maxAllowed) {
        qrLogoSize = current;
        if (label) label.textContent = qrLogoSize + '%';
        return false;
      }

      qrLogoSize = maxAllowed;
      slider.value = String(maxAllowed);
      if (label) label.textContent = qrLogoSize + '%';

      if (showToastOnClamp) {
        const now = Date.now();
        if (now - lastLogoClampToastAt > 1800) {
          lastLogoClampToastAt = now;
          showToast((typeof t === 'function') ? t('toast.logoMax', { max: maxAllowed, ecc: getCurrentECC() }) : `Logo tối đa ${maxAllowed}% với ECC ${getCurrentECC()}`);
        }
      }
      return true;
    }

    // Debounce utility to reduce rapid calls
    function debounce(fn, delay = 400) {
      let timer;
      return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }
    const debouncedGenerateQR = debounce(generateQR, 400);

    // Input listeners
    function setupInputListeners() {
      const inputs = [
        'input-url', 'input-text', 'input-phone',
        'wifi-ssid', 'wifi-password', 'wifi-security',
        'email-address', 'email-subject', 'email-body',
        'sms-phone', 'sms-message',

        // Location
        'loc-lat', 'loc-lng', 'loc-name',

        // vCard
        'vcard-lastname', 'vcard-firstname', 'vcard-org', 'vcard-title',
        'vcard-phone', 'vcard-email', 'vcard-url', 'vcard-address',

        // Event
        'event-title', 'event-location', 'event-start', 'event-end', 'event-desc',

        // VietQR
  'bank-scheme', 'vietqr-bank', 'vietqr-account', 'vietqr-name', 'vietqr-amount', 'vietqr-memo',

  // SEPA (EPC)
  'sepa-name', 'sepa-iban', 'sepa-bic', 'sepa-amount', 'sepa-purpose', 'sepa-remittance', 'sepa-info',

        // Crypto
        'crypto-type', 'crypto-address', 'crypto-amount', 'crypto-label',

        // File
        'file-direct-url'
      ];

      inputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          el.oninput = () => debouncedGenerateQR();
          el.onchange = () => generateQR();
        }
      });

      // Bank scheme UI toggle
      const bankSchemeEl = document.getElementById('bank-scheme');
      if (bankSchemeEl) {
        bankSchemeEl.addEventListener('change', () => {
          updateBankSchemeUI();
          generateQR();
        });
      }
      
      // QR customization sliders
      setupQRCustomizationSliders();
    }

    function getBankScheme() {
      return document.getElementById('bank-scheme')?.value || 'vietqr';
    }

    function updateBankSchemeUI() {
      const scheme = getBankScheme();
      const vietqrFields = document.getElementById('bank-vietqr-fields');
      const sepaFields = document.getElementById('bank-sepa-fields');
      if (vietqrFields) vietqrFields.style.display = scheme === 'vietqr' ? '' : 'none';
      if (sepaFields) sepaFields.style.display = scheme === 'sepa' ? '' : 'none';
    }
    
    function setupQRCustomizationSliders() {
      // Dot gap slider
      const dotGapSlider = document.getElementById('qr-dot-gap');
      const dotGapLabel = document.getElementById('dot-gap-label');
      if (dotGapSlider) {
        dotGapSlider.oninput = () => {
          qrDotGap = parseInt(dotGapSlider.value);
          if (dotGapLabel) dotGapLabel.textContent = qrDotGap + '%';
        };
        dotGapSlider.onchange = () => generateQR();
      }
      
      // Eye thickness slider
      const eyeThicknessSlider = document.getElementById('qr-eye-thickness');
      const eyeThicknessLabel = document.getElementById('eye-thickness-label');
      if (eyeThicknessSlider) {
        eyeThicknessSlider.oninput = () => {
          qrEyeThickness = parseInt(eyeThicknessSlider.value);
          if (eyeThicknessLabel) eyeThicknessLabel.textContent = qrEyeThickness + '%';
        };
        eyeThicknessSlider.onchange = () => generateQR();
      }
    }

    function getModuleCountForVersion(version) {
      return 17 + 4 * version;
    }

    function updateVersionDisplay() {
      const label = document.getElementById('version-label');
      const hint = document.getElementById('version-hint');
      const moduleCount = getModuleCountForVersion(currentQRVersion);
      if (label) label.textContent = ` ${currentQRVersion}`;
      if (hint) {
        const unit = (typeof getI18nText === 'function') ? getI18nText('qr.gridUnit') : 'ô vuông';
        hint.textContent = `${moduleCount} × ${moduleCount} ${unit}`;
      }
    }

    function setupVersionControl() {
      const slider = document.getElementById('qr-version');
      if (!slider) return;
      slider.value = currentQRVersion;

      const applyVersionValue = () => {
        currentQRVersion = Math.max(1, Math.min(12, parseInt(slider.value) || 1));
        updateVersionDisplay();
      };

      slider.addEventListener('input', () => {
        applyVersionValue();
      });

      slider.addEventListener('change', () => {
        applyVersionValue();
        generateQR();
      });
      updateVersionDisplay();
    }

    // Get QR data
    function getQRData() {
      switch (currentQRType) {
        case 'url': return document.getElementById('input-url').value || 'https:/qrio.site';
        case 'text': return document.getElementById('input-text').value || 'Hello';
        case 'phone':
          const p = document.getElementById('input-phone').value;
          return p ? 'tel:' + p : 'tel:+84123456789';
        case 'wifi':
          const ssid = document.getElementById('wifi-ssid').value || 'WiFi';
          const pass = document.getElementById('wifi-password').value || '';
          const sec = document.getElementById('wifi-security').value;
          return `WIFI:T:${sec};S:${ssid};P:${pass};;`;
        case 'email':
          const email = document.getElementById('email-address').value || 'test@test.com';
          const subj = encodeURIComponent(document.getElementById('email-subject').value || '');
          const body = encodeURIComponent(document.getElementById('email-body').value || '');
          return `mailto:${email}?subject=${subj}&body=${body}`;
        case 'sms':
          const smsP = document.getElementById('sms-phone').value || '';
          const msg = encodeURIComponent(document.getElementById('sms-message').value || '');
          return `sms:${smsP}?body=${msg}`;
        case 'location':
          const lat = document.getElementById('loc-lat').value || '21.0285';
          const lng = document.getElementById('loc-lng').value || '105.8542';
          const latNum = Number.parseFloat(lat);
          const lngNum = Number.parseFloat(lng);
          const safeLat = Number.isFinite(latNum) ? latNum : 21.0285;
          const safeLng = Number.isFinite(lngNum) ? lngNum : 105.8542;
          // Use the standard geo URI format.
          return `geo:${safeLat.toFixed(6)},${safeLng.toFixed(6)}`;
        case 'vcard':
          return generateVCard();
        case 'event':
          return generateVEvent();
        case 'vietqr':
          // Banking: VietQR is generated server-side via VietQR API; SEPA is EPC payload generated locally.
          if (getBankScheme() === 'sepa') {
            return generateSEPA();
          }
          return 'VietQR';
        case 'crypto':
          return generateCryptoURI();
        case 'file':
          const directUrl = document.getElementById('file-direct-url').value;
          if (directUrl) return directUrl;
          if (uploadedFileUrl) return uploadedFileUrl;
          return window.location.origin;
        default: return 'https://qrio.site';
      }
    }

    function normalizeSEPAField(v, maxLen) {
      let s = String(v || '').replace(/[\r\n]+/g, ' ').trim();
      if (typeof maxLen === 'number' && maxLen > 0) s = s.slice(0, maxLen);
      return s;
    }

    function normalizeIBAN(v) {
      return String(v || '').replace(/\s+/g, '').toUpperCase();
    }

    function normalizeBIC(v) {
      return String(v || '').replace(/\s+/g, '').toUpperCase();
    }

    function formatSepaAmount(amountStr) {
      const raw = String(amountStr || '').trim();
      if (!raw) return '';
      const normalized = raw.replace(',', '.');
      const n = Number.parseFloat(normalized);
      if (!Number.isFinite(n) || n <= 0) return null;
      // EPC examples typically use dot decimal, up to 2 decimals.
      const fixed = Math.round(n * 100) / 100;
      return 'EUR' + fixed.toFixed(2);
    }

    // SEPA/EPC QR payload (SCT)
    function generateSEPA() {
      const name = normalizeSEPAField(document.getElementById('sepa-name')?.value, 70);
      const iban = normalizeIBAN(document.getElementById('sepa-iban')?.value);
      const bic = normalizeBIC(document.getElementById('sepa-bic')?.value);
      const amount = formatSepaAmount(document.getElementById('sepa-amount')?.value);
      const purposeRaw = normalizeSEPAField(document.getElementById('sepa-purpose')?.value, 4).toUpperCase();
      const purpose = /^[A-Z0-9]{0,4}$/.test(purposeRaw) ? purposeRaw : '';
      const remittance = normalizeSEPAField(document.getElementById('sepa-remittance')?.value, 140);
      const info = normalizeSEPAField(document.getElementById('sepa-info')?.value, 70);

      // Minimal validation is performed before calling this function.
      const amountLine = amount || '';

      // EPC/SEPA requires fixed lines; keep empty lines if missing.
      const lines = [
        'BCD',
        '001',
        '1',
        'SCT',
        bic || '',
        name || '',
        iban || '',
        amountLine,
        purpose || '',
        remittance || '',
        info || ''
      ];
      return lines.join('\n');
    }
    
    function escapeVCardValue(v) {
      return String(v || '')
        .replace(/\\/g, '\\\\')
        .replace(/\r\n|\r|\n/g, '\\n')
        .replace(/;/g, '\\;')
        .replace(/,/g, '\\,');
    }

    // Helper function for vCard
    function generateVCard() {
      const fn = document.getElementById('vcard-firstname').value || '';
      const ln = document.getElementById('vcard-lastname').value || '';
      const org = document.getElementById('vcard-org').value || '';
      const title = document.getElementById('vcard-title').value || '';
      const phone = document.getElementById('vcard-phone').value || '';
      const email = document.getElementById('vcard-email').value || '';
      const url = document.getElementById('vcard-url').value || '';
      const addr = document.getElementById('vcard-address').value || '';
      
      let vcard = 'BEGIN:VCARD\r\nVERSION:3.0\r\n';
      if (fn || ln) vcard += `N:${escapeVCardValue(ln)};${escapeVCardValue(fn)};;;\r\n`;
      if (fn || ln) vcard += `FN:${escapeVCardValue(`${fn} ${ln}`.trim())}\r\n`;
      if (org) vcard += `ORG:${escapeVCardValue(org)}\r\n`;
      if (title) vcard += `TITLE:${escapeVCardValue(title)}\r\n`;
      if (phone) vcard += `TEL;TYPE=WORK,VOICE:${escapeVCardValue(phone)}\r\n`;
      if (email) vcard += `EMAIL;TYPE=PREF,INTERNET:${escapeVCardValue(email)}\r\n`;
      if (url) vcard += `URL:${escapeVCardValue(url)}\r\n`;
      if (addr) vcard += `ADR;TYPE=WORK:;;${escapeVCardValue(addr).replace(/\\n/g, ', ')};;;;\r\n`;
      vcard += 'END:VCARD';
      return vcard;
    }

    function escapeICalValue(v) {
      return String(v || '')
        .replace(/\\/g, '\\\\')
        .replace(/\r\n|\r|\n/g, '\\n')
        .replace(/;/g, '\\;')
        .replace(/,/g, '\\,');
    }

    function formatICalLocal(dateStr) {
      if (!dateStr) return '';
      // datetime-local returns local time (no timezone). Keep it as a floating local time.
      const d = new Date(dateStr);
      if (Number.isNaN(d.getTime())) return '';
      const pad = (n) => String(n).padStart(2, '0');
      return (
        d.getFullYear() +
        pad(d.getMonth() + 1) +
        pad(d.getDate()) +
        'T' +
        pad(d.getHours()) +
        pad(d.getMinutes()) +
        pad(d.getSeconds())
      );
    }
    
    // Helper function for Calendar Event
    function generateVEvent() {
      const title = document.getElementById('event-title').value || 'Event';
      const location = document.getElementById('event-location').value || '';
      const startInput = document.getElementById('event-start').value;
      const endInput = document.getElementById('event-end').value;
      const desc = document.getElementById('event-desc').value || '';

      const now = new Date();
      const defaultStart = new Date(now.getTime() + 5 * 60 * 1000);
      const defaultEnd = new Date(defaultStart.getTime() + 60 * 60 * 1000);

      const start = formatICalLocal(startInput) || formatICalLocal(defaultStart);
      const end = formatICalLocal(endInput) || formatICalLocal(defaultEnd);

      let vevent = 'BEGIN:VCALENDAR\r\nVERSION:2.0\r\nBEGIN:VEVENT\r\n';
      vevent += `SUMMARY:${escapeICalValue(title)}\r\n`;
      vevent += `DTSTART:${start}\r\n`;
      vevent += `DTEND:${end}\r\n`;
      if (location) vevent += `LOCATION:${escapeICalValue(location)}\r\n`;
      if (desc) vevent += `DESCRIPTION:${escapeICalValue(desc)}\r\n`;
      vevent += 'END:VEVENT\r\nEND:VCALENDAR';
      return vevent;
    }
    
    // CRC-16 CCITT calculation for VietQR
    function calculateCRC16(str) {
      let crc = 0xFFFF;
      for (let i = 0; i < str.length; i++) {
        crc ^= str.charCodeAt(i) << 8;
        for (let j = 0; j < 8; j++) {
          if (crc & 0x8000) {
            crc = (crc << 1) ^ 0x1021;
          } else {
            crc <<= 1;
          }
          crc &= 0xFFFF;
        }
      }
      return crc.toString(16).toUpperCase().padStart(4, '0');
    }
    
    // Helper function for Crypto URI
    function generateCryptoURI() {
      const type = document.getElementById('crypto-type').value || 'bitcoin';
      const address = document.getElementById('crypto-address').value || '';
      const amount = document.getElementById('crypto-amount').value || '';
      const label = document.getElementById('crypto-label').value || '';
      
      if (!address) return 'https://qrio.site';
      
      let uri = `${type}:${address}`;
      const params = [];
      if (amount) params.push(`amount=${amount}`);
      if (label) params.push(`label=${encodeURIComponent(label)}`);
      if (params.length > 0) uri += '?' + params.join('&');
      
      return uri;
    }
    
    // Get current location for Location QR
    function getCurrentLocation() {
      if (!navigator.geolocation) {
        showToast((typeof t === 'function') ? t('toast.geoNotSupported') : 'Trình duyệt không hỗ trợ định vị');
        return;
      }
      
      showToast((typeof t === 'function') ? t('toast.geoGetting') : 'Đang lấy vị trí...');
      navigator.geolocation.getCurrentPosition(
        (position) => {
          document.getElementById('loc-lat').value = position.coords.latitude.toFixed(6);
          document.getElementById('loc-lng').value = position.coords.longitude.toFixed(6);
          showToast((typeof t === 'function') ? t('toast.geoSuccess') : 'Đã lấy vị trí thành công!');
          generateQR();
        },
        (error) => {
          showToast((typeof t === 'function') ? t('toast.geoFail', { msg: error.message }) : ('Không thể lấy vị trí: ' + error.message));
        },
        { enableHighAccuracy: true }
      );
    }
    
    // File upload handling
    let uploadedFileUrl = '';
    let uploadedFileData = null;
    
    async function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Check file size (5MB limit)
      if (file.size > 5 * 1024 * 1024) {
        showToast((typeof t === 'function') ? t('toast.fileTooLarge') : 'File quá lớn! Tối đa 5MB');
        return;
      }
      
      // Show preview
      document.getElementById('file-upload-preview').style.display = 'block';
      document.getElementById('uploaded-file-name').textContent = file.name;
      document.getElementById('file-size').textContent = formatFileSize(file.size);
      
      // Upload to backend and get a real download URL
      try {
        showToast((typeof t === 'function') ? t('toast.fileUploading') : 'Đang tải file lên...');
        const fd = new FormData();
        fd.append('file', file);
        const res = await fetch('/api/file/upload', { method: 'POST', body: fd });
        const payload = await res.json().catch(() => ({}));
        if (!res.ok) throw new Error(payload.error || 'Upload thất bại');
        uploadedFileData = null;
        uploadedFileUrl = payload.url || '';
        if (!uploadedFileUrl) throw new Error('Không nhận được link download');
        showToast((typeof t === 'function') ? t('toast.fileUploaded') : 'Đã tạo link tải file!');
        generateQR();
      } catch (e) {
        uploadedFileUrl = '';
        uploadedFileData = null;
        showToast((typeof t === 'function') ? t('toast.uploadError', { msg: (e?.message || e) }) : ('Upload lỗi: ' + (e?.message || e)));
      }
    }
    
    function removeUploadedFile() {
      uploadedFileUrl = '';
      uploadedFileData = null;
      document.getElementById('file-upload-input').value = '';
      document.getElementById('file-upload-preview').style.display = 'none';
      generateQR();
    }
    
    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Generate QR
    async function generateQR() {
      const qrEl = elements.find(e => e.type === 'qr');
      if (!qrEl) return;

      const el = document.getElementById(qrEl.id);
      if (!el) return;

      const content = el.querySelector('.qr-content');
      content.innerHTML = '<span class="qr-loading">⏳</span>';

      const qrColor = document.getElementById('qr-color').value;
      const bgColor = document.getElementById('qr-bg-color').value;
      const moduleStyle = document.querySelector('#dot-pills .pill.active')?.dataset.module || currentModuleStyle;
      const eccLevel = document.querySelector('#ecc-pills .pill.active')?.dataset.ecc || 'H';
      currentModuleStyle = moduleStyle;
      // Basic pre-validation for Banking schemes.
      let bankScheme = null;
      if (currentQRType === 'vietqr') {
        bankScheme = getBankScheme();
        if (bankScheme === 'vietqr') {
          const account = document.getElementById('vietqr-account')?.value || '';
          const bank = document.getElementById('vietqr-bank')?.value || '';
          if (!account.trim() || !bank.trim()) {
            content.innerHTML = '<span class="qr-loading" style="color:#f59e0b">⚠️</span>';
            showToast((typeof t === 'function') ? t('toast.vietqrMissing') : 'Vui lòng nhập Số tài khoản và chọn Ngân hàng');
            return;
          }
        } else if (bankScheme === 'sepa') {
          const name = (document.getElementById('sepa-name')?.value || '').trim();
          const iban = normalizeIBAN(document.getElementById('sepa-iban')?.value || '');
          const amountStr = document.getElementById('sepa-amount')?.value || '';
          const amount = formatSepaAmount(amountStr);

          if (!name || !iban) {
            content.innerHTML = '<span class="qr-loading" style="color:#f59e0b">⚠️</span>';
            showToast((typeof t === 'function') ? t('toast.sepaMissing') : 'Vui lòng nhập Tên người nhận và IBAN');
            return;
          }
          if (iban && !/^[A-Z]{2}[0-9A-Z]{13,32}$/.test(iban)) {
            content.innerHTML = '<span class="qr-loading" style="color:#f59e0b">⚠️</span>';
            showToast((typeof t === 'function') ? t('toast.sepaIbanInvalid') : 'IBAN không hợp lệ');
            return;
          }
          const bic = normalizeBIC(document.getElementById('sepa-bic')?.value || '');
          if (bic && !/^[A-Z0-9]{8}([A-Z0-9]{3})?$/.test(bic)) {
            content.innerHTML = '<span class="qr-loading" style="color:#f59e0b">⚠️</span>';
            showToast((typeof t === 'function') ? t('toast.sepaBicInvalid') : 'BIC/SWIFT không hợp lệ');
            return;
          }
          if (String(amountStr || '').trim() && amount === null) {
            content.innerHTML = '<span class="qr-loading" style="color:#f59e0b">⚠️</span>';
            showToast((typeof t === 'function') ? t('toast.sepaAmountInvalid') : 'Số tiền EUR không hợp lệ');
            return;
          }
        }
      }

      const qrData = getQRData();

      // Ensure logo size is within safe bounds for the selected ECC
      syncLogoSizeConstraints(false);

      const eyeStyle = document.querySelector('#eye-pills .pill.active')?.dataset.eye || currentEyeStyle;
      currentEyeStyle = eyeStyle;

      // Normalize slider percentages to backend-friendly ratios
      const dotScale = 1; // fixed (removed dot density control)
      const dotGap = Math.max(0, Math.min(0.5, qrDotGap / 100));
      const eyeThickness = Math.max(0.7, Math.min(2, qrEyeThickness / 100));

      console.log('generateQR called with:', {
        data: qrData,
        qr_color: qrColor,
        bg_color: bgColor,
        module_style: moduleStyle,
        eye_style: eyeStyle,
        ecc_level: eccLevel,
        version: currentQRVersion
      });

      const formData = new FormData();
      formData.append('data', qrData);

      // If user chose SEPA inside the banking panel, send as plain text to backend.
      let qrTypeToSend = currentQRType;
      if (currentQRType === 'vietqr' && (bankScheme || getBankScheme()) === 'sepa') {
        qrTypeToSend = 'text';
      }
      formData.append('qr_type', qrTypeToSend);
      formData.append('qr_color', qrColor);
      formData.append('bg_color', bgColor);
      formData.append('box_size', '15');
      formData.append('border', '2');
      formData.append('dot_type', 'rounded');
      formData.append('ecc_level', eccLevel);
      formData.append('version', currentQRVersion.toString());
      formData.append('module_style', moduleStyle);
      formData.append('eye_style', eyeStyle);
      formData.append('logo_size', qrLogoSize.toString());
      formData.append('logo_radius', qrLogoRadius.toString());
      formData.append('dot_scale', dotScale.toString());
      formData.append('dot_gap', dotGap.toString());
      formData.append('eye_thickness', eyeThickness.toString());

      // VietQR fields (used by backend to call VietQR API)
      if (currentQRType === 'vietqr' && (bankScheme || getBankScheme()) === 'vietqr') {
        formData.append('vietqr_bank', document.getElementById('vietqr-bank')?.value || '');
        formData.append('vietqr_account', document.getElementById('vietqr-account')?.value || '');
        formData.append('vietqr_name', document.getElementById('vietqr-name')?.value || '');
        formData.append('vietqr_amount', document.getElementById('vietqr-amount')?.value || '');
        formData.append('vietqr_memo', document.getElementById('vietqr-memo')?.value || '');
      }

      // Add logo if available (backend will also carve quiet area under it)
      if (qrLogoData) {
        const logoBlob = dataUrlToBlob(qrLogoData);
        if (logoBlob && logoBlob.size > 2 * 1024 * 1024) {
          showToast((typeof t === 'function') ? t('toast.logoTooLarge2mb') : 'Logo quá lớn (tối đa 2MB). Vui lòng chọn ảnh nhỏ hơn.');
          content.innerHTML = '<span class="qr-loading" style="color:#f43f5e">❌</span>';
          return;
        }
        formData.append('logo', logoBlob, 'logo.png');
      }

      try {
        const res = await fetch('/api/generate', { method: 'POST', body: formData });
        const result = await res.json();
        console.log('API response:', result);
        if (result.error) {
          showToast(result.error);
        }
        if (result.image) {
          qrImageCache = result.image; // Cache the image
          content.innerHTML = `<img class="qr-base" src="${result.image}" alt="QR" />`;

          // Backend may clamp logo size for scan safety; reflect it in UI.
          if (result.logo_size_clamped && typeof result.logo_size_used === 'number') {
            const slider = document.getElementById('logo-size');
            const label = document.getElementById('logo-size-label');
            qrLogoSize = result.logo_size_used;
            if (slider) slider.value = String(qrLogoSize);
            if (label) label.textContent = qrLogoSize + '%';
            if (typeof result.logo_size_max === 'number') {
              showToast((typeof t === 'function') ? t('toast.logoClampedMax', { used: result.logo_size_used, max: result.logo_size_max }) : `Logo đã giới hạn ${result.logo_size_used}% (tối đa ${result.logo_size_max}%)`);
            } else {
              showToast((typeof t === 'function') ? t('toast.logoClampedReadable', { used: result.logo_size_used }) : `Logo đã giới hạn ${result.logo_size_used}% để dễ quét`);
            }
            // Keep slider max in sync too
            syncLogoSizeConstraints(false);
          }
        } else {
          content.innerHTML = '<span class="qr-loading" style="color:#f43f5e">❌</span>';
        }
        // Update toolbar position after QR renders
        updateToolbarPosition();
      } catch (err) {
        console.error('Fetch error:', err);
        content.innerHTML = '<span class="qr-loading" style="color:#f43f5e">❌</span>';
      }
    }

    function dataUrlToBlob(dataUrl) {
      try {
        const s = String(dataUrl || '');
        const comma = s.indexOf(',');
        if (comma < 0) return null;

        const header = s.slice(0, comma);
        const b64 = s.slice(comma + 1);
        const mimeMatch = header.match(/^data:([^;]+);base64$/i);
        const mime = mimeMatch ? mimeMatch[1] : 'application/octet-stream';

        const binStr = atob(b64);
        const len = binStr.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binStr.charCodeAt(i);
        return new Blob([bytes], { type: mime });
      } catch {
        return null;
      }
    }

    // Add QR element
    function addQRElement() {
      const id = 'el-' + Date.now();
      const size = 200;
      const canvasRect = canvas.getBoundingClientRect();
      const canvasW = parseInt(canvas.style.width);
      const canvasH = parseInt(canvas.style.height);

      saveToHistory();
      elements.push({
        id, type: 'qr',
        x: (canvasW - size) / 2,
        y: (canvasH - size) / 2,
        width: size,
        height: size,
        rotation: 0,
        opacity: 100
      });

      renderElements();
      updateEmptyQRNotice();
      updateQRPanelVisibility();
      generateQR();
    }

    // Helpers for text-based glyphs (numbers/letters) and solid music icons
    const textShapeSvg = (char) => `
      <svg viewBox="0 0 100 100" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <text x="50" y="55" text-anchor="middle" dominant-baseline="middle" font-family="Be Vietnam Pro, sans-serif" font-weight="800" font-size="64" fill="currentColor">${char}</text>
      </svg>
    `;
    const musicNoteSvg = `
      <svg viewBox="0 0 100 100" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <path fill="currentColor" d="M62 18v39.5a15 15 0 1 1-6-11.8V26l24-5v12l-14 3V18z" />
        <circle cx="41" cy="65" r="11" fill="currentColor" />
      </svg>
    `;
    const musicDoubleSvg = `
      <svg viewBox="0 0 100 100" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <path fill="currentColor" d="M36 54.5v18.5a13 13 0 1 1-6-11V41l26-5v18.5a13 13 0 1 1-6-11V31l26-5v14l-16 3.5V62a13 13 0 1 1-6-11V28.5z" />
      </svg>
    `;
    const solidSvg = (paths, viewBox = '0 0 24 24') => {
      const pathContent = Array.isArray(paths)
        ? paths.map(d => `<path fill="currentColor" d="${d}" />`).join('')
        : `<path fill="currentColor" d="${paths}" />`;
      return `
        <svg viewBox="${viewBox}" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
          ${pathContent}
        </svg>
      `;
    };

    // Generic SVG loader for external icon sets (Phosphor)
    const svgCache = new Map();
    function normalizeSvgColors(svgText) {
      let normalized = svgText
        .replace(/stroke="(?!none)[^"]*"/gi, 'stroke="currentColor"')
        .replace(/fill="(?!none)[^"]*"/gi, 'fill="currentColor"');
      normalized = normalized.replace(/<svg([^>]*?)>/i, '<svg$1 width="100%" height="100%" preserveAspectRatio="xMidYMid meet">');
      return normalized;
    }
    async function loadSvg(path) {
      const cacheKey = String(new URL(path, window.location.href));
      if (svgCache.has(cacheKey)) return svgCache.get(cacheKey);
      const res = await fetch(cacheKey);
      if (!res.ok) throw new Error(`SVG load failed: ${res.status}`);
      const text = await res.text();
      const normalized = normalizeSvgColors(text);
      svgCache.set(cacheKey, normalized);
      return normalized;
    }

    function setSvgMask(el, svgUrl, fillColor) {
      if (!el) return;
      const url = String(new URL(svgUrl, window.location.href));

      // file:// origins often block fetch() for local assets; <img> works reliably.
      if (window.location.protocol === 'file:') {
        clearSvgMask(el);
        el.innerHTML = `<img src="${url}" alt="" style="width:100%;height:100%;object-fit:contain;" />`;
        return;
      }

      el.innerHTML = '';
      el.style.backgroundColor = fillColor || 'currentColor';
      el.style.setProperty('-webkit-mask', `url(\"${url}\") center / contain no-repeat`);
      el.style.setProperty('mask', `url(\"${url}\") center / contain no-repeat`);
    }

    function clearSvgMask(el) {
      if (!el) return;
      el.style.removeProperty('-webkit-mask');
      el.style.removeProperty('mask');
      el.style.removeProperty('background-color');
    }

    function titleCaseFromSlug(slug) {
      return String(slug || '')
        .split('-')
        .filter(Boolean)
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join(' ');
    }

    function deriveEnglishShapeLabel(shape) {
      const id = shape?.id || '';
      if (!id) return shape?.name || '';
      if (id.startsWith('num-')) return `Number ${id.slice(4)}`;
      if (id.startsWith('letter-')) return `Letter ${String(id.slice(7) || '').toUpperCase()}`;
      if (id.startsWith('lucide-')) {
        const iconName = shape?.icon || id.slice(7);
        return titleCaseFromSlug(iconName);
      }
      const cleaned = id
        .replace(/^ph-/, '')
        .replace(/-solid$/, '')
        .replace(/-simple$/, '');
      return titleCaseFromSlug(cleaned);
    }

    function getShapeLabel(shape) {
      const fallbackName = shape?.name || shape?.id || '';
      if (typeof getI18nText !== 'function' || !shape?.id) return fallbackName;
      const key = `shape.${shape.id}`;
      const label = getI18nText(key);
      if (label && label !== key) return label;

      const lang = (window.qrI18n?.lang || localStorage.getItem('qr_lang') || 'en').toLowerCase();
      if (lang.startsWith('vi')) return fallbackName;

      const derived = deriveEnglishShapeLabel(shape);
      return derived || fallbackName;
    }

    // Phosphor icon set removed per request.


    // Shape catalog with simple base shapes + open-source icons
    const shapesCatalog = [
      // Basic shapes (first 9 shown by default)
      { id: 'rect', name: 'Vuông', style: '' },
      { id: 'rounded', name: 'Bo góc', style: 'border-radius:8px;' },
      { id: 'circle', name: 'Tròn', style: 'border-radius:50%;' },
      { id: 'pill', name: 'Pill', style: 'border-radius:999px;' },
      { id: 'triangle', name: 'Tam giác', style: 'clip-path:polygon(50% 0%, 0% 100%, 100% 100%);' },
      { id: 'triangle-down', name: 'Tam giác ngược', style: 'clip-path:polygon(50% 100%, 0% 0%, 100% 0%);' },
      { id: 'diamond', name: 'Kim cương', style: 'clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);' },
      { id: 'pentagon', name: 'Ngũ giác', style: 'clip-path:polygon(50% 0%, 100% 38%, 81% 100%, 19% 100%, 0% 38%);' },
      { id: 'hexagon', name: 'Lục giác', style: 'clip-path:polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);' },
      { id: 'star', name: 'Sao', style: 'clip-path:polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);' },
      { id: 'star-4', name: 'Sao 4', style: 'clip-path:polygon(50% 0%, 63% 37%, 100% 50%, 63% 63%, 50% 100%, 37% 63%, 0% 50%, 37% 37%);' },
      { id: 'heart', name: 'Trái tim', svg: solidSvg('M12 21.35 10.55 20.03C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.53L12 21.35Z') },
      { id: 'shield-check-solid', name: 'Khiên', svg: solidSvg(['M12 2 4 5v6c0 5.25 3.5 10.74 8 12 4.5-1.26 8-6.75 8-12V5l-8-3Z', 'M11 15 8 12l1.41-1.41L11 12.17l3.59-3.58L16 10l-5 5z']) },
      { id: 'user-solid', name: 'Người dùng', svg: solidSvg(['M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4Z', 'M4 19c0-3.31 3.58-5 8-5s8 1.69 8 5v2H4v-2Z']) },
      { id: 'users-solid', name: 'Nhóm', svg: solidSvg(['M16 11c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3Z', 'M8 11c1.66 0 3-1.34 3-3S9.66 5 8 5 5 6.34 5 8s1.34 3 3 3Z', 'M16 13c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4Z', 'M2 19v-2c0-1.66 2.69-2.92 5.38-2.99a9.5 9.5 0 0 1 2.14.2C7.39 14.6 5 15.88 5 17.5V19H2Z']) },
      { id: 'message-solid', name: 'Hộp chat', svg: solidSvg('M20 2H4a2 2 0 0 0-2 2v16l4-4h14a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2Z') },
      { id: 'phone-solid', name: 'Điện thoại', svg: solidSvg('M6.62 10.79a15.05 15.05 0 0 0 6.59 6.59l2.2-2.2a1 1 0 0 1 1.05-.24c1.15.38 2.38.59 3.54.59a1 1 0 0 1 1 1V20a2 2 0 0 1-2 2C10.07 22 2 13.93 2 4a2 2 0 0 1 2-2h3.25a1 1 0 0 1 1 1c0 1.21.2 2.39.59 3.54a1 1 0 0 1-.25 1.05l-2 2.2Z') },
      { id: 'map-pin-solid', name: 'Pin', svg: solidSvg('M12 2a7 7 0 0 0-7 7c0 5.25 7 13 7 13s7-7.75 7-13a7 7 0 0 0-7-7Zm0 9.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5Z') },
      { id: 'navigation-solid', name: 'Mũi tên', svg: solidSvg('M12 2 4 20l8-4 8 4-8-18Z') },
      { id: 'play-solid', name: 'Play', svg: solidSvg('M8 5v14l11-7-11-7Z') },
      { id: 'pause-solid', name: 'Pause', svg: solidSvg(['M6 5h4v14H6z', 'M14 5h4v14h-4z']) },
      { id: 'stop-solid', name: 'Stop', svg: solidSvg('M6 6h12v12H6z') },
      { id: 'forward-solid', name: 'Tua tới', svg: solidSvg(['M4 5v14l8-7-8-7Z', 'M13 5v14l8-7-8-7Z']) },
      { id: 'backward-solid', name: 'Tua ngược', svg: solidSvg(['M20 5v14l-8-7 8-7Z', 'M11 5v14L3 12l8-7Z']) },
      { id: 'camera-solid', name: 'Camera', svg: solidSvg(['M4 5h4l2-2h4l2 2h4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2Z', 'M12 17a5 5 0 1 0 0-10 5 5 0 0 0 0 10Z']) },
      { id: 'video-solid', name: 'Video', svg: solidSvg(['M4 6h10a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2Z', 'M18 8v8l4 3V5l-4 3Z']) },
      { id: 'bell-solid', name: 'Chuông', svg: solidSvg(['M18 8a6 6 0 1 0-12 0v5H4a1 1 0 0 0 0 2h16a1 1 0 0 0 0-2h-2V8Z', 'M12 21a2 2 0 0 0 2-2H10a2 2 0 0 0 2 2Z']) },
      { id: 'calendar-solid', name: 'Lịch', svg: solidSvg(['M19 4h-1V2h-2v2H8V2H6v2H5a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3Z', 'M20 19H4V10h16v9Z']) },
      { id: 'cloud-solid', name: 'Mây', svg: solidSvg('M6 18h12a4 4 0 0 0 0-8 6 6 0 0 0-11-2A4 4 0 0 0 6 18Z') },
      { id: 'moon-solid', name: 'Trăng', svg: solidSvg('M21 12.79A9 9 0 0 1 11.21 3 7 7 0 1 0 21 12.79Z') },
      { id: 'home-solid', name: 'Nhà', svg: solidSvg('M3 11 12 3 21 11v9a2 2 0 0 1-2 2h-4v-6h-6v6H5a2 2 0 0 1-2-2Z') },
      { id: 'search-solid', name: 'Tìm kiếm', svg: solidSvg(['M10 4a6 6 0 1 1 0 12 6 6 0 0 1 0-12Z', 'M15 13l5 5-2 2-5-5']) },
      { id: 'filter-solid', name: 'Lọc', svg: solidSvg('M4 4h16l-6 6v6.5l-4 3.5V10z') },
      { id: 'menu-solid', name: 'Menu', svg: solidSvg(['M3 6h18v2H3z', 'M3 11h18v2H3z', 'M3 16h18v2H3z']) },
      { id: 'more-horizontal-solid', name: 'Ba chấm ngang', svg: solidSvg(['M6 10a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z', 'M12 10a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z', 'M18 10a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z']) },
      { id: 'more-vertical-solid', name: 'Ba chấm dọc', svg: solidSvg(['M10 6a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z', 'M10 12a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z', 'M10 18a2 2 0 1 1 4 0 2 2 0 0 1-4 0Z']) },
      { id: 'arrow-up-solid', name: 'Mũi tên lên', svg: solidSvg('M12 4l7 7h-4v9h-6v-9H5z') },
      { id: 'arrow-down-solid', name: 'Mũi tên xuống', svg: solidSvg('M12 20l-7-7h4V4h6v9h4z') },
      { id: 'arrow-left-solid', name: 'Mũi tên trái', svg: solidSvg('M4 12l7-7v4h9v6h-9v4z') },
      { id: 'arrow-right-solid', name: 'Mũi tên phải', svg: solidSvg('M20 12l-7 7v-4H4v-6h9V5z') },
      { id: 'inbox-solid', name: 'Hộp thư', svg: solidSvg(['M3 5h18v9h-4l-2 3h-6l-2-3H3z', 'M3 16h3.5l2 3h7l2-3H21v3a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1z']) },
      { id: 'folder-solid', name: 'Thư mục', svg: solidSvg('M3 6h7l2 2h9a1 1 0 0 1 1 1v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2Z') },
      { id: 'folder-open-solid', name: 'Thư mục mở', svg: solidSvg(['M3 7h7l2-2h9a1 1 0 0 1 1 1v2H6.6L3 18.5V9a2 2 0 0 1 2-2Z', 'M5.4 12H22l-2.4 8H3l2.4-8Z']) },
      { id: 'file-check-solid', name: 'File', svg: solidSvg(['M6 2h8l4 4v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2Z', 'M14 2v4h4', 'M9 14l-2-2 1.4-1.4L9 11.2l4.6-4.6L15 8l-6 6z']) },
      { id: 'wallet-solid', name: 'Ví', svg: solidSvg(['M4 6h16a2 2 0 0 1 2 2v2h-4a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h4v2a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2Z', 'M18 12h4v4h-4z']) },
      { id: 'tag-solid', name: 'Tag', svg: solidSvg(['M3 9.5 12.5 3h7.5V10l-9.5 9.5a2 2 0 0 1-2.8 0L3 12.3V9.5Z', 'M16 7a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z']) },
      { id: 'droplet-solid', name: 'Giọt nước', svg: solidSvg('M12 2C8 7 6 10 6 13.5A6 6 0 0 0 18 13.5C18 10 16 7 12 2Z') },
      { id: 'bookmark-solid', name: 'Bookmark', svg: solidSvg('M6 3h12a2 2 0 0 1 2 2v16l-8-4-8 4V5a2 2 0 0 1 2-2Z') },

      // Open-source icon shapes (Lucide)
      { id: 'lucide-qr', name: 'QR (Lucide)', lib: 'lucide', icon: 'qr-code' },
      { id: 'lucide-image', name: 'Ảnh (Lucide)', lib: 'lucide', icon: 'image' },
      { id: 'lucide-camera', name: 'Camera (Lucide)', lib: 'lucide', icon: 'camera' },
      { id: 'lucide-qr', name: 'QR', lib: 'lucide', icon: 'qr-code' },
      { id: 'lucide-image', name: 'Ảnh', lib: 'lucide', icon: 'image' },
      { id: 'lucide-camera', name: 'Camera', lib: 'lucide', icon: 'camera' },
      { id: 'lucide-video', name: 'Video', lib: 'lucide', icon: 'video' },
      { id: 'lucide-music', name: 'Nhạc', lib: 'lucide', icon: 'music-2' },
      { id: 'lucide-mic', name: 'Mic', lib: 'lucide', icon: 'mic' },
      { id: 'lucide-map-pin', name: 'Vị trí', lib: 'lucide', icon: 'map-pin' },
      { id: 'lucide-navigation', name: 'La bàn', lib: 'lucide', icon: 'navigation' },
      { id: 'lucide-compass', name: 'Compass', lib: 'lucide', icon: 'compass' },
      { id: 'lucide-globe', name: 'Globe', lib: 'lucide', icon: 'globe-2' },
      { id: 'lucide-wifi', name: 'Wi-Fi', lib: 'lucide', icon: 'wifi' },
      { id: 'lucide-bluetooth', name: 'Bluetooth', lib: 'lucide', icon: 'bluetooth' },
      { id: 'lucide-smartphone', name: 'Điện thoại', lib: 'lucide', icon: 'smartphone' },
      { id: 'lucide-monitor', name: 'Màn hình', lib: 'lucide', icon: 'monitor' },
      { id: 'lucide-cpu', name: 'CPU', lib: 'lucide', icon: 'cpu' },
      { id: 'lucide-cloud', name: 'Mây', lib: 'lucide', icon: 'cloud' },
      { id: 'lucide-palette', name: 'Bảng màu', lib: 'lucide', icon: 'palette' },
      { id: 'lucide-layers', name: 'Layers', lib: 'lucide', icon: 'layers' },
      { id: 'lucide-sparkles', name: 'Sparkles', lib: 'lucide', icon: 'sparkles' },
      { id: 'lucide-badge-check', name: 'Badge', lib: 'lucide', icon: 'badge-check' },
      { id: 'lucide-check-circle', name: 'Check', lib: 'lucide', icon: 'check-circle-2' },
      { id: 'lucide-x-circle', name: 'X', lib: 'lucide', icon: 'x-circle' },
      { id: 'lucide-bell', name: 'Chuông', lib: 'lucide', icon: 'bell' },
      { id: 'lucide-calendar', name: 'Lịch', lib: 'lucide', icon: 'calendar' },
      { id: 'lucide-clock', name: 'Đồng hồ', lib: 'lucide', icon: 'clock-3' },
      { id: 'lucide-tag', name: 'Tag', lib: 'lucide', icon: 'tag' },
      { id: 'lucide-bookmark', name: 'Bookmark', lib: 'lucide', icon: 'bookmark' },
      { id: 'lucide-book', name: 'Sách', lib: 'lucide', icon: 'book-open' },
      { id: 'lucide-file', name: 'File', lib: 'lucide', icon: 'file-text' },
      { id: 'lucide-printer', name: 'Printer', lib: 'lucide', icon: 'printer' },
      { id: 'lucide-download', name: 'Download', lib: 'lucide', icon: 'download' },
      { id: 'lucide-upload', name: 'Upload', lib: 'lucide', icon: 'upload' },
      { id: 'lucide-share', name: 'Share', lib: 'lucide', icon: 'share-2' },
      { id: 'lucide-link', name: 'Link', lib: 'lucide', icon: 'link-2' },
      { id: 'lucide-lock', name: 'Khóa', lib: 'lucide', icon: 'lock' },
      { id: 'lucide-unlock', name: 'Mở khóa', lib: 'lucide', icon: 'unlock' },
      { id: 'lucide-shield', name: 'Khiên', lib: 'lucide', icon: 'shield' },
      { id: 'lucide-shield-check', name: 'Khiên check', lib: 'lucide', icon: 'shield-check' },
      { id: 'lucide-shopping-bag', name: 'Túi', lib: 'lucide', icon: 'shopping-bag' },
      { id: 'lucide-credit-card', name: 'Thẻ', lib: 'lucide', icon: 'credit-card' },
      { id: 'lucide-gift', name: 'Quà', lib: 'lucide', icon: 'gift' },
      { id: 'lucide-ticket', name: 'Vé', lib: 'lucide', icon: 'ticket' },
      { id: 'lucide-rocket', name: 'Rocket', lib: 'lucide', icon: 'rocket' },
      { id: 'lucide-briefcase', name: 'Cặp', lib: 'lucide', icon: 'briefcase' },
      { id: 'lucide-graduation-cap', name: 'Mũ tốt nghiệp', lib: 'lucide', icon: 'graduation-cap' },
      { id: 'lucide-flame', name: 'Lửa', lib: 'lucide', icon: 'flame' },
      { id: 'lucide-headphones', name: 'Tai nghe', lib: 'lucide', icon: 'headphones' },
      { id: 'lucide-radio', name: 'Radio', lib: 'lucide', icon: 'radio' },
      { id: 'num-0', name: 'Số 0', svg: textShapeSvg('0') },
      { id: 'num-1', name: 'Số 1', svg: textShapeSvg('1') },
      { id: 'num-2', name: 'Số 2', svg: textShapeSvg('2') },
      { id: 'num-3', name: 'Số 3', svg: textShapeSvg('3') },
      { id: 'num-4', name: 'Số 4', svg: textShapeSvg('4') },
      { id: 'num-5', name: 'Số 5', svg: textShapeSvg('5') },
      { id: 'num-6', name: 'Số 6', svg: textShapeSvg('6') },
      { id: 'num-7', name: 'Số 7', svg: textShapeSvg('7') },
      { id: 'num-8', name: 'Số 8', svg: textShapeSvg('8') },
      { id: 'num-9', name: 'Số 9', svg: textShapeSvg('9') },
      { id: 'letter-a', name: 'Chữ A', svg: textShapeSvg('A') },
      { id: 'letter-b', name: 'Chữ B', svg: textShapeSvg('B') },
      { id: 'letter-c', name: 'Chữ C', svg: textShapeSvg('C') },
      { id: 'letter-d', name: 'Chữ D', svg: textShapeSvg('D') },
      { id: 'letter-e', name: 'Chữ E', svg: textShapeSvg('E') },
      { id: 'letter-f', name: 'Chữ F', svg: textShapeSvg('F') },
      { id: 'letter-g', name: 'Chữ G', svg: textShapeSvg('G') },
      { id: 'letter-h', name: 'Chữ H', svg: textShapeSvg('H') },
      { id: 'letter-i', name: 'Chữ I', svg: textShapeSvg('I') },
      { id: 'letter-j', name: 'Chữ J', svg: textShapeSvg('J') },
      { id: 'letter-k', name: 'Chữ K', svg: textShapeSvg('K') },
      { id: 'letter-l', name: 'Chữ L', svg: textShapeSvg('L') },
      { id: 'letter-m', name: 'Chữ M', svg: textShapeSvg('M') },
      { id: 'letter-n', name: 'Chữ N', svg: textShapeSvg('N') },
      { id: 'letter-o', name: 'Chữ O', svg: textShapeSvg('O') },
      { id: 'letter-p', name: 'Chữ P', svg: textShapeSvg('P') },
      { id: 'letter-q', name: 'Chữ Q', svg: textShapeSvg('Q') },
      { id: 'letter-r', name: 'Chữ R', svg: textShapeSvg('R') },
      { id: 'letter-s', name: 'Chữ S', svg: textShapeSvg('S') },
      { id: 'letter-t', name: 'Chữ T', svg: textShapeSvg('T') },
      { id: 'letter-u', name: 'Chữ U', svg: textShapeSvg('U') },
      { id: 'letter-v', name: 'Chữ V', svg: textShapeSvg('V') },
      { id: 'letter-w', name: 'Chữ W', svg: textShapeSvg('W') },
      { id: 'letter-x', name: 'Chữ X', svg: textShapeSvg('X') },
      { id: 'letter-y', name: 'Chữ Y', svg: textShapeSvg('Y') },
      { id: 'letter-z', name: 'Chữ Z', svg: textShapeSvg('Z') }
    ];

    let shapesExpanded = false;

    function renderToggleShapesBtn() {
      const btn = document.getElementById('toggle-shapes-btn');
      if (!btn) return;
      const labelKey = shapesExpanded ? 'action.showLessShapes' : 'action.showMoreShapes';
      const label = (typeof getI18nText === 'function') ? getI18nText(labelKey) : btn.textContent;
      btn.innerHTML = shapesExpanded
        ? `<i class="fa-solid fa-chevron-up"></i> ${label}`
        : `<i class="fa-solid fa-chevron-down"></i> ${label}`;
    }
    
    function toggleMoreShapes() {
      shapesExpanded = !shapesExpanded;
      const extraGrid = document.getElementById('shapes-grid-extra');
      if (extraGrid) {
        extraGrid.style.display = shapesExpanded ? 'grid' : 'none';
      }
      renderToggleShapesBtn();
    }

    function initShapesGrid() {
      const mainGrid = document.getElementById('shapes-grid-main');
      const extraGrid = document.getElementById('shapes-grid-extra');
      if (!mainGrid || !extraGrid) return;
      
      mainGrid.innerHTML = '';
      extraGrid.innerHTML = '';
      
      shapesCatalog.forEach((shape, idx) => {
        const shapeLabel = getShapeLabel(shape);
        const div = document.createElement('div');
        div.className = 'shape-preview';
        div.dataset.shapeId = shape.id;
        div.onclick = () => addShapeElement(shape.id);
        div.title = shapeLabel;

        const isSvgShape = !!shape.svg || shape.lib === 'lucide' || !!shape.svgPath;
        const baseStyle = shape.style || '';
        const thumbClass = `shape-thumb ${isSvgShape ? 'svg-thumb' : ''}`;
        const thumbStyle = isSvgShape
          ? 'background:transparent;color:#fff;display:flex;align-items:center;justify-content:center;'
          : `background:#fff;${baseStyle}`;

        let thumbContent = '';
        if (shape.lib === 'lucide') {
          const iconName = shape.icon || shape.id.replace('lucide-', '');
          thumbContent = `<i data-lucide="${iconName}"></i>`;
        } else if (shape.svg) {
          thumbContent = shape.svg;
        }

        div.innerHTML = `
          <div class="${thumbClass}" style="${thumbStyle}">${thumbContent}</div>
          <span class="shape-label">${shapeLabel}</span>
        `;

        // Lazy load external SVG thumbnails
        const thumbDiv = div.querySelector('.shape-thumb');
        if (shape.svgPath && thumbDiv) {
          const resolvedUrl = String(new URL(shape.svgPath, window.location.href));
          if (window.location.protocol === 'file:') {
            setSvgMask(thumbDiv, resolvedUrl);
          } else {
            thumbDiv.innerHTML = '<span style="opacity:0.6">...</span>';
            loadSvg(shape.svgPath).then(svg => {
              clearSvgMask(thumbDiv);
              thumbDiv.innerHTML = svg;
            }).catch(() => {
              setSvgMask(thumbDiv, resolvedUrl);
            });
          }
        }

        if (idx < 9) {
          mainGrid.appendChild(div);
        } else {
          extraGrid.appendChild(div);
        }
      });

      // Render Lucide icons inside the grid
      if (window.lucide) {
        window.lucide.createIcons({ attrs: { 'stroke-width': 2 } });
      }
    }

    function refreshShapesGridLabels() {
      const previews = document.querySelectorAll('.shape-preview[data-shape-id]');
      if (!previews || previews.length === 0) return;

      const byId = new Map();
      shapesCatalog.forEach(s => {
        if (s && s.id) byId.set(s.id, s);
      });

      previews.forEach(el => {
        const id = el.dataset.shapeId;
        const shape = byId.get(id);
        if (!shape) return;
        const label = getShapeLabel(shape);
        el.title = label;
        const labelEl = el.querySelector('.shape-label') || el.querySelector('span');
        if (labelEl) labelEl.textContent = label;
      });
    }

    // Add shape element
    function addShapeElement(shape = 'rect') {
      const id = 'el-' + Date.now();
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      const size = 120;
      
      // Default color for new shapes
      const defaultColor = '#7c3aed';
      
      saveToHistory();
      elements.push({
        id,
        type: 'shape',
        shapeType: shape,
        fill: defaultColor,
        stroke: '',
        x: canvasW / 2 - size / 2,
        y: canvasH / 2 - size / 2,
        width: size,
        height: size,
        rotation: 0,
        opacity: 100
      });
      renderElements();
    }

    function refreshSelectionStyles() {
      const handles = ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'];
      const isMultiSelect = selectedIds.size >= 2;
      
      elements.forEach(el => {
        const div = document.getElementById(el.id);
        if (!div) return;

        const isSelected = selectedIds.has(el.id);
        div.classList.toggle('selected', isSelected);
        div.classList.toggle('multi-selected', isSelected && isMultiSelect);

        // Remove old handles so we can re-render them if needed
        div.querySelectorAll('.resize-handle, .rotation-handle, .rotation-line').forEach(handle => handle.remove());

        if (isSelected && !isMultiSelect) {
          // Add resize handles only for single selection
          handles.forEach(pos => {
            const handle = document.createElement('div');
            handle.className = `resize-handle ${pos}`;
            handle.dataset.handle = pos;
            div.appendChild(handle);
          });
          
          // Add rotation handle (only for single selection)
          const rotLine = document.createElement('div');
          rotLine.className = 'rotation-line';
          div.appendChild(rotLine);
          
          const rotHandle = document.createElement('div');
          rotHandle.className = 'rotation-handle';
          rotHandle.innerHTML = '<i class="fa-solid fa-rotate"></i>';
          rotHandle.dataset.rotate = 'true';
          div.appendChild(rotHandle);
        }
      });
      
      // Update multi-select box if multiple elements selected
      updateMultiSelectBox();
      
      // Update floating toolbar visibility
      updateFloatingToolbar();
      
      // Update handle scales to compensate for current zoom level
      updateHandleScales();
    }

    function getCanvasPoint(e) {
      const rect = canvas.getBoundingClientRect();
      const scale = canvasZoom / 100;
      return {
        x: (e.clientX - rect.left) / scale,
        y: (e.clientY - rect.top) / scale
      };
    }

    function getCanvasPointFromPage(point) {
      const rect = canvas.getBoundingClientRect();
      const scale = canvasZoom / 100;
      return {
        x: (point.x - rect.left) / scale,
        y: (point.y - rect.top) / scale
      };
    }

    function rectIntersects(el, selection) {
      const x1 = Math.min(selection.x1, selection.x2);
      const y1 = Math.min(selection.y1, selection.y2);
      const x2 = Math.max(selection.x1, selection.x2);
      const y2 = Math.max(selection.y1, selection.y2);
      return !(el.x > x2 || el.x + el.width < x1 || el.y > y2 || el.y + el.height < y1);
    }

    function updateSelectionBox(e) {
      if (!isSelecting || !selectionStart || !wrapperSelectionBox) return;
      const wrapperRect = canvasWrapper.getBoundingClientRect();
      const currentPage = { x: e.clientX, y: e.clientY };
      lastSelectionPoint = currentPage;
      const x1p = Math.min(selectionStart.page.x, currentPage.x) - wrapperRect.left + canvasWrapper.scrollLeft;
      const y1p = Math.min(selectionStart.page.y, currentPage.y) - wrapperRect.top + canvasWrapper.scrollTop;
      const x2p = Math.max(selectionStart.page.x, currentPage.x) - wrapperRect.left + canvasWrapper.scrollLeft;
      const y2p = Math.max(selectionStart.page.y, currentPage.y) - wrapperRect.top + canvasWrapper.scrollTop;

      wrapperSelectionBox.style.left = x1p + 'px';
      wrapperSelectionBox.style.top = y1p + 'px';
      wrapperSelectionBox.style.width = (x2p - x1p) + 'px';
      wrapperSelectionBox.style.height = (y2p - y1p) + 'px';
      wrapperSelectionBox.style.display = 'block';

      // Compute canvas-space rectangle for hit-test
      const currentCanvas = getCanvasPointFromPage(currentPage);
      const x1 = Math.min(selectionStart.canvas.x, currentCanvas.x);
      const y1 = Math.min(selectionStart.canvas.y, currentCanvas.y);
      const x2 = Math.max(selectionStart.canvas.x, currentCanvas.x);
      const y2 = Math.max(selectionStart.canvas.y, currentCanvas.y);

      const hits = elements.filter(el => rectIntersects(el, { x1, y1, x2, y2 }));
      selectedIds.clear();
      hits.forEach(el => selectedIds.add(el.id));
      refreshSelectionStyles();
    }

    // Select element(s) - Canva style
    function selectElement(id, addToSelection = false) {
      // Deselect canvas when selecting element
      if (canvasSelected) {
        canvasSelected = false;
        canvas.style.outline = 'none';
        canvas.style.outlineOffset = '0';
        removeCanvasSelectionOverlay();
      }
      
      if (addToSelection) {
        // Shift+click: toggle selection
        if (selectedIds.has(id)) {
          selectedIds.delete(id);
        } else {
          selectedIds.add(id);
        }
      } else {
        // Normal click: select only this one
        selectedIds.clear();
        if (id) selectedIds.add(id);
      }
      refreshSelectionStyles();
      showElementProps();
      updateMobilePropsMode();
    }

    function clearSelection() {
      selectedIds.clear();
      canvasSelected = false;
      canvas.style.outline = 'none';
      canvas.style.outlineOffset = '0';
      removeCanvasSelectionOverlay();
      removeMultiSelectBox();
      refreshSelectionStyles();
      updateFloatingToolbar();
      showElementProps();
    }

    // ===== LAYER MANAGEMENT =====
    function moveLayerUp() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const selectedArr = [...selectedIds];
      // Sort by current index descending to move from top
      selectedArr.sort((a, b) => elements.findIndex(e => e.id === b) - elements.findIndex(e => e.id === a));
      selectedArr.forEach(id => {
        const idx = elements.findIndex(e => e.id === id);
        if (idx < elements.length - 1) {
          [elements[idx], elements[idx + 1]] = [elements[idx + 1], elements[idx]];
        }
      });
      renderElements();
    }

    function moveLayerDown() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const selectedArr = [...selectedIds];
      // Sort by current index ascending to move from bottom
      selectedArr.sort((a, b) => elements.findIndex(e => e.id === a) - elements.findIndex(e => e.id === b));
      selectedArr.forEach(id => {
        const idx = elements.findIndex(e => e.id === id);
        if (idx > 0) {
          [elements[idx], elements[idx - 1]] = [elements[idx - 1], elements[idx]];
        }
      });
      renderElements();
    }

    function moveLayerToTop() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const selected = elements.filter(e => selectedIds.has(e.id));
      const others = elements.filter(e => !selectedIds.has(e.id));
      elements = [...others, ...selected];
      renderElements();
    }

    function moveLayerToBottom() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const selected = elements.filter(e => selectedIds.has(e.id));
      const others = elements.filter(e => !selectedIds.has(e.id));
      elements = [...selected, ...others];
      renderElements();
    }

    // ===== FLOATING TOOLBAR =====
    function updateFloatingToolbar() {
      const toolbar = document.getElementById('floating-toolbar');
      if (!toolbar) return;
      
      // Always show toolbar (like Canva)
      toolbar.classList.add('visible');
      
      // Update button states based on selection
      const hasSelection = selectedIds.size > 0 || canvasSelected;
      const hasClipboard = clipboard.length > 0;
      const canUndo = historyIndex > 0;
      const canRedo = historyIndex < history.length - 1;
      
      // Get all buttons
      const undoBtn = toolbar.querySelector('[title*="Hoàn tác"]');
      const redoBtn = toolbar.querySelector('[title*="Làm lại"]');
      const copyBtn = toolbar.querySelector('[title*="Copy"]');
      const dupBtn = toolbar.querySelector('[title*="Nhân đôi"]');
      const delBtn = toolbar.querySelector('[title*="Xóa"]');
      const layerBtn = toolbar.querySelector('[title*="Vị trí"]');
      const pasteBtn = toolbar.querySelector('[title*="Dán"]');
      
      // Update disabled states
      if (undoBtn) undoBtn.style.opacity = canUndo ? '1' : '0.4';
      if (redoBtn) redoBtn.style.opacity = canRedo ? '1' : '0.4';
      if (copyBtn) copyBtn.style.opacity = hasSelection ? '1' : '0.4';
      if (dupBtn) dupBtn.style.opacity = hasSelection ? '1' : '0.4';
      if (delBtn) delBtn.style.opacity = hasSelection ? '1' : '0.4';
      if (layerBtn) layerBtn.style.opacity = hasSelection ? '1' : '0.4';
      if (pasteBtn) pasteBtn.style.opacity = hasClipboard ? '1' : '0.4';
      
      // Update toolbar position
      updateToolbarPosition();
      
      // Hide menus
      hideLayerMenu();
      hideMoreMenu();
    }
    
    function toggleLayerMenu() {
      const menu = document.getElementById('layer-menu');
      if (menu) {
        menu.classList.toggle('show');
        hideMoreMenu();
      }
    }
    
    function hideLayerMenu() {
      const menu = document.getElementById('layer-menu');
      if (menu) menu.classList.remove('show');
    }

    // ===== MOBILE: render 3-dots menu inside bottom panel =====
    let mobileMoreMenuOpen = false;
    let lastSidebarPanelBeforeMore = 'panel-qr';

    function setMobileSidebarOpen(open) {
      const sidebar = document.getElementById('sidebar');
      const mainArea = document.querySelector('.main-area');
      if (!sidebar || !mainArea) return;
      if (!isMobileViewport()) return;
      sidebar.classList.toggle('open', !!open);
      mainArea.classList.toggle('sidebar-collapsed', !open);
      mainArea.classList.toggle('sidebar-open', !!open);
    }

    function syncMoreMenuHost() {
      const menu = document.getElementById('more-menu');
      const hostDesktop = document.getElementById('more-menu-host-desktop');
      const hostMobile = document.getElementById('more-menu-host-mobile');
      if (!menu || !hostDesktop || !hostMobile) return;
      if (isMobileViewport()) {
        if (menu.parentElement !== hostMobile) hostMobile.appendChild(menu);
      } else {
        if (menu.parentElement !== hostDesktop) hostDesktop.appendChild(menu);
        mobileMoreMenuOpen = false;
        menu.classList.remove('show');
      }
    }

    function openMobileMorePanel() {
      if (!isMobileViewport()) return;
      syncMoreMenuHost();
      const tabs = document.querySelector('.sidebar-tabs');
      if (tabs) tabs.classList.add('hidden');
      const active = document.querySelector('.sidebar-panel.active');
      if (active && active.id && active.id !== 'panel-more') lastSidebarPanelBeforeMore = active.id;
      setActiveSidebarPanel('panel-more');
      setMobileSidebarOpen(true);
      const menu = document.getElementById('more-menu');
      if (menu) menu.classList.add('show');
    }

    function closeMobileMorePanel() {
      const menu = document.getElementById('more-menu');
      if (menu) menu.classList.remove('show');
      mobileMoreMenuOpen = false;
      if (!isMobileViewport()) return;
      const tabs = document.querySelector('.sidebar-tabs');
      if (tabs) tabs.classList.remove('hidden');
      // Restore state based on selection (props auto-switch) or last panel
      if (typeof updateMobilePropsMode === 'function') {
        updateMobilePropsMode();
      } else {
        const target = document.getElementById(lastSidebarPanelBeforeMore) ? lastSidebarPanelBeforeMore : 'panel-qr';
        setActiveSidebarPanel(target);
      }
    }
    
    function toggleMoreMenu() {
      const menu = document.getElementById('more-menu');
      if (typeof isMobileViewport === 'function' && isMobileViewport()) {
        hideLayerMenu();
        mobileMoreMenuOpen = !mobileMoreMenuOpen;
        if (mobileMoreMenuOpen) openMobileMorePanel();
        else closeMobileMorePanel();
        return;
      }
      if (menu) {
        menu.classList.toggle('show');
        hideLayerMenu();
      }
    }
    
    function hideMoreMenu() {
      const menu = document.getElementById('more-menu');
      if (typeof isMobileViewport === 'function' && isMobileViewport()) {
        closeMobileMorePanel();
        return;
      }
      if (menu) menu.classList.remove('show');
    }
    
    function selectAllElements() {
      elements.forEach(el => selectedIds.add(el.id));
      refreshSelectionStyles();
      updateMultiSelectBox();
      updateFloatingToolbar();
      showElementProps();
    }

    // ===== ALIGN, FLIP, RESET FUNCTIONS =====
    function alignSelected(alignment) {
      if (selectedIds.size === 0) return;
      saveToHistory();
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      
      if (selectedIds.size === 1) {
        // Align to canvas
        const el = selected[0];
        if (alignment === 'left') el.x = 0;
        else if (alignment === 'center') el.x = (canvasW - el.width) / 2;
        else if (alignment === 'right') el.x = canvasW - el.width;
        else if (alignment === 'top') el.y = 0;
        else if (alignment === 'middle') el.y = (canvasH - el.height) / 2;
        else if (alignment === 'bottom') el.y = canvasH - el.height;
      } else {
        // Align selected elements to each other
        const bounds = getSelectionBounds();
        if (!bounds) return;
        
        selected.forEach(el => {
          if (alignment === 'left') el.x = bounds.x;
          else if (alignment === 'center') el.x = bounds.x + (bounds.width - el.width) / 2;
          else if (alignment === 'right') el.x = bounds.x + bounds.width - el.width;
          else if (alignment === 'top') el.y = bounds.y;
          else if (alignment === 'middle') el.y = bounds.y + (bounds.height - el.height) / 2;
          else if (alignment === 'bottom') el.y = bounds.y + bounds.height - el.height;
        });
      }
      
      renderElements();
      updateMultiSelectBox();
    }

    function flipSelected(direction) {
      if (canvasSelected && selectedIds.size === 0) {
        showToast((typeof t === 'function')
          ? t(direction === 'vertical' ? 'toast.canvasFlipNotAllowedV' : 'toast.canvasFlipNotAllowedH')
          : (direction === 'vertical' ? 'Canvas không thể lật dọc' : 'Canvas không thể lật ngang'));
        return;
      }
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      const bounds = getSelectionBounds();
      if (!bounds) return;
      
      selected.forEach(el => {
        if (direction === 'horizontal') {
          // Mirror X position within bounds
          const relX = el.x - bounds.x;
          el.x = bounds.x + bounds.width - relX - el.width;
          // Flip content
          el.flipX = !el.flipX;
        } else if (direction === 'vertical') {
          // Mirror Y position within bounds
          const relY = el.y - bounds.y;
          el.y = bounds.y + bounds.height - relY - el.height;
          // Flip content
          el.flipY = !el.flipY;
        }
      });
      
      renderElements();
      updateMultiSelectBox();
    }

    function resetRotation() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      elements.filter(el => selectedIds.has(el.id)).forEach(el => {
        el.rotation = 0;
      });
      
      renderElements();
      showElementProps();
    }

    function fitToCanvas() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      const padding = 20;
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      const bounds = getSelectionBounds();
      if (!bounds) return;
      
      // Calculate scale to fit
      const scaleX = (canvasW - padding * 2) / bounds.width;
      const scaleY = (canvasH - padding * 2) / bounds.height;
      const scale = Math.min(scaleX, scaleY, 2); // Max 2x scale
      
      // Calculate new center position
      const newCenterX = canvasW / 2;
      const newCenterY = canvasH / 2;
      const oldCenterX = bounds.x + bounds.width / 2;
      const oldCenterY = bounds.y + bounds.height / 2;
      
      selected.forEach(el => {
        // Scale relative to bounds center
        const relX = el.x - oldCenterX;
        const relY = el.y - oldCenterY;
        
        el.x = Math.round(newCenterX + relX * scale);
        el.y = Math.round(newCenterY + relY * scale);
        el.width = Math.round(el.width * scale);
        el.height = Math.round(el.height * scale);
        
        if (el.type === 'text' && el.fontSize) {
          el.fontSize = Math.max(8, Math.round(el.fontSize * scale));
        }
      });
      
      renderElements();
      updateMultiSelectBox();
      showElementProps();
    }
    
    // Center selected elements in canvas
    function centerInCanvas() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      const bounds = getSelectionBounds();
      if (!bounds) return;
      
      const offsetX = (canvasW - bounds.width) / 2 - bounds.x;
      const offsetY = (canvasH - bounds.height) / 2 - bounds.y;
      
      selected.forEach(el => {
        el.x = Math.round(el.x + offsetX);
        el.y = Math.round(el.y + offsetY);
      });
      
      renderElements();
      updateMultiSelectBox();
    }
    
    // Rotate selected elements by a specific angle
    function rotateSelected(angle) {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      elements.filter(el => selectedIds.has(el.id)).forEach(el => {
        el.rotation = normalizeRotation((el.rotation || 0) + angle);
      });
      
      renderElements();
      updateMultiSelectBox();
      showElementProps();
    }
    
    // Distribute selected elements evenly
    function distributeSelected(direction) {
      const selected = elements.filter(el => selectedIds.has(el.id));
      if (selected.length < 3) {
        showToast((typeof t === 'function') ? t('toast.distributeNeed3') : 'Cần ít nhất 3 phần tử để phân bố');
        return;
      }
      
      saveToHistory();
      
      if (direction === 'horizontal') {
        // Sort by x position
        selected.sort((a, b) => a.x - b.x);
        const first = selected[0];
        const last = selected[selected.length - 1];
        const totalSpace = (last.x + last.width) - first.x;
        const totalWidths = selected.reduce((sum, el) => sum + el.width, 0);
        const gap = (totalSpace - totalWidths) / (selected.length - 1);
        
        let currentX = first.x + first.width + gap;
        for (let i = 1; i < selected.length - 1; i++) {
          selected[i].x = Math.round(currentX);
          currentX += selected[i].width + gap;
        }
      } else {
        // Sort by y position
        selected.sort((a, b) => a.y - b.y);
        const first = selected[0];
        const last = selected[selected.length - 1];
        const totalSpace = (last.y + last.height) - first.y;
        const totalHeights = selected.reduce((sum, el) => sum + el.height, 0);
        const gap = (totalSpace - totalHeights) / (selected.length - 1);
        
        let currentY = first.y + first.height + gap;
        for (let i = 1; i < selected.length - 1; i++) {
          selected[i].y = Math.round(currentY);
          currentY += selected[i].height + gap;
        }
      }
      
      renderElements();
      updateMultiSelectBox();
    }
    
    // Toggle lock on selected elements
    function toggleLockSelected() {
      if (selectedIds.size === 0) return;
      saveToHistory();
      
      const selected = elements.filter(el => selectedIds.has(el.id));
      // Check if any is unlocked -> lock all, otherwise unlock all
      const anyUnlocked = selected.some(el => !el.locked);
      
      selected.forEach(el => {
        el.locked = anyUnlocked;
      });
      
      renderElements();
      showElementProps();
      showToast((typeof t === 'function') ? t(anyUnlocked ? 'toast.elementsLocked' : 'toast.elementsUnlocked') : (anyUnlocked ? 'Đã khóa phần tử' : 'Đã mở khóa phần tử'));
    }

    // ===== CONTEXT MENU =====
    let contextMenu = null;
    
    function showContextMenu(e, elementId = null) {
      hideContextMenu();
      
      // If right-clicking on an element, select it first
      if (elementId && !selectedIds.has(elementId)) {
        selectElement(elementId, false);
      }
      
      contextMenu = document.createElement('div');
      contextMenu.className = 'context-menu';
      
      const hasSelection = selectedIds.size > 0;
      const hasClipboard = clipboard.length > 0;
      
      const items = [
        { icon: 'fa-copy', label: 'Copy', shortcut: 'Ctrl+C', action: copySelected, disabled: !hasSelection },
        { icon: 'fa-paste', label: 'Dán', shortcut: 'Ctrl+V', action: pasteClipboard, disabled: !hasClipboard },
        { icon: 'fa-clone', label: 'Nhân đôi', shortcut: 'Ctrl+D', action: duplicateSelected, disabled: !hasSelection },
        { divider: true },
        { icon: 'fa-trash', label: 'Xóa', shortcut: 'Delete', action: deleteSelected, disabled: !hasSelection },
        { divider: true },
        { icon: 'fa-arrow-up', label: 'Đưa lên trên', action: moveLayerUp, disabled: !hasSelection },
        { icon: 'fa-arrow-down', label: 'Đưa xuống dưới', action: moveLayerDown, disabled: !hasSelection },
        { icon: 'fa-angles-up', label: 'Đưa lên trên cùng', action: moveLayerToTop, disabled: !hasSelection },
        { icon: 'fa-angles-down', label: 'Đưa xuống dưới cùng', action: moveLayerToBottom, disabled: !hasSelection },
        { divider: true },
        { icon: 'fa-check-double', label: 'Chọn tất cả', shortcut: 'Ctrl+A', action: () => {
          elements.forEach(el => selectedIds.add(el.id));
          refreshSelectionStyles();
          updateMultiSelectBox();
          showElementProps();
        }},
      ];
      
      items.forEach(item => {
        if (item.divider) {
          const div = document.createElement('div');
          div.className = 'context-menu-divider';
          contextMenu.appendChild(div);
        } else {
          const menuItem = document.createElement('div');
          menuItem.className = 'context-menu-item';
          if (item.disabled) {
            menuItem.style.opacity = '0.4';
            menuItem.style.pointerEvents = 'none';
          }
          menuItem.innerHTML = `
            <i class="fa-solid ${item.icon}"></i>
            <span>${item.label}</span>
            ${item.shortcut ? `<span class="shortcut">${item.shortcut}</span>` : ''}
          `;
          menuItem.onclick = () => {
            item.action();
            hideContextMenu();
          };
          contextMenu.appendChild(menuItem);
        }
      });
      
      // Position menu
      let x = e.clientX;
      let y = e.clientY;
      
      document.body.appendChild(contextMenu);
      
      // Adjust if menu goes off screen
      const rect = contextMenu.getBoundingClientRect();
      if (x + rect.width > window.innerWidth) x = window.innerWidth - rect.width - 5;
      if (y + rect.height > window.innerHeight) y = window.innerHeight - rect.height - 5;
      
      contextMenu.style.left = x + 'px';
      contextMenu.style.top = y + 'px';
    }
    
    function hideContextMenu() {
      if (contextMenu) {
        contextMenu.remove();
        contextMenu = null;
      }
    }

    // ===== UNDO/REDO SYSTEM =====
    function getCanvasState() {
      return {
        width: parseInt(canvas.style.width) || 400,
        height: parseInt(canvas.style.height) || 400,
        background: canvas.style.backgroundColor || '#ffffff',
        radius: parseInt(canvas.style.borderRadius) || 8,
        zoom: canvasZoom || 100
      };
    }

    function applyCanvasState(state) {
      if (!state) return;
      const w = state.width || 400;
      const h = state.height || 400;
      const clampedW = clampCanvasDimension(w);
      const clampedH = clampCanvasDimension(h);
      canvas.style.width = clampedW + 'px';
      canvas.style.height = clampedH + 'px';
      canvas.style.backgroundColor = state.background || '#ffffff';
      canvas.style.borderRadius = (state.radius !== undefined ? state.radius : 8) + 'px';
      canvasZoom = state.zoom !== undefined ? state.zoom : canvasZoom;
      updateCanvasTransform();
      // Sync inputs
      syncCanvasSizeInputs(clampedW, clampedH);
      const cbg = document.getElementById('canvas-bg'); if (cbg) cbg.value = state.background || '#ffffff';
      const pbg = document.getElementById('prop-canvas-bg'); if (pbg) pbg.value = state.background || '#ffffff';
      const rslider = document.getElementById('prop-canvas-radius'); if (rslider) rslider.value = state.radius || 8;
      const rlabel = document.getElementById('canvas-radius-label'); if (rlabel) rlabel.textContent = (state.radius || 8) + 'px';
      centerCanvasInView();
      updateToolbarPosition();
      renderCanvasSelectionOverlay();
    }

    function snapshotState() {
      return {
        elements: JSON.parse(JSON.stringify(elements)),
        canvas: getCanvasState()
      };
    }

    function saveToHistory() {
      if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
      }
      history.push(snapshotState());
      historyIndex = history.length - 1;
      if (history.length > 50) {
        history.shift();
        historyIndex--;
      }
    }

    function restoreFromHistory(idx) {
      const snap = history[idx];
      if (!snap) return;
      elements = JSON.parse(JSON.stringify(snap.elements || []));
      applyCanvasState(snap.canvas);
      selectedIds.clear();
      removeMultiSelectBox();
      renderElements();
      updateFloatingToolbar();
      showElementProps();
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        restoreFromHistory(historyIndex);
        showElementProps();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreFromHistory(historyIndex);
        showElementProps();
      }
    }

    // ===== CLIPBOARD (Copy/Paste/Duplicate) =====
    function copySelected() {
      if (canvasSelected && selectedIds.size === 0) {
        showToast((typeof t === 'function') ? t('toast.canvasCannotCopy') : 'Canvas không thể copy');
        return;
      }
      if (selectedIds.size === 0) return;
      // Filter out QR elements - QR cannot be copied
      const nonQRElements = elements
        .filter(el => selectedIds.has(el.id) && el.type !== 'qr')
        .map(el => JSON.parse(JSON.stringify(el)));
      
      if (nonQRElements.length === 0) {
        showToast((typeof t === 'function') ? t('toast.qrCannotCopy') : 'Mã QR không thể copy');
        return;
      }
      
      clipboard = nonQRElements;
      // Show brief visual feedback
      showToast((typeof t === 'function') ? t('toast.copiedElements', { count: clipboard.length }) : ('Đã copy ' + clipboard.length + ' phần tử'));
    }
    
    function showToast(message) {
      // Remove any existing toast
      const existing = document.querySelector('.toast-notification');
      if (existing) existing.remove();
      
      const toast = document.createElement('div');
      toast.className = 'toast-notification';
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: #10b981;
        color: #fff;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 12px;
        z-index: 9999;
        animation: fadeInOut 1.5s ease forwards;
      `;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 1500);
    }

    function pasteClipboard() {
      if (canvasSelected && selectedIds.size === 0) {
        showToast((typeof t === 'function') ? t('toast.canvasCannotPaste') : 'Canvas không thể paste');
        return;
      }
      if (clipboard.length === 0) return;
      
      // Filter out QR elements in case they somehow got into clipboard
      const nonQRClipboard = clipboard.filter(el => el.type !== 'qr');
      if (nonQRClipboard.length === 0) {
        showToast((typeof t === 'function') ? t('toast.qrCannotPaste') : 'Mã QR không thể paste');
        return;
      }
      
      saveToHistory();
      const newIds = [];
      const offset = 20; // Offset from original position
      let counter = 0;
      nonQRClipboard.forEach(el => {
        const newEl = JSON.parse(JSON.stringify(el));
        newEl.id = 'el-' + Date.now() + '-' + (counter++) + '-' + Math.random().toString(36).substr(2, 5);
        newEl.x += offset;
        newEl.y += offset;
        elements.push(newEl);
        newIds.push(newEl.id);
      });
      selectedIds.clear();
      newIds.forEach(id => selectedIds.add(id));
      renderElements();
      updateMultiSelectBox();
      updateFloatingToolbar();
      showElementProps();
    }

    function duplicateSelected() {
      if (canvasSelected && selectedIds.size === 0) {
        showToast((typeof t === 'function') ? t('toast.canvasCannotDuplicate') : 'Canvas không thể nhân đôi');
        return;
      }
      if (selectedIds.size === 0) return;
      
      // Filter out QR elements - QR cannot be duplicated
      const nonQRSelected = elements.filter(el => selectedIds.has(el.id) && el.type !== 'qr');
      
      if (nonQRSelected.length === 0) {
        showToast((typeof t === 'function') ? t('toast.qrCannotDuplicate') : 'Mã QR không thể nhân đôi');
        return;
      }
      
      saveToHistory();
      const newIds = [];
      const offset = 20;
      let counter = 0;
      nonQRSelected.forEach(el => {
        const newEl = JSON.parse(JSON.stringify(el));
        newEl.id = 'el-' + Date.now() + '-' + (counter++) + '-' + Math.random().toString(36).substr(2, 5);
        newEl.x += offset;
        newEl.y += offset;
        elements.push(newEl);
        newIds.push(newEl.id);
      });
      selectedIds.clear();
      newIds.forEach(id => selectedIds.add(id));
      renderElements();
      updateMultiSelectBox();
      updateFloatingToolbar();
      showElementProps();
    }

    function deleteSelected() {
      if (canvasSelected && selectedIds.size === 0) {
        showToast((typeof t === 'function') ? t('toast.canvasCannotDelete') : 'Canvas không thể xóa');
        return;
      }
      if (selectedIds.size === 0) return;
      saveToHistory();
      elements = elements.filter(el => !selectedIds.has(el.id));
      selectedIds.clear();
      removeMultiSelectBox();
      renderElements();
      updateFloatingToolbar();
      showElementProps();
      updateEmptyQRNotice();
      updateQRPanelVisibility();
    }

    // ===== MULTI-SELECT BOUNDING BOX =====
    function getSelectionBounds() {
      const selected = elements.filter(el => selectedIds.has(el.id));
      if (selected.length === 0) return null;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      selected.forEach(el => {
        minX = Math.min(minX, el.x);
        minY = Math.min(minY, el.y);
        maxX = Math.max(maxX, el.x + el.width);
        maxY = Math.max(maxY, el.y + el.height);
      });
      return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    function removeMultiSelectBox() {
      if (multiSelectBox) {
        multiSelectBox.remove();
        multiSelectBox = null;
      }
    }

    function updateMultiSelectBox() {
      removeMultiSelectBox();
      if (selectedIds.size < 2) return;
      
      const bounds = getSelectionBounds();
      if (!bounds) return;
      
      const box = document.createElement('div');
      box.className = 'multi-select-box';
      box.style.left = bounds.x + 'px';
      box.style.top = bounds.y + 'px';
      box.style.width = bounds.width + 'px';
      box.style.height = bounds.height + 'px';
      
      // Apply zoom-compensated border width
      box.style.borderWidth = `${Math.max(1, 2 / (canvasZoom / 100))}px`;
      
      // Add handles
      const inverseScale = 100 / canvasZoom;
      ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'].forEach(pos => {
        const handle = document.createElement('div');
        handle.className = `ms-handle ${pos}`;
        handle.dataset.msHandle = pos;
        
        // Apply inverse scale for consistent handle size
        let transform = `scale(${inverseScale})`;
        if (pos === 'n' || pos === 's') {
          transform += ' translateX(-50%)';
        } else if (pos === 'w' || pos === 'e') {
          transform += ' translateY(-50%)';
        }
        handle.style.transform = transform;
        
        box.appendChild(handle);
      });
      
      // Handle events for moving the entire group
      box.onmousedown = (e) => {
        if (e.target.dataset.msHandle) return; // Let handle event fire

        // Shift+click inside the multi-select box should toggle the underlying element
        // (useful because the box sits above elements and can intercept clicks).
        if (e.shiftKey) {
          e.preventDefault();
          e.stopPropagation();
          const pt = getCanvasPoint(e);
          const hit = [...elements].reverse().find(el =>
            pt.x >= el.x && pt.x <= (el.x + el.width) &&
            pt.y >= el.y && pt.y <= (el.y + el.height)
          );
          if (hit) {
            selectElement(hit.id, true);
          }
          return;
        }

        e.preventDefault();
        e.stopPropagation();
        const startPointer = getCanvasPoint(e);
        multiSelectDragging = {
          startPointer,
          elements: [...selectedIds].map(id => {
            const el = elements.find(e => e.id === id);
            return el ? { el, startX: el.x, startY: el.y } : null;
          }).filter(Boolean),
          startBounds: { ...bounds }
        };
        saveToHistory();
      };
      
      // Handle resize - Canva-style proportional scaling
      box.querySelectorAll('.ms-handle').forEach(handle => {
        handle.onmousedown = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const startPointer = getCanvasPoint(e);
          multiSelectResizing = {
            handle: handle.dataset.msHandle,
            startPointer,
            startBounds: { ...bounds },
            elements: [...selectedIds].map(id => {
              const el = elements.find(e => e.id === id);
              if (!el) return null;
              return {
                el,
                startX: el.x,
                startY: el.y,
                startW: el.width,
                startH: el.height,
                startFontSize: el.type === 'text' ? el.fontSize : null
              };
            }).filter(Boolean)
          };
          saveToHistory();
        };
      });
      
      canvas.appendChild(box);
      multiSelectBox = box;
    }

    function ensureEmptyQRNotice() {
      if (emptyQRNotice) return;
      emptyQRNotice = document.createElement('div');
      emptyQRNotice.className = 'canvas-empty-state';
      emptyQRNotice.innerHTML = `
        <div class="canvas-empty-card">
          <i class="fa-solid fa-qrcode"></i>
          <div class="title" data-i18n="empty.createQr">Tạo mã QR</div>
          <div class="subtitle" data-i18n="empty.noQrHint">Tạo mã QR để bắt đầu thiết kế</div>
          <button class="cta-btn" data-i18n="empty.createQr">Tạo mã QR</button>
        </div>
      `;

      // This node is created dynamically after initial page i18n pass
      if (typeof applyI18n === 'function') applyI18n();
      const btn = emptyQRNotice.querySelector('.cta-btn');
      if (btn) {
        btn.onclick = (e) => {
          e.stopPropagation();
          addQRElement();
          generateQR();
        };
      }
    }

    function updateEmptyQRNotice() {
      ensureEmptyQRNotice();
      const hasQR = elements.some(el => el.type === 'qr');
      if (!hasQR) {
        if (!canvas.contains(emptyQRNotice)) canvas.appendChild(emptyQRNotice);
        emptyQRNotice.style.display = 'flex';
      } else if (emptyQRNotice && emptyQRNotice.parentElement) {
        emptyQRNotice.remove();
      }
    }

    // Update QR Panel visibility based on whether QR exists
    function updateQRPanelVisibility() {
      const hasQR = elements.some(el => el.type === 'qr');
      const createSection = document.getElementById('qr-create-section');
      const customizeSection = document.getElementById('qr-customize-section');
      
      if (createSection && customizeSection) {
        if (hasQR) {
          createSection.style.display = 'none';
          customizeSection.style.display = 'block';
        } else {
          createSection.style.display = 'block';
          customizeSection.style.display = 'none';
        }
      }
    }

    // Add text element
    function addTextElement(text = 'Text', fontSize = 16, bold = false) {
      const id = 'el-' + Date.now();
      const canvasW = parseInt(canvas.style.width);

      saveToHistory();
      elements.push({
        id, type: 'text',
        text, fontSize, bold,
        italic: false,
        underline: false,
        fontFamily: 'Be Vietnam Pro',
        color: '#1e293b',
        bgColor: '',
        shadow: false,
        opacity: 100,
        x: canvasW / 2 - 50,
        y: 20,
        width: 100,
        height: fontSize + 10,
        rotation: 0
      });

      renderElements();
      selectElement(id);
    }

    // Render all elements
    function renderElements() {
      // Save guides container before clearing
      const savedGuidesContainer = guidesContainer;

      // Clear only child elements, not guides container or multi-select box
      const children = Array.from(canvas.children).filter(child => 
        child !== guidesContainer && child !== selectionBox && child !== multiSelectBox
      );
      children.forEach(child => child.remove());

      elements.forEach(el => {
        const div = document.createElement('div');
        div.id = el.id;
        div.className = 'canvas-element' + (selectedIds.has(el.id) ? ' selected' : '');
        const opacity = el.opacity !== undefined ? el.opacity / 100 : 1;
        div.style.cssText = `left:${el.x}px;top:${el.y}px;width:${el.width}px;height:${el.height}px;`;
        setElementRotation(div, el);

        if (el.type === 'qr') {
          // Use cached QR image if available
          if (qrImageCache) {
            div.innerHTML = `<div class="qr-content"><img class="qr-base" src="${qrImageCache}" alt="QR" /></div>`;
          } else {
            div.innerHTML = '<div class="qr-content"><span class="qr-loading">⏳</span></div>';
          }
          const qrContent = div.querySelector('.qr-content');
          if (qrContent) qrContent.style.opacity = opacity;
        } else if (el.type === 'text') {
          const fontSize = fitTextToContainer(el);
          const fontFamily = el.fontFamily || 'Be Vietnam Pro';
          const fontWeight = el.bold ? '700' : '400';
          const fontStyle = el.italic ? 'italic' : 'normal';
          const textDecor = el.underline ? 'underline' : 'none';
          const bgColor = el.bgColor || 'transparent';
          const shadow = el.shadow ? '2px 2px 4px rgba(0,0,0,0.3)' : 'none';
          
          div.innerHTML = `<div class="text-content" style="
            font-size:${fontSize}px;
            color:${el.color};
            font-weight:${fontWeight};
            font-style:${fontStyle};
            text-decoration:${textDecor};
            font-family:'${fontFamily}', sans-serif;
            background:${bgColor};
            text-shadow:${shadow};
            opacity:${opacity};
          ">${el.text}</div>`;
          loadGoogleFont(fontFamily);
        } else if (el.type === 'shape') {
          const fill = el.fill || '#7c3aed';
          const stroke = el.stroke || '';
          const shape = el.shapeType || 'rect';
          const borderRadius = el.borderRadius || 0;
          const opacity = (el.opacity !== undefined ? el.opacity : 100) / 100;
          
          // Get shape style from catalog
          const shapeInfo = shapesCatalog.find(s => s.id === shape);
          let shapeStyle = shapeInfo ? shapeInfo.style : '';
          
          // Allow custom border radius for rect/rounded shapes
          if (['rect', 'rounded'].includes(shape) && borderRadius > 0) {
            shapeStyle = `border-radius:${borderRadius}px;`;
          }
          
          if (shapeInfo && (shapeInfo.lib === 'lucide' || shapeInfo.svg || shapeInfo.svgPath)) {
            const colorStyle = `color:${fill};opacity:${opacity};`;
            if (shapeInfo.lib === 'lucide') {
              const iconName = shapeInfo.icon || shapeInfo.id.replace('lucide-', '');
              div.innerHTML = `<div class="shape-base shape-svg" style="${colorStyle}"><i data-lucide="${iconName}"></i></div>`;
              setTimeout(() => {
                if (window.lucide) {
                  window.lucide.createIcons({ attrs: { stroke: stroke || fill, 'stroke-width': 2, 'stroke-linecap': 'round', 'stroke-linejoin': 'round' } });
                }
              }, 0);
            } else if (shapeInfo.svg) {
              div.innerHTML = `<div class="shape-base shape-svg" style="${colorStyle}">${shapeInfo.svg}</div>`;
            } else if (shapeInfo.svgPath) {
              div.innerHTML = `<div class="shape-base shape-svg" style="${colorStyle}"><span style="opacity:0.6">...</span></div>`;
              const container = div.querySelector('.shape-svg');
              const resolvedUrl = String(new URL(shapeInfo.svgPath, window.location.href));
              if (container) {
                if (window.location.protocol === 'file:') {
                  setSvgMask(container, resolvedUrl, fill);
                } else {
                  loadSvg(shapeInfo.svgPath).then(svg => {
                    clearSvgMask(container);
                    container.innerHTML = svg;
                  }).catch(() => {
                    setSvgMask(container, resolvedUrl, fill);
                  });
                }
              }
            }
          } else {
            div.innerHTML = `<div class="shape-base" style="background:${fill};${stroke ? `border:2px solid ${stroke};` : ''}${shapeStyle}opacity:${opacity};"></div>`;
          }
        }

        canvas.appendChild(div);
      });

      // Restore guides container at end
      if (savedGuidesContainer && !canvas.contains(guidesContainer)) {
        canvas.appendChild(guidesContainer);
      }
      refreshSelectionStyles();
      updateEmptyQRNotice();
    }

    function setElementRotation(div, el) {
      if (!div) return;
      const flipX = el && el.flipX ? -1 : 1;
      const flipY = el && el.flipY ? -1 : 1;
      div.style.transform = `rotate(${normalizeRotation(el.rotation)}deg) scale(${flipX}, ${flipY})`;
    }

    // Fit text to container without clipping
    function fitTextToContainer(el) {
      if (el.type !== 'text') return el.fontSize;

      const padding = 8;
      const availableHeight = Math.max(el.height - padding, 20);
      const maxFontSize = Math.floor(availableHeight * 0.8);
      const minFontSize = 8;

      return Math.max(minFontSize, Math.min(el.fontSize, maxFontSize));
    }

    // Show element properties
    let lastSidebarPanelId = 'panel-qr';

    function isMobileViewport() {
      return window.innerWidth <= 750;
    }

    function syncElementPropsHost() {
      const props = document.getElementById('element-props');
      const hostDesktop = document.getElementById('element-props-host-desktop');
      const hostMobile = document.getElementById('element-props-host-mobile');
      if (!props || !hostDesktop || !hostMobile) return;
      if (isMobileViewport()) {
        if (props.parentElement !== hostMobile) hostMobile.appendChild(props);
      } else {
        if (props.parentElement !== hostDesktop) hostDesktop.appendChild(props);
      }
    }

    function setActiveSidebarPanel(panelId) {
      document.querySelectorAll('.sidebar-panel').forEach(p => p.classList.toggle('active', p.id === panelId));
      const panelKey = panelId.replace('panel-', '');
      document.querySelectorAll('.sidebar-tab').forEach(btn => btn.classList.toggle('active', btn.dataset.panel === panelKey));
    }

    function openMobilePropsPanel() {
      if (!isMobileViewport()) return;
      syncElementPropsHost();
      const tabs = document.querySelector('.sidebar-tabs');
      if (tabs) tabs.classList.add('hidden');
      const active = document.querySelector('.sidebar-panel.active');
      if (active && active.id && active.id !== 'panel-props') lastSidebarPanelId = active.id;
      setActiveSidebarPanel('panel-props');
    }

    function closeMobilePropsPanel() {
      if (!isMobileViewport()) return;
      const tabs = document.querySelector('.sidebar-tabs');
      if (tabs) tabs.classList.remove('hidden');
      const target = document.getElementById(lastSidebarPanelId) ? lastSidebarPanelId : 'panel-qr';
      setActiveSidebarPanel(target);
    }

    function updateMobilePropsMode() {
      syncElementPropsHost();
      const tabs = document.querySelector('.sidebar-tabs');
      if (!isMobileViewport()) {
        // Leaving mobile: restore normal sidebar behavior
        if (tabs) tabs.classList.remove('hidden');
        const active = document.querySelector('.sidebar-panel.active');
        if (active && active.id === 'panel-props') {
          const target = document.getElementById(lastSidebarPanelId) ? lastSidebarPanelId : 'panel-qr';
          setActiveSidebarPanel(target);
        }
        return;
      }
      if (typeof mobileMoreMenuOpen !== 'undefined' && mobileMoreMenuOpen) {
        // Don't fight the explicit "more" panel on mobile
        return;
      }
      const hasSelection = canvasSelected || selectedIds.size > 0;
      if (hasSelection) openMobilePropsPanel();
      else closeMobilePropsPanel();
    }

    function showElementProps() {
      syncElementPropsHost();
      const propsDiv = document.getElementById('element-props');
      const tr = (key) => (typeof getI18nText === 'function') ? getI18nText(key) : key;

      // If canvas is selected, show canvas properties
      if (canvasSelected) {
        const canvasW = parseInt(canvas.style.width) || 400;
        const canvasH = parseInt(canvas.style.height) || 400;
        const canvasBg = rgbToHex(canvas.style.backgroundColor || '#ffffff');
        const canvasRadius = parseInt(canvas.style.borderRadius) || 8;
        
        propsDiv.innerHTML = `
        <div class="section">
          <div class="section-title" style="color:#10b981;"><i class="fa-solid fa-square"></i> ${tr('props.canvasTitle')}</div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>${tr('props.width')}</label>
            <input type="number" id="prop-canvas-w" value="${canvasW}" min="200" max="650" />
          </div>
          <div class="form-group">
            <label>${tr('props.height')}</label>
            <input type="number" id="prop-canvas-h" value="${canvasH}" min="200" max="650" />
          </div>
        </div>
        <div class="form-group">
          <label>${tr('props.background')}</label>
          <div class="color-input-wrap">
            <input type="color" id="prop-canvas-bg" value="${canvasBg}" />
          </div>
        </div>
      `;
        
        document.getElementById('prop-canvas-w').oninput = (e) => {
          const clampedW = clampCanvasDimension(e.target.value);
          e.target.value = clampedW;
          const currentH = clampCanvasDimension(canvas.style.height);
          canvas.style.width = clampedW + 'px';
          canvas.style.height = currentH + 'px';
          syncCanvasSizeInputs(clampedW, currentH);
          showElementProps();
          updateToolbarPosition();
          saveToHistory();
        };
        document.getElementById('prop-canvas-h').oninput = (e) => {
          const clampedH = clampCanvasDimension(e.target.value);
          e.target.value = clampedH;
          const currentW = clampCanvasDimension(canvas.style.width);
          canvas.style.height = clampedH + 'px';
          canvas.style.width = currentW + 'px';
          syncCanvasSizeInputs(currentW, clampedH);
          showElementProps();
          updateToolbarPosition();
          saveToHistory();
        };
        document.getElementById('prop-canvas-bg').onchange = (e) => {
          const val = e.target.value;
          const base = document.getElementById('canvas-bg');
          if (base) base.value = val;
          updateCanvasBg(val, true);
        };
        const radiusSlider = document.getElementById('prop-canvas-radius');
        const radiusLabel = document.getElementById('canvas-radius-label');
        if (radiusSlider) {
          radiusSlider.oninput = () => {
            const r = radiusSlider.value;
            canvas.style.borderRadius = r + 'px';
            if (radiusLabel) radiusLabel.textContent = r + 'px';
          };
          radiusSlider.onchange = () => {
            saveToHistory();
          };
        }
        updateMobilePropsMode();
        return;
      }

      // Get first selected element for properties
      const selectedId = selectedIds.size > 0 ? [...selectedIds][0] : null;

      if (!selectedId) {
        propsDiv.innerHTML = `
        <p style="font-size:12px;color:#aaa;margin-top:4px;">${tr('props.selectHint')}</p>
      `;
        updateMobilePropsMode();
        return;
      }

      const el = elements.find(e => e.id === selectedId);
      if (!el) return;

      const rotationValue = normalizeRotation(el.rotation);
      if (el.type === 'text') {
        propsDiv.innerHTML = `
        <div class="form-group">
          <label>${tr('props.text.content')} <small style="color:#888">(${tr('props.text.inlineEditHint')})</small></label>
          <input type="text" id="prop-text" value="${el.text}" />
        </div>
        <div class="form-group">
          <label>${tr('props.text.font')} <small style="color:#888">(${tr('props.text.clickToChooseHint')})</small></label>
          <div class="font-picker-wrapper">
            <input type="text" id="prop-fontfamily" class="font-picker-input" value="${el.fontFamily || 'Be Vietnam Pro'}" style="font-family:'${el.fontFamily || 'Be Vietnam Pro'}';" readonly />
            <div class="font-picker-dropdown" id="font-dropdown">
              <div class="font-picker-search">
                <input type="text" id="font-search" placeholder="${tr('props.text.searchFont')}" autocomplete="off" />
              </div>
              <div id="font-list"></div>
            </div>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>${tr('props.text.fontSize')}</label>
            <input type="number" id="prop-fontsize" value="${el.fontSize}" min="10" max="120" />
          </div>
          <div class="form-group">
            <label>${tr('props.rotation')}</label>
            <input type="number" id="prop-rotation" value="${rotationValue}" min="-360" max="360" step="1" />
          </div>
        </div>
        <div class="form-group">
          <label>${tr('props.text.style')}</label>
          <div class="pill-row">
            <button class="pill ${el.bold ? 'active' : ''}" id="prop-bold-btn" title="${tr('props.text.bold')}"><i class="fa-solid fa-bold"></i></button>
            <button class="pill ${el.italic ? 'active' : ''}" id="prop-italic-btn" title="${tr('props.text.italic')}"><i class="fa-solid fa-italic"></i></button>
            <button class="pill ${el.underline ? 'active' : ''}" id="prop-underline-btn" title="${tr('props.text.underline')}"><i class="fa-solid fa-underline"></i></button>
            <button class="pill ${el.shadow ? 'active' : ''}" id="prop-shadow-btn" title="${tr('props.text.shadow')}"><i class="fa-solid fa-clone"></i></button>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>${tr('props.text.color')}</label>
            <div class="color-input-wrap">
              <input type="color" id="prop-color" value="${el.color}" />
            </div>
          </div>
          <div class="form-group">
            <label>${tr('props.text.background')}</label>
            <div class="color-input-wrap" style="position:relative">
              <input type="color" id="prop-bgcolor" value="${el.bgColor || '#ffffff'}" />
              ${el.bgColor ? '<span id="clear-bgcolor" style="position:absolute;top:-5px;right:-5px;background:#dc2626;color:#fff;border-radius:50%;width:14px;height:14px;font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;">×</span>' : ''}
            </div>
          </div>
        </div>
        <div class="form-group">
          <label>${tr('props.opacity')}</label>
          <div class="opacity-row">
            <input type="range" id="prop-opacity" min="0" max="100" value="${el.opacity !== undefined ? el.opacity : 100}" />
            <span id="opacity-label">${el.opacity !== undefined ? el.opacity : 100}%</span>
          </div>
        </div>
        <button class="toolbar-btn" style="width:100%;justify-content:center;margin-top:8px;background:#dc2626" onclick="deleteSelected()">🗑 ${tr('action.delete')}</button>
      `;

        // Event handlers
        document.getElementById('prop-text').oninput = (e) => { el.text = e.target.value; renderElements(); };
        
        // Custom Font Picker
        const fontInput = document.getElementById('prop-fontfamily');
        const fontDropdown = document.getElementById('font-dropdown');
        const fontList = document.getElementById('font-list');
        const fontSearch = document.getElementById('font-search');
        
        function renderFontList(filter = '') {
          const filtered = fontCatalog.filter(f => f.toLowerCase().includes(filter.toLowerCase()));
          fontList.innerHTML = filtered.map(f => `
            <div class="font-picker-item ${f === el.fontFamily ? 'selected' : ''}" 
                 data-font="${f}" 
                 style="font-family:'${f}';">${f}</div>
          `).join('');
          
          // Preload fonts for visible items
          filtered.slice(0, 15).forEach(f => loadGoogleFont(f));
          
          // Click handler for font items
          fontList.querySelectorAll('.font-picker-item').forEach(item => {
            item.onclick = () => {
              const font = item.dataset.font;
              el.fontFamily = font;
              fontInput.value = font;
              fontInput.style.fontFamily = `'${font}'`;
              loadGoogleFont(font);
              renderElements();
              fontDropdown.classList.remove('show');
            };
          });
        }
        
        fontInput.onclick = () => {
          fontDropdown.classList.toggle('show');
          if (fontDropdown.classList.contains('show')) {
            renderFontList();
            fontSearch.value = '';
            fontSearch.focus();
          }
        };
        
        fontSearch.oninput = () => renderFontList(fontSearch.value);
        fontSearch.onclick = (e) => e.stopPropagation();
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function closeFontDropdown(e) {
          if (!e.target.closest('.font-picker-wrapper')) {
            fontDropdown.classList.remove('show');
          }
        }, { once: false });
        
        document.getElementById('prop-fontsize').oninput = (e) => { el.fontSize = parseInt(e.target.value); el.height = el.fontSize + 10; renderElements(); };
        document.getElementById('prop-color').oninput = (e) => { el.color = e.target.value; renderElements(); };
        
        // Style toggle buttons
        document.getElementById('prop-bold-btn').onclick = () => { el.bold = !el.bold; showElementProps(); renderElements(); };
        document.getElementById('prop-italic-btn').onclick = () => { el.italic = !el.italic; showElementProps(); renderElements(); };
        document.getElementById('prop-underline-btn').onclick = () => { el.underline = !el.underline; showElementProps(); renderElements(); };
        document.getElementById('prop-shadow-btn').onclick = () => { el.shadow = !el.shadow; showElementProps(); renderElements(); };
        
        // Background color
        document.getElementById('prop-bgcolor').oninput = (e) => { el.bgColor = e.target.value; renderElements(); };
        const clearBg = document.getElementById('clear-bgcolor');
        if (clearBg) clearBg.onclick = () => { el.bgColor = ''; showElementProps(); renderElements(); };
        
        // Opacity
        const opacitySlider = document.getElementById('prop-opacity');
        const opacityLabel = document.getElementById('opacity-label');
        if (opacitySlider) {
          opacitySlider.oninput = () => {
            el.opacity = parseInt(opacitySlider.value);
            if (opacityLabel) opacityLabel.textContent = el.opacity + '%';
            renderElements();
          };
        }
      } else if (el.type === 'qr') {
        propsDiv.innerHTML = `
        <div class="form-group">
          <label>${tr('props.size')}</label>
          <input type="number" id="prop-qr-size" value="${el.width}" min="100" max="400" />
        </div>
        <div class="form-group">
          <label>${tr('props.rotation')}</label>
          <input type="number" id="prop-rotation" value="${rotationValue}" min="-360" max="360" step="1" />
        </div>
        <div class="form-group">
          <label>${tr('props.opacity')}</label>
          <div class="opacity-row">
            <input type="range" id="prop-opacity" min="0" max="100" value="${el.opacity !== undefined ? el.opacity : 100}" />
            <span id="opacity-label">${el.opacity !== undefined ? el.opacity : 100}%</span>
          </div>
        </div>
      `;

        document.getElementById('prop-qr-size').oninput = (e) => {
          const size = parseInt(e.target.value);
          el.width = size;
          el.height = size;
          renderElements();
        };
        
        // Opacity
        const opacitySlider = document.getElementById('prop-opacity');
        const opacityLabel = document.getElementById('opacity-label');
        if (opacitySlider) {
          opacitySlider.oninput = () => {
            el.opacity = parseInt(opacitySlider.value);
            if (opacityLabel) opacityLabel.textContent = el.opacity + '%';
            renderElements();
          };
        }
      } else if (el.type === 'shape') {
        const shapeInfo = shapesCatalog.find(s => s.id === el.shapeType);
        const shapeName = shapeInfo ? getShapeLabel(shapeInfo) : el.shapeType;
        const canRoundCorners = ['rect', 'rounded'].includes(el.shapeType);
        const borderRadius = el.borderRadius || 0;
        
        propsDiv.innerHTML = `
        <div class="section">
          <div class="section-title" style="color:#7c3aed;"><i class="fa-solid fa-shapes"></i> ${shapeName}</div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>${tr('props.width')}</label>
            <input type="number" id="prop-shape-w" value="${el.width}" min="20" max="800" />
          </div>
          <div class="form-group">
            <label>${tr('props.height')}</label>
            <input type="number" id="prop-shape-h" value="${el.height}" min="20" max="800" />
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>${tr('props.background')}</label>
            <div class="color-input-wrap">
              <input type="color" id="prop-shape-fill" value="${el.fill || '#2563eb'}" />
            </div>
          </div>
        </div>
        ${canRoundCorners ? `
        <div class="form-group">
          <label>${tr('props.cornerRadius')}</label>
          <div class="opacity-row">
            <input type="range" id="prop-shape-radius" min="0" max="50" value="${borderRadius}" />
            <span id="shape-radius-label">${borderRadius}px</span>
          </div>
        </div>
        ` : ''}
        <div class="form-group">
          <label>${tr('props.rotation')}</label>
          <input type="number" id="prop-rotation" value="${rotationValue}" min="-360" max="360" step="1" />
        </div>
        <div class="form-group">
          <label>${tr('props.opacity')}</label>
          <div class="opacity-row">
            <input type="range" id="prop-opacity" min="0" max="100" value="${el.opacity !== undefined ? el.opacity : 100}" />
            <span id="opacity-label">${el.opacity !== undefined ? el.opacity : 100}%</span>
          </div>
        </div>
        <button class="toolbar-btn" style="width:100%;justify-content:center;margin-top:8px;background:#dc2626" onclick="deleteSelected()">🗑 ${tr('action.delete')}</button>
      `;

        document.getElementById('prop-shape-w').oninput = (e) => { el.width = parseInt(e.target.value); renderElements(); };
        document.getElementById('prop-shape-h').oninput = (e) => { el.height = parseInt(e.target.value); renderElements(); };
        document.getElementById('prop-shape-fill').oninput = (e) => { el.fill = e.target.value; renderElements(); };
        
        if (canRoundCorners) {
          const radiusSlider = document.getElementById('prop-shape-radius');
          const radiusLabel = document.getElementById('shape-radius-label');
          if (radiusSlider) {
            radiusSlider.oninput = () => {
              el.borderRadius = parseInt(radiusSlider.value);
              if (radiusLabel) radiusLabel.textContent = el.borderRadius + 'px';
              renderElements();
            };
          }
        }
        
        // Opacity
        const opacitySlider = document.getElementById('prop-opacity');
        const opacityLabel = document.getElementById('opacity-label');
        if (opacitySlider) {
          opacitySlider.oninput = () => {
            el.opacity = parseInt(opacitySlider.value);
            if (opacityLabel) opacityLabel.textContent = el.opacity + '%';
            renderElements();
          };
        }
      }
      const rotationInput = document.getElementById('prop-rotation');
      if (rotationInput) {
        const updateRotation = (e) => {
          const sanitized = normalizeRotation(e.target.value);
          el.rotation = sanitized;
          rotationInput.value = sanitized;
          updateElementPosition(el);
        };
        rotationInput.oninput = updateRotation;
        rotationInput.onchange = updateRotation;
      }

      updateMobilePropsMode();
    }

    // Track currently editing text element
    let editingTextId = null;
    
    // Start inline text editing (double-click like Canva)
    function startInlineEdit(el) {
      if (el.type !== 'text') return;
      
      editingTextId = el.id;
      const div = document.getElementById(el.id);
      if (!div) return;
      
      const textContent = div.querySelector('.text-content');
      if (!textContent) return;
      
      div.classList.add('editing');
      textContent.classList.add('editing');
      textContent.contentEditable = 'true';
      textContent.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(textContent);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
      
      // Save on blur
      textContent.onblur = () => {
        el.text = textContent.textContent || 'Text';
        exitInlineEdit();
        renderElements();
      };
      
      // Save on Enter (but allow Shift+Enter for newline)
      textContent.onkeydown = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          textContent.blur();
        }
        if (e.key === 'Escape') {
          e.preventDefault();
          textContent.blur();
        }
        // Stop propagation so Delete doesn't delete the element
        e.stopPropagation();
      };
    }
    
    // Exit inline editing
    function exitInlineEdit() {
      if (!editingTextId) return;
      
      const div = document.getElementById(editingTextId);
      if (div) {
        div.classList.remove('editing');
        const textContent = div.querySelector('.text-content');
        if (textContent) {
          textContent.classList.remove('editing');
          textContent.contentEditable = 'false';
        }
      }
      editingTextId = null;
    }

    // Canvas events - Canva style
    function setupCanvasEvents() {
      
      // Start selection from wrapper background (outside canvas)
      canvasWrapper.onmousedown = (e) => {
        if (e.button !== 0) return;
        if (e.target.closest('.canvas-element') || e.target.closest('.canvas-selection-overlay') || e.target.closest('.multi-select-box')) return;
        const wrapperRect = canvasWrapper.getBoundingClientRect();
        const pagePoint = { x: e.clientX, y: e.clientY };
        selectionStart = {
          page: pagePoint,
          canvas: getCanvasPointFromPage(pagePoint)
        };
        isSelecting = true;
        selectionStartedOnWrapper = true;
        lastSelectionPoint = { ...pagePoint };
        if (wrapperSelectionBox) {
          wrapperSelectionBox.style.left = (pagePoint.x - wrapperRect.left + canvasWrapper.scrollLeft) + 'px';
          wrapperSelectionBox.style.top = (pagePoint.y - wrapperRect.top + canvasWrapper.scrollTop) + 'px';
          wrapperSelectionBox.style.width = '0px';
          wrapperSelectionBox.style.height = '0px';
          wrapperSelectionBox.style.display = 'none';
        }
        if (!e.shiftKey) clearSelection();
      };

      // Canvas handle interactions (resize / rotate)
      document.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        const handle = e.target.closest('[data-canvas-handle]');
        const rotHandle = e.target.closest('[data-canvas-rotate]');
        if (!handle && !rotHandle) return;
        canvasSelected = true;
        selectedIds.clear();
        showElementProps();
        renderCanvasSelectionOverlay();

        const rect = canvas.getBoundingClientRect();
        const startPointer = { x: e.clientX, y: e.clientY };
        if (handle) {
          e.preventDefault();
          saveToHistory();
          canvasResizing = {
            handle: handle.dataset.canvasHandle,
            startPointer,
            startW: parseInt(canvas.style.width) || rect.width,
            startH: parseInt(canvas.style.height) || rect.height
          };
        } else if (rotHandle) {
          e.preventDefault();
          saveToHistory();
          const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
          canvasRotating = {
            center,
            startPointer,
            startAngle: Math.atan2(startPointer.y - center.y, startPointer.x - center.x),
            startRotation: canvasRotation
          };
        }
      });

      // Double-click to edit text inline
      canvas.ondblclick = (e) => {
        const target = e.target.closest('.canvas-element');
        if (!target) return;
        
        const el = elements.find(el => el.id === target.id);
        if (el && el.type === 'text') {
          e.preventDefault();
          startInlineEdit(el);
        }
      };
      
      // Right-click context menu
      canvas.oncontextmenu = (e) => {
        e.preventDefault();
        const target = e.target.closest('.canvas-element');
        const elementId = target ? target.id : null;
        showContextMenu(e, elementId);
      };
      
      canvasWrapper.oncontextmenu = (e) => {
        e.preventDefault();
        const target = e.target.closest('.canvas-element');
        const elementId = target ? target.id : null;
        showContextMenu(e, elementId);
      };
      
      // Hide context menu on click anywhere
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu')) {
          hideContextMenu();
        }
        // Hide floating toolbar menus
        if (!e.target.closest('.floating-toolbar-dropdown') && !e.target.closest('.floating-toolbar-menu')) {
          hideLayerMenu();
          hideMoreMenu();
        }
      });
      
      canvas.onmousedown = (e) => {
        if (e.button !== 0) return;
        
        // Hide context menu
        hideContextMenu();
        
        // Deselect canvas when clicking on canvas content
        if (canvasSelected) {
          canvasSelected = false;
          canvas.style.outline = 'none';
          canvas.style.outlineOffset = '0';
          removeCanvasSelectionOverlay();
        }
        
        // If clicking outside the editing element, exit edit mode
        if (editingTextId) {
          const target = e.target.closest('.canvas-element');
          if (!target || target.id !== editingTextId) {
            exitInlineEdit();
          } else {
            // Allow clicking inside the editing text
            return;
          }
        }

        const canvasPoint = getCanvasPoint(e);

        const target = e.target.closest('.canvas-element');
        const handle = e.target.closest('.resize-handle');
        const rotateHandle = e.target.closest('.rotation-handle');

        if (rotateHandle) {
          // Start rotating
          const elId = rotateHandle.closest('.canvas-element')?.id;
          if (!elId || !selectedIds.has(elId)) return;

          const el = elements.find(e => e.id === elId);
          if (!el) return;

          e.preventDefault();
          saveToHistory();
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          rotating = {
            el,
            centerX,
            centerY,
            startAngle: Math.atan2(canvasPoint.y - centerY, canvasPoint.x - centerX),
            startRotation: normalizeRotation(el.rotation)
          };
        } else if (handle) {
          // Start resizing - only if element is selected
          const elId = handle.closest('.canvas-element')?.id;
          if (!elId || !selectedIds.has(elId)) return;

          const el = elements.find(e => e.id === elId);
          if (!el) return;

          e.preventDefault();
          saveToHistory();
          resizing = {
            el,
            handle: handle.dataset.handle,
            startPointer: canvasPoint,
            startW: el.width,
            startH: el.height,
            startElX: el.x,
            startElY: el.y,
            startFontSize: el.fontSize || 16
          };
        } else if (target) {
          // Click on element
          e.preventDefault();
          const id = target.id;

          if (e.shiftKey) {
            // Shift+click: add/remove from selection
            // If user shift-clicks something already selected, treat it as deselect and don't start dragging.
            const wasSelected = selectedIds.has(id);
            selectElement(id, true);
            if (wasSelected && !selectedIds.has(id)) {
              return;
            }
          } else if (!selectedIds.has(id)) {
            // Click on unselected element: select it
            selectElement(id, false);
          }
          // If already selected, prepare for drag

          // Start dragging all selected elements
          const el = elements.find(e => e.id === id);
          if (el) {
            saveToHistory();
            dragging = {
              startPointer: canvasPoint,
              elements: [...selectedIds].map(id => {
                const el = elements.find(e => e.id === id);
                return el ? { el, startX: el.x, startY: el.y } : null;
              }).filter(Boolean)
            };
          }
        } else {
          // Click on empty canvas background - start selection box
          e.preventDefault();
          const wrapperRect = canvasWrapper.getBoundingClientRect();
          const pagePoint = { x: e.clientX, y: e.clientY };
          selectionStart = {
            page: pagePoint,
            canvas: getCanvasPointFromPage(pagePoint)
          };
          isSelecting = true;
          selectionStartedOnCanvas = true; // Track that we clicked on canvas background
          lastSelectionPoint = { ...pagePoint };

          if (wrapperSelectionBox) {
            wrapperSelectionBox.style.left = (pagePoint.x - wrapperRect.left + canvasWrapper.scrollLeft) + 'px';
            wrapperSelectionBox.style.top = (pagePoint.y - wrapperRect.top + canvasWrapper.scrollTop) + 'px';
            wrapperSelectionBox.style.width = '0px';
            wrapperSelectionBox.style.height = '0px';
            wrapperSelectionBox.style.display = 'none';
          }

          // Clear selection unless shift is held
          if (!e.shiftKey) {
            clearSelection();
          }
        }
      };

      document.onmousemove = (e) => {
        if (isSelecting) {
          updateSelectionBox(e);
          return;
        }

        // Multi-select group dragging
        if (multiSelectDragging) {
          const pointer = getCanvasPoint(e);
          const dx = pointer.x - multiSelectDragging.startPointer.x;
          const dy = pointer.y - multiSelectDragging.startPointer.y;
          multiSelectDragging.elements.forEach(({ el, startX, startY }) => {
            el.x = Math.round(startX + dx);
            el.y = Math.round(startY + dy);
            updateElementPosition(el);
          });
          // Update box position
          if (multiSelectBox) {
            multiSelectBox.style.left = (multiSelectDragging.startBounds.x + dx) + 'px';
            multiSelectBox.style.top = (multiSelectDragging.startBounds.y + dy) + 'px';
          }
          return;
        }

        // Multi-select group resizing - Canva-style proportional scaling
        if (multiSelectResizing) {
          const pointer = getCanvasPoint(e);
          const dx = pointer.x - multiSelectResizing.startPointer.x;
          const dy = pointer.y - multiSelectResizing.startPointer.y;
          const h = multiSelectResizing.handle;
          const b = multiSelectResizing.startBounds;
          
          // Calculate new bounds based on handle being dragged
          let newX = b.x, newY = b.y, newW = b.width, newH = b.height;
          
          // Corner handles - proportional by default
          const isCorner = ['nw', 'ne', 'sw', 'se'].includes(h);
          
          if (isCorner) {
            // Calculate aspect ratio for proportional scaling
            const aspectRatio = b.width / b.height;
            
            if (h === 'se') {
              // Southeast - scale from top-left anchor
              const delta = Math.max(dx, dy / aspectRatio * aspectRatio);
              newW = Math.max(50, b.width + delta);
              newH = Math.max(50, b.height + delta / aspectRatio);
            } else if (h === 'nw') {
              // Northwest - scale from bottom-right anchor
              const delta = Math.max(-dx, -dy / aspectRatio * aspectRatio);
              newW = Math.max(50, b.width + delta);
              newH = Math.max(50, b.height + delta / aspectRatio);
              newX = b.x + b.width - newW;
              newY = b.y + b.height - newH;
            } else if (h === 'ne') {
              // Northeast - scale from bottom-left anchor
              const delta = Math.max(dx, -dy / aspectRatio * aspectRatio);
              newW = Math.max(50, b.width + delta);
              newH = Math.max(50, b.height + delta / aspectRatio);
              newY = b.y + b.height - newH;
            } else if (h === 'sw') {
              // Southwest - scale from top-right anchor
              const delta = Math.max(-dx, dy / aspectRatio * aspectRatio);
              newW = Math.max(50, b.width + delta);
              newH = Math.max(50, b.height + delta / aspectRatio);
              newX = b.x + b.width - newW;
            }
          } else {
            // Edge handles - free scaling on one axis
            if (h === 'e') newW = Math.max(50, b.width + dx);
            if (h === 'w') { newW = Math.max(50, b.width - dx); newX = b.x + b.width - newW; }
            if (h === 's') newH = Math.max(50, b.height + dy);
            if (h === 'n') { newH = Math.max(50, b.height - dy); newY = b.y + b.height - newH; }
          }
          
          // Calculate scale factors from original bounds
          const scaleX = newW / b.width;
          const scaleY = newH / b.height;
          const uniformScale = Math.min(scaleX, scaleY);
          
          // Apply transformations to each element
          multiSelectResizing.elements.forEach(({ el, startX, startY, startW, startH, startFontSize }) => {
            // Scale position relative to new bounds origin
            const relX = (startX - b.x) / b.width;
            const relY = (startY - b.y) / b.height;
            
            el.x = Math.round(newX + relX * newW);
            el.y = Math.round(newY + relY * newH);
            el.width = Math.max(20, Math.round(startW * scaleX));
            el.height = Math.max(20, Math.round(startH * scaleY));
            
            // Scale font proportionally for text elements
            if (el.type === 'text' && startFontSize) {
              el.fontSize = Math.max(8, Math.round(startFontSize * uniformScale));
              // Update DOM immediately for live preview
              const div = document.getElementById(el.id);
              if (div) {
                const textContent = div.querySelector('.text-content');
                if (textContent) {
                  const fontSize = fitTextToContainer(el);
                  textContent.style.fontSize = fontSize + 'px';
                }
              }
            }
            
            updateElementPosition(el);
          });
          
          // Update bounding box
          if (multiSelectBox) {
            multiSelectBox.style.left = newX + 'px';
            multiSelectBox.style.top = newY + 'px';
            multiSelectBox.style.width = newW + 'px';
            multiSelectBox.style.height = newH + 'px';
          }
          return;
        }

        // Canvas resizing
        if (canvasResizing) {
          const dx = e.clientX - canvasResizing.startPointer.x;
          const dy = e.clientY - canvasResizing.startPointer.y;
          let newW = canvasResizing.startW;
          let newH = canvasResizing.startH;
          const h = canvasResizing.handle;
          if (h.includes('e')) newW = Math.max(MIN_CANVAS_SIZE, canvasResizing.startW + dx);
          if (h.includes('w')) newW = Math.max(MIN_CANVAS_SIZE, canvasResizing.startW - dx);
          if (h.includes('s')) newH = Math.max(MIN_CANVAS_SIZE, canvasResizing.startH + dy);
          if (h.includes('n')) newH = Math.max(MIN_CANVAS_SIZE, canvasResizing.startH - dy);

          const clampedW = clampCanvasDimension(newW);
          const clampedH = clampCanvasDimension(newH);

          const oldRect = canvas.getBoundingClientRect();
          canvas.style.width = clampedW + 'px';
          canvas.style.height = clampedH + 'px';
          syncCanvasSizeInputs(clampedW, clampedH);
          updateCanvasTransform();
          
          const newRect = canvas.getBoundingClientRect();
          keepCanvasViewStable(oldRect, newRect);
          centerCanvasInView();

          renderCanvasSelectionOverlay();
          renderElements();
          showElementProps();
          return;
        }

        // Canvas rotating
        if (canvasRotating) {
          const pointer = { x: e.clientX, y: e.clientY };
          const currentAngle = Math.atan2(pointer.y - canvasRotating.center.y, pointer.x - canvasRotating.center.x);
          let delta = (currentAngle - canvasRotating.startAngle) * (180 / Math.PI);
          let newRot = canvasRotating.startRotation + delta;
          // Snap to 15deg when Shift, otherwise 5deg threshold to common angles
          if (e.shiftKey) {
            newRot = Math.round(newRot / 15) * 15;
          } else {
            const snaps = [0, 45, 90, 135, 180, -45, -90, -135, -180];
            for (const s of snaps) {
              if (Math.abs(newRot - s) < 5) { newRot = s; break; }
            }
          }
          while (newRot > 180) newRot -= 360;
          while (newRot < -180) newRot += 360;
          canvasRotation = newRot;
          updateCanvasTransform();
          return;
        }

        clearGuides();

        const pointer = getCanvasPoint(e);

        // Handle rotation
        if (rotating) {
          const currentAngle = Math.atan2(pointer.y - rotating.centerY, pointer.x - rotating.centerX);
          let deltaAngle = (currentAngle - rotating.startAngle) * (180 / Math.PI);
          let newRotation = rotating.startRotation + deltaAngle;
          
          // Auto-snap to common angles (0, 45, 90, 135, 180, -45, -90, -135)
          const snapAngles = [0, 45, 90, 135, 180, -45, -90, -135, -180];
          const snapThreshold = e.shiftKey ? 0 : 5; // More precise with Shift
          
          // Snap to 15 degree increments when holding Shift
          if (e.shiftKey) {
            newRotation = Math.round(newRotation / 15) * 15;
          } else {
            // Auto-snap to common angles
            for (const snapAngle of snapAngles) {
              if (Math.abs(newRotation - snapAngle) < snapThreshold) {
                newRotation = snapAngle;
                break;
              }
            }
          }
          
          // Normalize to -180 to 180
          while (newRotation > 180) newRotation -= 360;
          while (newRotation < -180) newRotation += 360;
          
          rotating.el.rotation = Math.round(newRotation);
          updateElementPosition(rotating.el);
          showElementProps(); // Real-time update
          return;
        }

        if (dragging && dragging.elements.length > 0) {
          const dx = pointer.x - dragging.startPointer.x;
          const dy = pointer.y - dragging.startPointer.y;

          // Move all selected elements
          dragging.elements.forEach(({ el, startX, startY }) => {
            el.x = Math.round(startX + dx);
            el.y = Math.round(startY + dy);
          });

          // Smart snap logic for primary element
          if (dragging.elements.length >= 1) {
            const el = dragging.elements[0].el;
            const canvasW = parseInt(canvas.style.width);
            const canvasH = parseInt(canvas.style.height);
            const centerX = (canvasW - el.width) / 2;
            const centerY = (canvasH - el.height) / 2;
            const snapDist = 8;
            
            // Get other elements (not being dragged)
            const otherElements = elements.filter(other => !selectedIds.has(other.id));
            
            // Element edges
            const elLeft = el.x;
            const elRight = el.x + el.width;
            const elTop = el.y;
            const elBottom = el.y + el.height;
            const elCenterX = el.x + el.width / 2;
            const elCenterY = el.y + el.height / 2;

            let snappedH = false, snappedV = false;
            
            // Snap to canvas
            if (Math.abs(elCenterX - canvasW / 2) < snapDist) { el.x = centerX; snappedH = true; showGuide('vertical', canvasW / 2); }
            if (Math.abs(elLeft) < snapDist) { el.x = 0; snappedH = true; showGuide('vertical', 0); }
            if (Math.abs(elRight - canvasW) < snapDist) { el.x = canvasW - el.width; snappedH = true; showGuide('vertical', canvasW); }
            if (Math.abs(elCenterY - canvasH / 2) < snapDist) { el.y = centerY; snappedV = true; showGuide('horizontal', canvasH / 2); }
            if (Math.abs(elTop) < snapDist) { el.y = 0; snappedV = true; showGuide('horizontal', 0); }
            if (Math.abs(elBottom - canvasH) < snapDist) { el.y = canvasH - el.height; snappedV = true; showGuide('horizontal', canvasH); }
            
            // Snap to other elements
            for (const other of otherElements) {
              const otherLeft = other.x;
              const otherRight = other.x + other.width;
              const otherTop = other.y;
              const otherBottom = other.y + other.height;
              const otherCenterX = other.x + other.width / 2;
              const otherCenterY = other.y + other.height / 2;
              
              // Vertical alignments (X axis)
              if (!snappedH) {
                // Left to left
                if (Math.abs(elLeft - otherLeft) < snapDist) { el.x = otherLeft; snappedH = true; showGuide('vertical', otherLeft); }
                // Right to right
                else if (Math.abs(elRight - otherRight) < snapDist) { el.x = otherRight - el.width; snappedH = true; showGuide('vertical', otherRight); }
                // Center to center
                else if (Math.abs(elCenterX - otherCenterX) < snapDist) { el.x = otherCenterX - el.width / 2; snappedH = true; showGuide('vertical', otherCenterX); }
                // Left to right
                else if (Math.abs(elLeft - otherRight) < snapDist) { el.x = otherRight; snappedH = true; showGuide('vertical', otherRight); }
                // Right to left
                else if (Math.abs(elRight - otherLeft) < snapDist) { el.x = otherLeft - el.width; snappedH = true; showGuide('vertical', otherLeft); }
              }
              
              // Horizontal alignments (Y axis)
              if (!snappedV) {
                // Top to top
                if (Math.abs(elTop - otherTop) < snapDist) { el.y = otherTop; snappedV = true; showGuide('horizontal', otherTop); }
                // Bottom to bottom
                else if (Math.abs(elBottom - otherBottom) < snapDist) { el.y = otherBottom - el.height; snappedV = true; showGuide('horizontal', otherBottom); }
                // Center to center
                else if (Math.abs(elCenterY - otherCenterY) < snapDist) { el.y = otherCenterY - el.height / 2; snappedV = true; showGuide('horizontal', otherCenterY); }
                // Top to bottom
                else if (Math.abs(elTop - otherBottom) < snapDist) { el.y = otherBottom; snappedV = true; showGuide('horizontal', otherBottom); }
                // Bottom to top
                else if (Math.abs(elBottom - otherTop) < snapDist) { el.y = otherTop - el.height; snappedV = true; showGuide('horizontal', otherTop); }
              }
              
              if (snappedH && snappedV) break;
            }
          }

          // Update positions in DOM
          dragging.elements.forEach(({ el }) => updateElementPosition(el));
          showElementProps(); // Real-time update
        }

        // Canva-style single element resize
        if (resizing) {
          const dx = pointer.x - resizing.startPointer.x;
          const dy = pointer.y - resizing.startPointer.y;
          const h = resizing.handle;
          const isCorner = ['nw', 'ne', 'sw', 'se'].includes(h);
          const aspectRatio = resizing.startW / resizing.startH;
          
          let newW = resizing.startW;
          let newH = resizing.startH;
          let newX = resizing.startElX;
          let newY = resizing.startElY;
          
          if (isCorner) {
            // Corner handles - proportional scaling (Canva behavior)
            // Use the larger delta to determine scale
            let scale = 1;
            
            if (h === 'se') {
              // Scale based on diagonal movement
              const avgDelta = (dx + dy) / 2;
              newW = Math.max(30, resizing.startW + avgDelta);
              newH = Math.max(30, newW / aspectRatio);
            } else if (h === 'nw') {
              const avgDelta = (-dx + -dy) / 2;
              newW = Math.max(30, resizing.startW + avgDelta);
              newH = Math.max(30, newW / aspectRatio);
              newX = resizing.startElX + resizing.startW - newW;
              newY = resizing.startElY + resizing.startH - newH;
            } else if (h === 'ne') {
              const avgDelta = (dx + -dy) / 2;
              newW = Math.max(30, resizing.startW + avgDelta);
              newH = Math.max(30, newW / aspectRatio);
              newY = resizing.startElY + resizing.startH - newH;
            } else if (h === 'sw') {
              const avgDelta = (-dx + dy) / 2;
              newW = Math.max(30, resizing.startW + avgDelta);
              newH = Math.max(30, newW / aspectRatio);
              newX = resizing.startElX + resizing.startW - newW;
            }
          } else {
            // Edge handles - free scaling on one axis
            if (h === 'e') newW = Math.max(30, resizing.startW + dx);
            if (h === 'w') { newW = Math.max(30, resizing.startW - dx); newX = resizing.startElX + resizing.startW - newW; }
            if (h === 's') newH = Math.max(20, resizing.startH + dy);
            if (h === 'n') { newH = Math.max(20, resizing.startH - dy); newY = resizing.startElY + resizing.startH - newH; }
          }
          
          // QR always square
          if (resizing.el.type === 'qr') {
            const size = Math.max(newW, newH);
            if (isCorner) {
              newW = newH = size;
            }
          }
          
          // Scale font proportionally for text
          if (resizing.el.type === 'text') {
            const scale = Math.min(newW / resizing.startW, newH / resizing.startH);
            resizing.el.fontSize = Math.max(8, Math.round(resizing.startFontSize * scale));
          }
          
          resizing.el.width = Math.round(newW);
          resizing.el.height = Math.round(newH);
          resizing.el.x = Math.round(newX);
          resizing.el.y = Math.round(newY);
          
          updateElementPosition(resizing.el);
          
          // Live font update
          if (resizing.el.type === 'text') {
            const div = document.getElementById(resizing.el.id);
            if (div) {
              const textContent = div.querySelector('.text-content');
              if (textContent) {
                const fontSize = fitTextToContainer(resizing.el);
                textContent.style.fontSize = fontSize + 'px';
              }
            }
          }
          
          showElementProps();
        }
      };

      document.onmouseup = (e) => {
        if (isSelecting) {
          const startPoint = selectionStart?.page;
          const endPoint = lastSelectionPoint || (e ? { x: e.clientX, y: e.clientY } : null);
          isSelecting = false;
          if (selectionBox) selectionBox.style.display = 'none';
          if (wrapperSelectionBox) wrapperSelectionBox.style.display = 'none';
          
          if (startPoint && endPoint) {
            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const distance = Math.hypot(dx, dy);
            
            if (distance < 6) {
              // Short click - just tap
              if (selectionStartedOnCanvas) {
                // Clicked on canvas background - select canvas
                selectedIds.clear();
                refreshSelectionStyles();
                removeMultiSelectBox();
                highlightCanvasSelection();
              } else if (selectionStartedOnWrapper) {
                // Clicked on wrapper (outside canvas) - clear all
                selectedIds.clear();
                refreshSelectionStyles();
                removeMultiSelectBox();
              }
            }
          }
          
          selectionStartedOnWrapper = false;
          selectionStartedOnCanvas = false;
          selectionStart = null;
          lastSelectionPoint = null;
          showElementProps();
        }

        if (dragging || resizing || rotating) {
          // Don't call renderElements - just update handles if needed
          if (selectedIds.size > 0) {
            renderElements();
          }
        }

        // Multi-select drag/resize end
        if (multiSelectDragging || multiSelectResizing) {
          multiSelectDragging = null;
          multiSelectResizing = null;
          updateMultiSelectBox();
          renderElements();
        }

        if (canvasResizing || canvasRotating) {
          if (canvasResizing) {
            saveToHistory();
            showElementProps();
          }
          canvasResizing = null;
          canvasRotating = null;
          renderCanvasSelectionOverlay();
        }

        clearGuides();
        dragging = null;
        resizing = null;
        rotating = null;
      };
    }

    // Update element position (fast, no re-render)
    function updateElementPosition(el) {
      const div = document.getElementById(el.id);
      if (div) {
        div.style.left = el.x + 'px';
        div.style.top = el.y + 'px';
        div.style.width = el.width + 'px';
        div.style.height = el.height + 'px';
        setElementRotation(div, el);
      }
    }

    // Center all elements in the canvas
    function centerAllElements() {
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      
      elements.forEach(el => {
        el.x = (canvasW - el.width) / 2;
        el.y = (canvasH - el.height) / 2;
      });
    }

    // Zoom canvas - Canva style
    function zoomCanvas(delta, e = null) {
      // If the user manually zooms, don't let auto-fit shrink it back.
      viewportZoomMode = 'manual';
      const oldZoom = canvasZoom;
      
      if (delta === 0) {
        canvasZoom = 100;
      } else {
        canvasZoom = Math.max(10, Math.min(400, canvasZoom + delta));
      }
      updateCanvasTransform();
      centerCanvasInView();
      updateZoomLabels();
    }
    
    // Auto-fit canvas to viewport - ensures canvas is visible without overflow
    function autoFitCanvasToViewport(forceApply = false) {
      const canvasEl = document.getElementById('canvas');
      const wrapperEl = document.getElementById('canvas-wrapper');
      if (!canvasEl || !wrapperEl) return;

      // If user manually zoomed, don't auto-fit unless forced.
      if (!forceApply && typeof viewportZoomMode !== 'undefined' && viewportZoomMode === 'manual') return;
      if (forceApply && typeof viewportZoomMode !== 'undefined') viewportZoomMode = 'auto';
      
      const canvasW = parseInt(canvasEl.style.width) || 400;
      const canvasH = parseInt(canvasEl.style.height) || 400;
      
      // Get available space with padding
      const padding = window.innerWidth <= 480 ? 24 : window.innerWidth <= 750 ? 32 : 80;
      const availableW = wrapperEl.clientWidth - padding * 2;
      const availableH = (wrapperEl.clientHeight - getBottomOverlayInset()) - padding * 2;
      
      if (availableW <= 0 || availableH <= 0) return;
      
      // Calculate zoom to fit
      const scaleX = availableW / canvasW;
      const scaleY = availableH / canvasH;
      let fitZoom = Math.min(scaleX, scaleY) * 100;
      // Clamp; keep fractional for smooth updates
      fitZoom = Math.max(10, Math.min(400, fitZoom));
      
      // Only adjust if canvas would overflow or is much smaller than available space
      const currentScale = canvasZoom / 100;
      const scaledW = canvasW * currentScale;
      const scaledH = canvasH * currentScale;
      
      const isOverflowing = scaledW > availableW || scaledH > availableH;
      const isTooSmall = scaledW < availableW * 0.3 && scaledH < availableH * 0.3;
      
      if (forceApply || isOverflowing || isTooSmall) {
        canvasZoom = fitZoom;
        updateCanvasTransform();
        updateZoomLabels();
        centerCanvasInView();
      }
    }

    // Real-time viewport fitting (smooth) using requestAnimationFrame
    let viewportUpdateRaf = null;
    let viewportForceFit = false;
    let viewportZoomMode = 'auto'; // 'auto' | 'manual'

    function updateZoomLabels() {
      const text = Math.round(canvasZoom || 100) + '%';
      document.querySelectorAll('#zoom-value, #zoom-value-mobile').forEach(el => {
        el.textContent = text;
      });

      const slider = document.getElementById('zoom-slider-mobile');
      if (slider) slider.value = String(Math.round(canvasZoom || 100));
      const sliderLabel = document.getElementById('zoom-slider-value-mobile');
      if (sliderLabel) sliderLabel.textContent = text;
    }

    function setupMobileZoomSlider() {
      const slider = document.getElementById('zoom-slider-mobile');
      if (!slider) return;
      slider.addEventListener('input', () => {
        viewportZoomMode = 'manual';
        const next = Number(slider.value);
        if (!Number.isFinite(next)) return;
        canvasZoom = Math.max(10, Math.min(400, next));
        updateCanvasTransform();
        centerCanvasInView();
        updateToolbarPosition();
        renderCanvasSelectionOverlay();
        updateZoomLabels();
      });
    }

    function fitViewport() {
      viewportZoomMode = 'auto';
      scheduleViewportUpdate(true);
    }

    function computeFitZoomTarget() {
      const canvasW = parseInt(canvas.style.width) || 400;
      const canvasH = parseInt(canvas.style.height) || 400;
      const padding = window.innerWidth <= 480 ? 24 : window.innerWidth <= 750 ? 32 : 80;
      const availableW = canvasWrapper.clientWidth - padding * 2;
      const availableH = (canvasWrapper.clientHeight - getBottomOverlayInset()) - padding * 2;
      if (availableW <= 0 || availableH <= 0) return null;
      const scaleX = availableW / canvasW;
      const scaleY = availableH / canvasH;
      const targetZoom = Math.max(10, Math.min(400, Math.min(scaleX, scaleY) * 100));
      return { targetZoom, availableW, availableH, canvasW, canvasH };
    }

    function scheduleViewportUpdate(forceFit = false) {
      if (forceFit) viewportZoomMode = 'auto';
      viewportForceFit = viewportForceFit || forceFit;
      if (viewportUpdateRaf) return;
      viewportUpdateRaf = requestAnimationFrame(runViewportUpdate);
    }

    function runViewportUpdate() {
      viewportUpdateRaf = null;
      const info = computeFitZoomTarget();
      if (!info) return;

      const { targetZoom, availableW, availableH, canvasW, canvasH } = info;
      const currentScale = canvasZoom / 100;
      const scaledW = canvasW * currentScale;
      const scaledH = canvasH * currentScale;
      const isOverflowing = scaledW > availableW || scaledH > availableH;
      const isTooSmall = scaledW < availableW * 0.3 && scaledH < availableH * 0.3;
      const shouldFit = viewportForceFit || (viewportZoomMode === 'auto' && (isOverflowing || isTooSmall));

      if (shouldFit) {
        const alpha = viewportForceFit ? 0.55 : 0.35;
        const nextZoom = Math.max(10, Math.min(400, canvasZoom + (targetZoom - canvasZoom) * alpha));
        if (Math.abs(nextZoom - canvasZoom) > 0.02) {
          canvasZoom = nextZoom;
          updateCanvasTransform();
          updateZoomLabels();
        }
      }

      centerCanvasInView();
      updateToolbarPosition();
      renderCanvasSelectionOverlay();

      if (shouldFit && Math.abs(targetZoom - canvasZoom) > 0.25) {
        viewportUpdateRaf = requestAnimationFrame(runViewportUpdate);
      } else {
        viewportForceFit = false;
      }
    }
    
    // Debounce function for resize events
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    
    // Setup scroll wheel zoom like Canva
    function setupScrollZoom() {
      let pendingDelta = 0;
      let rafId = 0;
      let lastEvent = null;

      const scheduleApply = () => {
        if (rafId) return;
        rafId = requestAnimationFrame(() => {
          rafId = 0;
          const d = pendingDelta;
          pendingDelta = 0;
          if (!d) return;
          zoomCanvas(d, lastEvent || undefined);
        });
      };

      canvasWrapper.addEventListener('wheel', (e) => {
        // Trackpad pinch-to-zoom usually comes as wheel + ctrlKey in Chromium.
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          lastEvent = e;

          const abs = Math.abs(e.deltaY);
          // Adaptive steps: trackpad/pinch sends small deltas frequently; don't jump 10% each tick.
          let step;
          if (abs < 8) step = 0.5;
          else if (abs < 16) step = 1;
          else if (abs < 40) step = 2;
          else if (abs < 100) step = 4;
          else step = 8;

          const delta = e.deltaY > 0 ? -step : step;
          pendingDelta += delta;
          // Clamp burst so a fast swipe doesn't overshoot wildly.
          pendingDelta = Math.max(-30, Math.min(30, pendingDelta));
          scheduleApply();
        }
      }, { passive: false });
    }

    // Update canvas background
    function updateCanvasBg(color = null, commit = false) {
      const val = color || (document.getElementById('canvas-bg')?.value) || '#ffffff';
      canvas.style.backgroundColor = val;
      const propBg = document.getElementById('prop-canvas-bg');
      if (propBg) propBg.value = val;
      if (commit) saveToHistory();
      showElementProps();
    }

    // Update canvas size - elements stay at their absolute position
    function updateCanvasSize() {
      saveToHistory();
      const widthInput = document.getElementById('canvas-width');
      const heightInput = document.getElementById('canvas-height');
      let newW = widthInput ? parseInt(widthInput.value) || 400 : 400;
      let newH = heightInput ? parseInt(heightInput.value) || 400 : 400;
      newW = clampCanvasDimension(newW);
      newH = clampCanvasDimension(newH);
      syncCanvasSizeInputs(newW, newH);
      
      canvas.style.width = newW + 'px';
      canvas.style.height = newH + 'px';
      updateCanvasTransform();
      renderElements();
      centerCanvasInView();
      updateToolbarPosition();
      showElementProps();
    }

    // Align selected element(s)
    function alignSelected(align) {
      if (selectedIds.size === 0) return;

      const canvasW = parseInt(canvas.style.width);
      const canvasH = parseInt(canvas.style.height);

      selectedIds.forEach(id => {
        const el = elements.find(e => e.id === id);
        if (!el) return;

        switch (align) {
          case 'left': el.x = 0; break;
          case 'right': el.x = canvasW - el.width; break;
          case 'center-h': el.x = (canvasW - el.width) / 2; break;
          case 'top': el.y = 0; break;
          case 'bottom': el.y = canvasH - el.height; break;
          case 'center-v': el.y = (canvasH - el.height) / 2; break;
        }
      });

      renderElements();
    }

    // Export state
    let exportFormat = 'png';
    let exportScale = 2;
    let exportQuality = 92;
    let exportRadius = 8;
    let exportSizeMode = 'scale'; // 'scale' or 'custom'
    let exportCustomWidth = 800;
    let exportCustomHeight = 800;
    let exportLockRatio = true;
    let exportAspectRatio = 1;
    let exportSizeEstimateToken = 0;
    let exportSizeEstimateTimer = null;

    const EXPORT_FILENAME_DEFAULT = 'qr_design';
    const EXPORT_FILENAME_MAX_LENGTH = 80;

    function getExportExtension(format) {
      if (format === 'jpg') return 'jpg';
      if (format === 'svg') return 'svg';
      if (format === 'pdf') return 'pdf';
      return 'png';
    }

    function stripKnownExtension(filename) {
      const v = String(filename || '').trim();
      const m = v.match(/^(.*)\.([A-Za-z0-9]+)$/);
      if (!m) return v;
      const ext = String(m[2] || '').toLowerCase();
      if (ext === 'png' || ext === 'jpg' || ext === 'jpeg' || ext === 'svg' || ext === 'pdf') return (m[1] || '').trim();
      return v;
    }

    function sanitizeFilenameBase(raw) {
      let name = String(raw || '')
        .replace(/[\\\/\:\*\?\"\<\>\|]+/g, ' ')
        .replace(/[\r\n\t]+/g, ' ')
        .trim();

      name = name.replace(/[. ]+$/g, '').trim();
      if (!name) name = EXPORT_FILENAME_DEFAULT;
      if (name.length > EXPORT_FILENAME_MAX_LENGTH) name = name.slice(0, EXPORT_FILENAME_MAX_LENGTH).trim();
      return name || EXPORT_FILENAME_DEFAULT;
    }

    function getExportFilenameInputEl() {
      return document.getElementById('export-filename');
    }

    function getExportFilenameBaseFromUI() {
      const input = getExportFilenameInputEl();
      const raw = input ? input.value : '';
      const base = stripKnownExtension(raw);
      return sanitizeFilenameBase(base);
    }

    function formatBytes(bytes) {
      const n = Number(bytes) || 0;
      if (n < 1024) return `${n} B`;
      const kb = n / 1024;
      if (kb < 1024) return `${kb.toFixed(0)} KB`;
      const mb = kb / 1024;
      return `${mb.toFixed(1)} MB`;
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise(resolve => {
        try {
          canvas.toBlob(b => resolve(b), type, quality);
        } catch {
          resolve(null);
        }
      });
    }

    function renderExportCanvas(dims) {
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);

      const scaleX = dims.width / canvasW;
      const scaleY = dims.height / canvasH;

      const cvs = document.createElement('canvas');
      cvs.width = dims.width;
      cvs.height = dims.height;
      const ctx = cvs.getContext('2d');
      ctx.scale(scaleX, scaleY);

      ctx.save();
      if (exportRadius > 0) {
        ctx.beginPath();
        ctx.roundRect(0, 0, canvasW, canvasH, exportRadius);
        ctx.clip();
      }

      ctx.fillStyle = canvasEl.style.backgroundColor || '#fff';
      ctx.fillRect(0, 0, canvasW, canvasH);
      drawElementsToContext(ctx, scaleX);
      ctx.restore();
      return cvs;
    }

    function scheduleEstimateExportFileSize(dims) {
      if (exportSizeEstimateTimer) {
        clearTimeout(exportSizeEstimateTimer);
        exportSizeEstimateTimer = null;
      }

      exportSizeEstimateTimer = setTimeout(() => {
        exportSizeEstimateTimer = null;
        estimateExportFileSize(dims);
      }, 250);
    }

    async function estimateExportFileSize(dims) {
      const token = ++exportSizeEstimateToken;
      const sizeInfo = document.getElementById('export-size-info');
      if (sizeInfo) sizeInfo.textContent = `${dims.width} × ${dims.height} px (… )`;

      // If modal closed while estimating, abort.
      const modal = document.getElementById('export-modal');
      if (!modal || modal.style.display === 'none') return;

      try {
        const cvs = renderExportCanvas(dims);
        let bytes = 0;

        // For PDF/SVG, estimating via actual PDF/SVG generation can be expensive.
        // Use a PNG blob as a proxy: PDF currently embeds a PNG; SVG embeds a PNG data URI.
        const needsPngProxy = exportFormat === 'pdf' || exportFormat === 'svg';
        let pngProxyBytes = 0;
        if (needsPngProxy) {
          const pngBlob = await canvasToBlob(cvs, 'image/png');
          pngProxyBytes = pngBlob ? pngBlob.size : 0;
        }

        if (exportFormat === 'png') {
          const blob = await canvasToBlob(cvs, 'image/png');
          bytes = blob ? blob.size : 0;
        } else if (exportFormat === 'jpg') {
          const blob = await canvasToBlob(cvs, 'image/jpeg', exportQuality / 100);
          bytes = blob ? blob.size : 0;
        } else if (exportFormat === 'svg') {
          // Approx: base64 expands ~4/3 plus a small markup overhead.
          bytes = pngProxyBytes ? Math.round(pngProxyBytes * 4 / 3 + 512) : 0;
        } else if (exportFormat === 'pdf') {
          // PDF currently embeds a PNG; add a small constant for PDF container overhead.
          bytes = pngProxyBytes ? Math.round(pngProxyBytes + 2048) : 0;
        }

        if (token !== exportSizeEstimateToken) return;
        if (!modal || modal.style.display === 'none') return;

        const pretty = bytes ? formatBytes(bytes) : '—';
        if (sizeInfo) sizeInfo.textContent = `${dims.width} × ${dims.height} px (~${pretty})`;
      } catch {
        if (token !== exportSizeEstimateToken) return;
        const sizeInfo = document.getElementById('export-size-info');
        if (sizeInfo) sizeInfo.textContent = `${dims.width} × ${dims.height} px`;
      }
    }

    function updateExportFilenameExtension() {
      const input = getExportFilenameInputEl();
      if (!input) return;
      const baseFromInput = stripKnownExtension(input.value);
      const base = sanitizeFilenameBase(baseFromInput || getProjectNameValue() || EXPORT_FILENAME_DEFAULT);
      input.value = base;
    }
    
    // Open export modal
    function downloadImage() {
      openExportModal();
    }
    
    function openExportModal() {
      const modal = document.getElementById('export-modal');
      modal.style.display = 'flex';

      // Ensure exportFormat matches current UI selection
      const activeFormatPill = document.querySelector('#format-pills .pill.active');
      if (activeFormatPill && activeFormatPill.dataset && activeFormatPill.dataset.format) {
        exportFormat = activeFormatPill.dataset.format;
      }
      
      // Get canvas size and set initial custom sizes
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      exportAspectRatio = canvasW / canvasH;
      exportCustomWidth = canvasW * exportScale;
      exportCustomHeight = canvasH * exportScale;
      document.getElementById('export-width').value = exportCustomWidth;
      document.getElementById('export-height').value = exportCustomHeight;
      
      // Setup format pills
      document.querySelectorAll('#format-pills .pill').forEach(pill => {
        pill.onclick = () => {
          document.querySelectorAll('#format-pills .pill').forEach(p => p.classList.remove('active'));
          pill.classList.add('active');
          exportFormat = pill.dataset.format;
          // Show/hide quality slider based on format
          const qualityGroup = document.getElementById('quality-group');
          qualityGroup.style.display = (exportFormat === 'jpg') ? 'block' : 'none';
          updateExportFilenameExtension();
          updateExportPreview();
        };
      });

      // Setup filename input
      const filenameInput = getExportFilenameInputEl();
      if (filenameInput) {
        filenameInput.onblur = () => updateExportFilenameExtension();
        filenameInput.onkeydown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            updateExportFilenameExtension();
            doExport();
          }
        };
        updateExportFilenameExtension();
      }
      
      // Initial quality visibility
      document.getElementById('quality-group').style.display = (exportFormat === 'jpg') ? 'block' : 'none';
      
      // Setup size pills
      document.querySelectorAll('#size-pills .pill').forEach(pill => {
        pill.onclick = () => {
          document.querySelectorAll('#size-pills .pill').forEach(p => p.classList.remove('active'));
          pill.classList.add('active');
          exportScale = parseInt(pill.dataset.scale);
          updateExportPreview();
        };
      });
      
      // Quality slider
      const qualitySlider = document.getElementById('export-quality');
      const qualityLabel = document.getElementById('quality-label');
      qualitySlider.oninput = () => {
        exportQuality = parseInt(qualitySlider.value);
        qualityLabel.textContent = exportQuality + '%';
      };
      
      // Radius slider
      const radiusSlider = document.getElementById('export-radius');
      const radiusLabel = document.getElementById('radius-label');
      radiusSlider.oninput = () => {
        exportRadius = parseInt(radiusSlider.value);
        radiusLabel.textContent = exportRadius + 'px';
        updateExportPreview();
      };
      
      updateExportPreview();
    }
    
    function setSizeMode(mode) {
      exportSizeMode = mode;
      document.getElementById('size-mode-scale').classList.toggle('active', mode === 'scale');
      document.getElementById('size-mode-custom').classList.toggle('active', mode === 'custom');
      document.getElementById('scale-options').style.display = mode === 'scale' ? 'block' : 'none';
      document.getElementById('custom-size-options').style.display = mode === 'custom' ? 'block' : 'none';
      
      if (mode === 'custom') {
        const canvasEl = document.getElementById('canvas');
        const canvasW = parseInt(canvasEl.style.width);
        const canvasH = parseInt(canvasEl.style.height);
        exportCustomWidth = canvasW * exportScale;
        exportCustomHeight = canvasH * exportScale;
        document.getElementById('export-width').value = exportCustomWidth;
        document.getElementById('export-height').value = exportCustomHeight;
      }
      
      updateExportPreview();
    }
    
    function updateExportSize() {
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      const widthInput = document.getElementById('export-width');
      const heightInput = document.getElementById('export-height');
      
      exportCustomWidth = parseInt(widthInput.value) || canvasW;
      exportCustomHeight = parseInt(heightInput.value) || canvasH;
      
      // Clamp values
      exportCustomWidth = Math.min(4096, Math.max(100, exportCustomWidth));
      exportCustomHeight = Math.min(4096, Math.max(100, exportCustomHeight));
      
      widthInput.value = exportCustomWidth;
      heightInput.value = exportCustomHeight;
      
      updateExportPreview();
    }
    
    function toggleLockRatio() {
      exportLockRatio = !exportLockRatio;
      const btn = document.getElementById('lock-ratio-btn');
      btn.innerHTML = exportLockRatio ? '<i class="fa-solid fa-lock"></i>' : '<i class="fa-solid fa-lock-open"></i>';
      btn.classList.toggle('active', exportLockRatio);
      
      if (exportLockRatio) {
        const canvasEl = document.getElementById('canvas');
        const canvasW = parseInt(canvasEl.style.width);
        const canvasH = parseInt(canvasEl.style.height);
        exportAspectRatio = canvasW / canvasH;
      }
    }
    
    // Update height when width changes (if locked)
    document.addEventListener('DOMContentLoaded', () => {
      const widthInput = document.getElementById('export-width');
      const heightInput = document.getElementById('export-height');
      
      if (widthInput) {
        widthInput.addEventListener('input', () => {
          if (exportLockRatio) {
            const w = parseInt(widthInput.value) || 800;
            heightInput.value = Math.round(w / exportAspectRatio);
          }
        });
      }
      
      if (heightInput) {
        heightInput.addEventListener('input', () => {
          if (exportLockRatio) {
            const h = parseInt(heightInput.value) || 800;
            widthInput.value = Math.round(h * exportAspectRatio);
          }
        });
      }
    });
    
    function closeExportModal() {
      document.getElementById('export-modal').style.display = 'none';
    }
    
    function getExportDimensions() {
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      
      if (exportSizeMode === 'custom') {
        return { width: exportCustomWidth, height: exportCustomHeight };
      } else {
        return { width: canvasW * exportScale, height: canvasH * exportScale };
      }
    }
    
    function updateExportPreview() {
      const previewCanvas = document.getElementById('export-preview-canvas');
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      
      previewCanvas.width = canvasW;
      previewCanvas.height = canvasH;
      const ctx = previewCanvas.getContext('2d');
      
      // Draw with rounded corners
      ctx.save();
      if (exportRadius > 0) {
        ctx.beginPath();
        ctx.roundRect(0, 0, canvasW, canvasH, exportRadius);
        ctx.clip();
      }
      
      // Background
      ctx.fillStyle = canvasEl.style.backgroundColor || '#fff';
      ctx.fillRect(0, 0, canvasW, canvasH);
      
      // Draw elements
      drawElementsToContext(ctx, 1);
      ctx.restore();
      
      // Update size info
      const dims = getExportDimensions();
      const sizeInfo = document.getElementById('export-size-info');
      if (sizeInfo) sizeInfo.textContent = `${dims.width} × ${dims.height} px`;
      scheduleEstimateExportFileSize(dims);
    }
    
    function drawElementsToContext(ctx, scale) {
      for (const el of elements) {
        const angle = (normalizeRotation(el.rotation) * Math.PI) / 180;
        const opacity = el.opacity !== undefined ? el.opacity / 100 : 1;
        const flipX = el && el.flipX ? -1 : 1;
        const flipY = el && el.flipY ? -1 : 1;
        
        if (el.type === 'qr') {
          const baseImg = document.querySelector(`#${el.id} img.qr-base`) || document.querySelector(`#${el.id} .qr-content img`);
          if (baseImg) {
            ctx.save();
            ctx.globalAlpha = opacity;
            const centerX = el.x + el.width / 2;
            const centerY = el.y + el.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(angle);
            ctx.scale(flipX, flipY);
            ctx.drawImage(baseImg, -el.width / 2, -el.height / 2, el.width, el.height);
            ctx.restore();
          }
        } else if (el.type === 'text') {
          ctx.save();
          ctx.globalAlpha = opacity;
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          ctx.scale(flipX, flipY);
          
          if (el.bgColor) {
            ctx.fillStyle = el.bgColor;
            ctx.fillRect(-el.width / 2, -el.height / 2, el.width, el.height);
          }
          
          const fontFamily = el.fontFamily || 'Be Vietnam Pro';
          const fontWeight = el.bold ? 'bold' : 'normal';
          const fontStyle = el.italic ? 'italic' : 'normal';
          ctx.font = `${fontStyle} ${fontWeight} ${el.fontSize}px "${fontFamily}", sans-serif`;
          ctx.fillStyle = el.color;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          if (el.shadow) {
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
          }
          
          ctx.fillText(el.text, 0, 0);
          
          if (el.underline) {
            ctx.shadowColor = 'transparent';
            const textWidth = ctx.measureText(el.text).width;
            ctx.beginPath();
            ctx.strokeStyle = el.color;
            ctx.lineWidth = Math.max(1, el.fontSize / 15);
            ctx.moveTo(-textWidth / 2, el.fontSize / 3);
            ctx.lineTo(textWidth / 2, el.fontSize / 3);
            ctx.stroke();
          }
          
          ctx.restore();
        } else if (el.type === 'shape') {
          ctx.save();
          ctx.globalAlpha = opacity;
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          ctx.scale(flipX, flipY);
          
          const w = el.width;
          const h = el.height;
          const fill = el.fill || '#7c3aed';
          const stroke = el.stroke || '';
          const shape = el.shapeType || 'rect';
          
          ctx.fillStyle = fill;
          if (stroke) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 2;
          }
          
          ctx.beginPath();
          
          // Draw different shapes
          switch (shape) {
            case 'circle':
            case 'ellipse':
              ctx.ellipse(0, 0, w / 2, h / 2, 0, 0, Math.PI * 2);
              break;
            case 'triangle':
              ctx.moveTo(0, -h / 2);
              ctx.lineTo(w / 2, h / 2);
              ctx.lineTo(-w / 2, h / 2);
              ctx.closePath();
              break;
            case 'diamond':
            case 'rhombus':
              ctx.moveTo(0, -h / 2);
              ctx.lineTo(w / 2, 0);
              ctx.lineTo(0, h / 2);
              ctx.lineTo(-w / 2, 0);
              ctx.closePath();
              break;
            case 'pentagon':
              drawPolygon(ctx, 5, w / 2, h / 2);
              break;
            case 'hexagon':
              drawPolygon(ctx, 6, w / 2, h / 2);
              break;
            case 'octagon':
              drawPolygon(ctx, 8, w / 2, h / 2);
              break;
            case 'star':
            case 'star-4':
            case 'star-5':
            case 'star-6':
              const points = shape === 'star-4' ? 4 : (shape === 'star-6' ? 6 : 5);
              drawStar(ctx, points, w / 2, h / 2, w / 4, h / 4);
              break;
            case 'heart':
              drawHeart(ctx, w, h);
              break;
            case 'arrow-right':
            case 'arrow-left':
            case 'arrow-up':
            case 'arrow-down':
              drawArrow(ctx, w, h, shape);
              break;
            case 'cross':
            case 'plus':
              drawCross(ctx, w, h);
              break;
            case 'rounded':
              const r = Math.min(el.borderRadius || 12, w / 2, h / 2);
              ctx.roundRect(-w / 2, -h / 2, w, h, r);
              break;
            default:
              // Default rectangle
              ctx.rect(-w / 2, -h / 2, w, h);
          }
          
          ctx.fill();
          if (stroke) ctx.stroke();
          ctx.restore();
        }
      }
    }
    
    // Helper functions for drawing shapes on canvas
    function drawPolygon(ctx, sides, rx, ry) {
      for (let i = 0; i < sides; i++) {
        const angle = (Math.PI * 2 * i / sides) - Math.PI / 2;
        const x = Math.cos(angle) * rx;
        const y = Math.sin(angle) * ry;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
    }
    
    function drawStar(ctx, points, outerRx, outerRy, innerRx, innerRy) {
      for (let i = 0; i < points * 2; i++) {
        const angle = (Math.PI * 2 * i / (points * 2)) - Math.PI / 2;
        const rx = i % 2 === 0 ? outerRx : innerRx;
        const ry = i % 2 === 0 ? outerRy : innerRy;
        const x = Math.cos(angle) * rx;
        const y = Math.sin(angle) * ry;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
    }
    
    function drawHeart(ctx, w, h) {
      const x = -w / 2;
      const y = -h / 2;
      ctx.moveTo(x + w / 2, y + h / 4);
      ctx.bezierCurveTo(x + w / 2, y, x, y, x, y + h / 4);
      ctx.bezierCurveTo(x, y + h / 2, x + w / 2, y + h * 0.7, x + w / 2, y + h);
      ctx.bezierCurveTo(x + w / 2, y + h * 0.7, x + w, y + h / 2, x + w, y + h / 4);
      ctx.bezierCurveTo(x + w, y, x + w / 2, y, x + w / 2, y + h / 4);
      ctx.closePath();
    }
    
    function drawArrow(ctx, w, h, direction) {
      const hw = w / 2, hh = h / 2;
      ctx.save();
      if (direction === 'arrow-left') ctx.rotate(Math.PI);
      else if (direction === 'arrow-up') ctx.rotate(-Math.PI / 2);
      else if (direction === 'arrow-down') ctx.rotate(Math.PI / 2);
      
      ctx.moveTo(hw, 0);
      ctx.lineTo(0, -hh);
      ctx.lineTo(0, -hh / 3);
      ctx.lineTo(-hw, -hh / 3);
      ctx.lineTo(-hw, hh / 3);
      ctx.lineTo(0, hh / 3);
      ctx.lineTo(0, hh);
      ctx.closePath();
      ctx.restore();
    }
    
    function drawCross(ctx, w, h) {
      const t = Math.min(w, h) / 3;
      ctx.moveTo(-t / 2, -h / 2);
      ctx.lineTo(t / 2, -h / 2);
      ctx.lineTo(t / 2, -t / 2);
      ctx.lineTo(w / 2, -t / 2);
      ctx.lineTo(w / 2, t / 2);
      ctx.lineTo(t / 2, t / 2);
      ctx.lineTo(t / 2, h / 2);
      ctx.lineTo(-t / 2, h / 2);
      ctx.lineTo(-t / 2, t / 2);
      ctx.lineTo(-w / 2, t / 2);
      ctx.lineTo(-w / 2, -t / 2);
      ctx.lineTo(-t / 2, -t / 2);
      ctx.closePath();
    }
    
    async function doExport() {
      const canvasEl = document.getElementById('canvas');
      const filenameBase = getExportFilenameBaseFromUI();
      const filename = filenameBase || EXPORT_FILENAME_DEFAULT;
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);
      
      // Get export dimensions
      const dims = getExportDimensions();
      const scaleX = dims.width / canvasW;
      const scaleY = dims.height / canvasH;
      
      const cvs = document.createElement('canvas');
      cvs.width = dims.width;
      cvs.height = dims.height;
      const ctx = cvs.getContext('2d');
      ctx.scale(scaleX, scaleY);
      
      // Draw with rounded corners (scaled)
      const scaledRadius = exportRadius * Math.min(scaleX, scaleY);
      ctx.save();
      if (exportRadius > 0) {
        ctx.beginPath();
        ctx.roundRect(0, 0, canvasW, canvasH, exportRadius);
        ctx.clip();
      }
      
      // Background
      ctx.fillStyle = canvasEl.style.backgroundColor || '#fff';
      ctx.fillRect(0, 0, canvasW, canvasH);
      
      // Draw elements
      drawElementsToContext(ctx, scaleX);
      ctx.restore();
      
      // Export based on format
      const link = document.createElement('a');
      
      if (exportFormat === 'png') {
        link.download = filename + '.png';
        link.href = cvs.toDataURL('image/png');
        link.click();
        trackDownloadEvent();
      } else if (exportFormat === 'jpg') {
        link.download = filename + '.jpg';
        link.href = cvs.toDataURL('image/jpeg', exportQuality / 100);
        link.click();
        trackDownloadEvent();
      } else if (exportFormat === 'svg') {
        // Create SVG (simplified - just embed the PNG)
        const dataUrl = cvs.toDataURL('image/png');
        const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${dims.width}" height="${dims.height}">
  <image xlink:href="${dataUrl}" width="${dims.width}" height="${dims.height}"/>
</svg>`;
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        link.download = filename + '.svg';
        link.href = URL.createObjectURL(blob);
        link.click();
        trackDownloadEvent();
      } else if (exportFormat === 'pdf') {
        const jsPDFCtor = window.jspdf && window.jspdf.jsPDF;
        if (!jsPDFCtor) {
          alert((typeof t === 'function') ? t('alert.pdfNoJsPdfPngInstead') : 'PDF export requires jsPDF library. Downloading as PNG instead.');
          link.download = filename + '.png';
          link.href = cvs.toDataURL('image/png');
          link.click();
          trackDownloadEvent();
        } else {
          const ptPerPx = 72 / 96;
          const pdfW = dims.width * ptPerPx;
          const pdfH = dims.height * ptPerPx;
          const orientation = pdfW >= pdfH ? 'l' : 'p';
          const doc = new jsPDFCtor({ orientation, unit: 'pt', format: [pdfW, pdfH] });
          const dataUrl = cvs.toDataURL('image/png');
          doc.addImage(dataUrl, 'PNG', 0, 0, pdfW, pdfH, undefined, 'FAST');
          doc.save(filename + '.pdf');
          trackDownloadEvent();
        }
      }
      
      closeExportModal();
    }

    function trackDownloadEvent() {
      try {
        const payload = new Blob([
          JSON.stringify({
            qr_type: currentQRType || 'url'
          })
        ], { type: 'application/json' });

        if (navigator.sendBeacon) {
          navigator.sendBeacon('/api/track-download', payload);
          return;
        }

        fetch('/api/track-download', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ qr_type: currentQRType || 'url' }),
          keepalive: true,
        }).catch(() => {});
      } catch {
        // ignore
      }
    }

    // Download image (legacy - now opens modal)
    async function downloadImageDirect() {
      const canvasEl = document.getElementById('canvas');
      const filename = (getProjectNameValue() || 'qr_design').replace(/[\\\/\:\*\?\"\<\>\|]+/g, ' ').trim() || 'qr_design';

      // Use html2canvas approach - create a canvas manually
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);

      const cvs = document.createElement('canvas');
      cvs.width = canvasW * 2; // 2x for quality
      cvs.height = canvasH * 2;
      const ctx = cvs.getContext('2d');
      ctx.scale(2, 2);

      // Background
      ctx.fillStyle = canvasEl.style.backgroundColor || '#fff';
      ctx.fillRect(0, 0, canvasW, canvasH);

      // Draw elements
      for (const el of elements) {
        const angle = (normalizeRotation(el.rotation) * Math.PI) / 180;
        const opacity = el.opacity !== undefined ? el.opacity / 100 : 1;
        
        if (el.type === 'qr') {
          const baseImg = document.querySelector(`#${el.id} img.qr-base`) || document.querySelector(`#${el.id} .qr-content img`);
          if (baseImg) {
            ctx.save();
            ctx.globalAlpha = opacity;
            const centerX = el.x + el.width / 2;
            const centerY = el.y + el.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(angle);
            ctx.drawImage(baseImg, -el.width / 2, -el.height / 2, el.width, el.height);
            ctx.restore();
          }
        } else if (el.type === 'text') {
          ctx.save();
          ctx.globalAlpha = opacity;
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          
          // Background
          if (el.bgColor) {
            ctx.fillStyle = el.bgColor;
            ctx.fillRect(-el.width / 2, -el.height / 2, el.width, el.height);
          }
          
          // Font styling
          const fontFamily = el.fontFamily || 'Be Vietnam Pro';
          const fontWeight = el.bold ? 'bold' : 'normal';
          const fontStyle = el.italic ? 'italic' : 'normal';
          ctx.font = `${fontStyle} ${fontWeight} ${el.fontSize}px "${fontFamily}", sans-serif`;
          ctx.fillStyle = el.color;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Shadow
          if (el.shadow) {
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
          }
          
          ctx.fillText(el.text, 0, 0);
          
          // Underline
          if (el.underline) {
            ctx.shadowColor = 'transparent';
            const textWidth = ctx.measureText(el.text).width;
            ctx.beginPath();
            ctx.strokeStyle = el.color;
            ctx.lineWidth = Math.max(1, el.fontSize / 15);
            ctx.moveTo(-textWidth / 2, el.fontSize / 3);
            ctx.lineTo(textWidth / 2, el.fontSize / 3);
            ctx.stroke();
          }
          
          ctx.restore();
        }
      }

      // Download
      const link = document.createElement('a');
      link.download = filename + '.png';
      link.href = cvs.toDataURL('image/png');
      link.click();
    }

    // Copy to clipboard
    async function copyToClipboard() {
      const canvasEl = document.getElementById('canvas');
      const canvasW = parseInt(canvasEl.style.width);
      const canvasH = parseInt(canvasEl.style.height);

      const cvs = document.createElement('canvas');
      cvs.width = canvasW * 2;
      cvs.height = canvasH * 2;
      const ctx = cvs.getContext('2d');
      ctx.scale(2, 2);

      ctx.fillStyle = canvasEl.style.backgroundColor || '#fff';
      ctx.fillRect(0, 0, canvasW, canvasH);

      for (const el of elements) {
        const angle = (normalizeRotation(el.rotation) * Math.PI) / 180;
        const opacity = el.opacity !== undefined ? el.opacity / 100 : 1;
        
        if (el.type === 'qr') {
          const baseImg = document.querySelector(`#${el.id} img.qr-base`) || document.querySelector(`#${el.id} .qr-content img`);
          if (baseImg) {
            ctx.save();
            ctx.globalAlpha = opacity;
            const centerX = el.x + el.width / 2;
            const centerY = el.y + el.height / 2;
            ctx.translate(centerX, centerY);
            ctx.rotate(angle);
            ctx.drawImage(baseImg, -el.width / 2, -el.height / 2, el.width, el.height);
            ctx.restore();
          }
        } else if (el.type === 'text') {
          ctx.save();
          ctx.globalAlpha = opacity;
          const centerX = el.x + el.width / 2;
          const centerY = el.y + el.height / 2;
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          
          // Background
          if (el.bgColor) {
            ctx.fillStyle = el.bgColor;
            ctx.fillRect(-el.width / 2, -el.height / 2, el.width, el.height);
          }
          
          // Font styling
          const fontFamily = el.fontFamily || 'Be Vietnam Pro';
          const fontWeight = el.bold ? 'bold' : 'normal';
          const fontStyle = el.italic ? 'italic' : 'normal';
          ctx.font = `${fontStyle} ${fontWeight} ${el.fontSize}px "${fontFamily}", sans-serif`;
          ctx.fillStyle = el.color;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Shadow
          if (el.shadow) {
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
          }
          
          ctx.fillText(el.text, 0, 0);
          
          // Underline
          if (el.underline) {
            ctx.shadowColor = 'transparent';
            const textWidth = ctx.measureText(el.text).width;
            ctx.beginPath();
            ctx.strokeStyle = el.color;
            ctx.lineWidth = Math.max(1, el.fontSize / 15);
            ctx.moveTo(-textWidth / 2, el.fontSize / 3);
            ctx.lineTo(textWidth / 2, el.fontSize / 3);
            ctx.stroke();
          }
          
          ctx.restore();
        }
      }

      cvs.toBlob(blob => {
        navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })])
          .then(() => alert((typeof t === 'function') ? t('alert.copySuccess') : '✅ Đã copy!'))
          .catch(err => alert((typeof t === 'function') ? t('alert.copyFail', { msg: err.message }) : ('❌ ' + err.message)));
      });
    }

    // Keyboard shortcut for delete/backspace - only when not editing
    document.addEventListener('keydown', (e) => {
      // Skip if we're in an input, textarea, or contenteditable
      const activeEl = document.activeElement;
      const isEditing = activeEl && (
        activeEl.tagName === 'INPUT' ||
        activeEl.tagName === 'TEXTAREA' ||
        activeEl.contentEditable === 'true' ||
        activeEl.closest('[contenteditable="true"]')
      );
      
      if (isEditing) return;
      
      // Ctrl/Cmd + C: Copy
      if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
        if (selectedIds.size > 0) {
          e.preventDefault();
          copySelected();
        }
      }
      
      // Ctrl/Cmd + V: Paste
      if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
        if (clipboard.length > 0) {
          e.preventDefault();
          pasteClipboard();
        }
      }
      
      // Ctrl/Cmd + D: Duplicate
      if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
        if (selectedIds.size > 0) {
          e.preventDefault();
          duplicateSelected();
        }
      }
      
      // Ctrl/Cmd + Z: Undo (always works)
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
        updateFloatingToolbar();
      }
      
      // Ctrl/Cmd + Shift + Z or Ctrl + Y: Redo (always works)
      if ((e.ctrlKey || e.metaKey) && ((e.key === 'z' && e.shiftKey) || e.key === 'y')) {
        e.preventDefault();
        redo();
        updateFloatingToolbar();
      }
      
      // Ctrl/Cmd + A: Select all
      if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
        e.preventDefault();
        elements.forEach(el => selectedIds.add(el.id));
        refreshSelectionStyles();
        updateMultiSelectBox();
        showElementProps();
      }
      
      // Delete or Backspace: Delete selected
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectedIds.size > 0) {
          e.preventDefault();
          deleteSelected();
        }
      }
      
      // Escape to exit inline editing or clear selection
      if (e.key === 'Escape') {
        if (editingTextId) {
          exitInlineEdit();
        } else {
          clearSelection();
        }
      }
      
      // Arrow keys: move selected elements
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        if (selectedIds.size > 0) {
          e.preventDefault();
          const step = e.shiftKey ? 10 : 1;
          const dx = e.key === 'ArrowLeft' ? -step : e.key === 'ArrowRight' ? step : 0;
          const dy = e.key === 'ArrowUp' ? -step : e.key === 'ArrowDown' ? step : 0;
          saveToHistory();
          elements.filter(el => selectedIds.has(el.id)).forEach(el => {
            el.x += dx;
            el.y += dy;
            updateElementPosition(el);
          });
          updateMultiSelectBox();
          showElementProps();
        }
      }
    });

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded fired, calling init...');
      init();
    });

    // Also call immediately in case DOM is already loaded
    if (document.readyState === 'loading') {
      console.log('Document still loading, will wait for DOMContentLoaded');
    } else {
      console.log('Document already loaded, calling init immediately');
      init();
    }
  </script>
</body>
</html>